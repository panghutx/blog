{"meta":{"title":"胖虎同学","subtitle":"生活学习类个人博客","description":"普通本科生的个人博客，分享日常生活、学习笔记，记录美好与成长","author":"胖虎同学","url":"https://youngsay.cn","root":"/"},"pages":[{"title":"关于","date":"2022-01-05T05:43:53.099Z","updated":"2022-01-05T05:43:53.099Z","comments":true,"path":"about/index.html","permalink":"https://youngsay.cn/about/index.html","excerpt":"","text":"我是胖虎同学，现在是一名大二学生，未来想做码农~这是我的个人博客。 博客主要记录我的学习笔记和心得感悟，欢迎常来，感谢您的来访和评论。"},{"title":"","date":"2021-10-08T03:01:26.189Z","updated":"2021-03-28T06:27:59.530Z","comments":true,"path":"mylist/index.html","permalink":"https://youngsay.cn/mylist/index.html","excerpt":"","text":""},{"title":"","date":"2021-06-18T04:08:38.003Z","updated":"2021-06-18T04:06:40.582Z","comments":true,"path":"photos/photosInfo.json","permalink":"https://youngsay.cn/photos/photosInfo.json","excerpt":"","text":"[]"},{"title":"","date":"2021-06-18T03:48:04.150Z","updated":"2021-06-18T03:48:04.150Z","comments":false,"path":"photos/index.html","permalink":"https://youngsay.cn/photos/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-01-11T00:51:19.187Z","updated":"2022-01-11T00:51:19.187Z","comments":true,"path":"link/index.html","permalink":"https://youngsay.cn/link/index.html","excerpt":"","text":"站点信息感谢访问本站，欢迎互换友链。 网站正常更新 添加本站友链 12345title: 胖虎同学avatar: https://cdn.jsdelivr.net/gh/panghutx/CDN/logo-dog.jpgurl: https://youngsay.cnkeywords: [日常, 学习, 分享]description: 记录生活与成长"},{"title":"说说","date":"2021-06-02T11:57:17.546Z","updated":"2021-04-01T02:57:19.881Z","comments":true,"path":"talk/index.html","permalink":"https://youngsay.cn/talk/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-01-11T00:40:42.557Z","updated":"2022-01-11T00:40:42.557Z","comments":true,"path":"tags/index.html","permalink":"https://youngsay.cn/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-06-18T04:08:33.497Z","updated":"2021-06-18T04:06:40.582Z","comments":true,"path":"photos/photos.json","permalink":"https://youngsay.cn/photos/photos.json","excerpt":"","text":"[]"},{"title":"所有分类","date":"2022-01-11T00:42:00.265Z","updated":"2022-01-11T00:42:00.265Z","comments":true,"path":"categories/index.html","permalink":"https://youngsay.cn/categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-01-05T03:35:30.891Z","updated":"2022-01-05T03:35:30.891Z","comments":true,"path":"search/index.html","permalink":"https://youngsay.cn/search/index.html","excerpt":"","text":""}],"posts":[{"title":"C语言实现简单的扫雷游戏","slug":"sweep-mine","date":"2022-02-09T10:22:01.000Z","updated":"2022-02-09T10:23:00.624Z","comments":true,"path":"2022/02/09/sweep-mine/","link":"","permalink":"https://youngsay.cn/2022/02/09/sweep-mine/","excerpt":"","text":"《扫雷》是一款大众类的益智小游戏，游戏目标是在最短的时间内根据点击格子出现的数字找出所有非雷格子，同时避免踩雷，踩到一个雷即全盘皆输。 这篇博客教大家用C语言制作一个简易版扫雷游戏，和之前的井字棋大同小异。 我们准备三个文件,分别为game.c,test.c,game.h game.c文件用来写实现游戏功能的各个函数代码,test.c文件写游戏的总流程,game.h文件用来声明函数和初始值. 先看test.c，由menu()``game()``main()三个函数组成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&quot;game.h&quot;menu()&#123; printf(&quot;--------------------\\n&quot;); printf(&quot;-----1.开始游戏-----\\n&quot;); printf(&quot;-----2.退出游戏-----\\n&quot;); printf(&quot;--------------------\\n&quot;);&#125;game()&#123; //棋盘——后台 char mine[ROWS][COLS] = &#123; 0 &#125;; //棋盘——玩家 char show[ROWS][COLS] = &#123; 0 &#125;; //初始化棋盘 init_arr(mine, ROWS, COLS,&#x27;0&#x27;); init_arr(show, ROWS, COLS, &#x27;*&#x27;); //打印棋盘 display_arr(show, ROW, COL); //display_arr(mine, ROW, COL); //放炸弹 set_mine(mine, ROW, COL); //排雷 set_coordinate(mine, show, ROW, COL); &#125;int main()&#123; srand((unsigned int)time(NULL)); int input = 0; do &#123; menu(); printf(&quot;请输入选项&gt;\\n&quot;); scanf(&quot;%d&quot;, &amp;input); switch (input) &#123; case 1: game(); break; case 2: printf(&quot;退出游戏\\n&quot;); break; default: printf(&quot;输入错误，请重新输入\\n&quot;); break; &#125; &#125; while (1);&#125; 下面是game.h头文件,文件内是头文件的引用,数据的初始化,游戏函数的定义 12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#define ROWS 11#define COLS 11#define ROW 9#define COL 9#define MINE 10//初始化棋盘void init_arr(char arr[ROWS][COLS], int rows, int cols,char set);//打印棋盘void display_arr(char arr[ROWS][COLS], int row, int col);//放炸弹void set_mine(char arr[ROWS][COLS], int row, int col);//排雷void set_coordinate(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col); 我们定义了两个棋盘，一个用来放雷（玩家看不到），一个用来展示玩家选定的位置四周的地雷数。如果是9x9的棋盘，当玩家选择边界位置（如1 1），程序检索其四周的地雷会造成越界访问，所以将棋盘做成11x11，但只打印9x9给玩家。 下面是game.c文件，我们来看下各个函数是如何实现的。 首先是初始化棋盘init_arr 12345678910void init_arr(char arr[ROWS][COLS], int rows, int cols,char set)&#123; int i = 0; int j = 0; for (i = 0; i &lt; rows; i++) &#123; for (j = 0; j &lt; cols; j++) &#123; arr[i][j] = set; &#125; &#125;&#125; 形参有4个，分别是棋盘，行数，列数，放置的元素。便利整个棋盘，将棋盘初始化。mine棋盘初始化为0，表示不是地雷，1表示地雷；show棋盘初始化为*，展示给玩家。 接着是打印棋盘display_arr 12345678910111213141516171819void display_arr(char arr[ROWS][COLS], int row, int col)&#123; int i = 0; int j = 0; //打印一个列号【列号就是单独的一行】 for (i = 0; i &lt;= row; i++) &#123; printf(&quot;%d &quot;, i); &#125; printf(&quot;\\n&quot;); for (i = 1; i &lt;= row; i++) &#123; //打印一个行号【行号就是单独的一列】 printf(&quot;%d &quot;, i); for (j = 1; j &lt;= col; j++) &#123; printf(&quot;%c &quot;, arr[i][j]); &#125; printf(&quot;\\n&quot;); &#125;&#125; 传入的参数的棋盘，行数，列数，注意这里的行数列数都是9，与初始化不同。为了方便玩家操作，我们在棋盘上标上对应的行数和列数，如下图所示。 接下来布置地雷set_mine 123456789101112131415void set_mine(char arr[ROWS][COLS], int row, int col)&#123; int x = 0; int y = 0; int count = 0; while ( count &lt; MINE) &#123; x = rand() % row + 1; y = rand() % col + 1; if (arr[x][y] == &#x27;0&#x27;) &#123; arr[x][y] = &#x27;1&#x27;; count++; &#125; &#125;&#125; MINE是10，当count&lt;10,生成1-9的随机数，如果坐标位置是0，将该位置置为地雷，count++，直到地雷数为10。 最后是排雷set_coordinate 12345678910111213141516171819202122232425262728293031323334353637383940414243int howmuch_mine(char mine[ROWS][COLS],int x,int y)&#123; return mine[x][y + 1] + mine[x - 1][y + 1] + mine[x - 1][y] + mine[x - 1][y - 1] + mine[x][y - 1] + mine[x + 1][y - 1] + mine[x + 1][y] + mine[x + 1][y + 1] - 8 * &#x27;0&#x27;;&#125;//排雷void set_coordinate(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)&#123; int x = 0; int y = 0; int counts = 0; while (counts&lt;(ROW*COL-MINE)) &#123; printf(&quot;输入坐标&gt;\\n&quot;); scanf(&quot;%d %d&quot;, &amp;x, &amp;y); if (x &gt;=1 || x&lt;=col &amp;&amp; y &gt;&gt;1 || y&lt;=col) &#123; if (show[x][y] == &#x27;*&#x27;) &#123; if (mine[x][y] == &#x27;1&#x27;) &#123; printf(&quot;很遗憾，你被炸了！\\n&quot;); display_arr(mine, ROW, COL); break; &#125; else &#123; //计算炸弹数 int count = howmuch_mine(mine, x, y); show[x][y] = count + &#x27;0&#x27;; display_arr(show, ROW, COL); counts++; &#125; &#125; else &#123; printf(&quot;坐标已被占用，请重新输入\\n&quot;); &#125; &#125; else &#123; printf(&quot;坐标非法，请重新输入&quot;); &#125; &#125; if (counts == (ROW * COL - MINE)) &#123; printf(&quot;恭喜你，排雷成功\\n&quot;); display_arr(mine, ROW, COL); &#125; &#125; 输入坐标，判断坐标的合法性，当坐标合法时，如果坐标处是地雷，结束游戏。如果坐标处不是地雷，将show棋盘坐标处的*改成炸弹数，这里需要计算炸弹数，单独写成howmuch_mine函数。函数逻辑是将mine棋盘坐标处四周的元素（8个）相加，无外乎就是字符0或1，再减去8x字符‘0’，这样结果就是地雷个数。 游戏怎样终止呢，排雷成功的条件是什么？9x9的棋盘，10个地雷，理应排71次，将排雷流程写入while语句，定义次数counts，当counts小于71，进入循环，成功排雷1次counts+1，如此往复。跳出while循环后，如果counts为71，排雷成功，打印地雷棋盘mine。 大概思路就是这样，一个简单的扫雷游戏就做好了，哪里有错误欢迎评论区指出。","categories":[{"name":"分享","slug":"分享","permalink":"https://youngsay.cn/categories/%E5%88%86%E4%BA%AB/"}],"tags":[]},{"title":"你有无一段游戏人生？","slug":"game-life","date":"2022-02-06T12:39:01.000Z","updated":"2022-02-06T12:48:19.900Z","comments":true,"path":"2022/02/06/game-life/","link":"","permalink":"https://youngsay.cn/2022/02/06/game-life/","excerpt":"","text":"今天初六了，眼看新年假期就要结束了，今天是打工人的最后一天假期，我也快该开学了。祝各位朋友新的一年健康快乐，工作顺利，学业进步！ 过年这半个月我又一次地沉迷游戏，这篇博客就来聊聊游戏。从小我就是个游戏迷，没少花时间玩游戏，穿越火线，qq飞车，dnf，逆战，大冲锋，反恐行动，兽人必须死，上古世纪，枪神纪等，这些游戏伴随了我的小初高中，高考结束后又玩上了人类一败涂地，糖豆人等，现在偶尔玩下糖豆人，枪神纪。有时闲来无聊会搜下小时候玩过的游戏，发现已经停服，多少有些感慨。 我玩的时间最久的是穿越火线和枪神纪。说到玩游戏，我觉得我大多数情况下不是玩游戏，而是沉迷游戏。 为什么会沉迷游戏？我觉得主要是游戏好玩，还有就是压力小。 游戏好玩，有各种模式，活动，奖惩机制，想着法的让你爱上它。通过玩游戏，由菜一点点变厉害，由负战绩变成正战绩，由团队合作一起战胜敌方，这都会使我成就感倍增。如果我通过其他事情获得了更大的成就感，得到了更多的乐趣，便会不再沉迷游戏。 游戏好玩，有好玩的伙伴，有一段熟悉又陌生，长久且纯洁的友情。过年这半个月，我大部分时间都在打枪神纪，好久没花这么长时间玩游戏了，我想原因之一便是这段友情。打开枪神纪，大部分好友状态都是离线，我想他们和我一样早都退服了。惊喜的是还有几个好友仍在玩，更惊喜的是他们给我发了消息，问我还记不记得他们。他们都改名了，但当他们告诉我之前的名字，我仍能隐约回忆起那段美好的日子，甚至他爱玩的职业，他与我常玩的模式，我都能依稀记得。“想起那次夕阳下的奔跑，那曾是我逝去的青春”，虽然我们很久没一起玩了，但再一次开黑还是熟悉的感觉。之前玩游戏是因为激情，现在玩游戏全是感情。 压力小，没有学习的压力，没有工作的压力，没有生活的压力。我不相信一个吃了上顿没下顿，今天不工作明天就会饿死的人还能没日没夜地沉迷游戏。我觉得沉迷游戏的大都是学生，压力小，工作后，需要自己来面临各种压力后，生活容不得你我去沉迷游戏。有人也许会说我工作了，但我每天都会玩游戏。我认为区分玩游戏和沉迷游戏的标准是游戏有没有成为生活的大部分，游戏有没有影响正常生活。工作生活之余玩一两把游戏不仅没有耽误正常生活，还会丰富日常生活。 如何戒掉游戏？我觉得没有必要，每天放松娱乐玩上一两把并无大碍，只要别沉迷游戏无法自拔，耽误正常生活就行了。那如何不再沉迷游戏？ 这是我小时候一直面对的问题，我也没能解决，有时候一玩就忘了时间，一玩就停不下来。直到现在，我也会间接性地沉迷游戏。比如过年这小半个月，看了下游戏时长，我玩了48小时。想起了一个段子，一个人因其貌不扬而烦恼，长大后不再烦恼，不是长开了，而是看开了。我以前会因过度玩游戏而烦恼，现在我不再烦恼，不是因为戒掉了游戏，而是有了更重要的事去做。寒暑假来了，我一玩游戏，也许又上瘾了，但时间不会太长，多则两周，两周后自然而然就不再上瘾。不是玩腻了，不是游戏不好玩了，而是有压力了，有更重要的事了。 正如我上面所说的，沉迷游戏的原因一是游戏好玩，一是压力小。所以我举得不再沉迷游戏的做法，一是找到比游戏更有乐趣的事，找到更有成就感的事，一是压力大后，自然而然就不再沉迷游戏。我不是说主动给自己给自己施压，这是很客观的事，到了一定阶段，压力自然而然就会出现。 最后，各位有没有沉迷游戏的经历，是否有沉迷游戏的烦恼，有无行之有效的解决办法，欢迎各抒己见。","categories":[{"name":"日常","slug":"日常","permalink":"https://youngsay.cn/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"C语言实现简单的井字棋游戏","slug":"Tic-Tac-Toe","date":"2022-01-25T14:42:01.000Z","updated":"2022-01-25T15:15:12.366Z","comments":true,"path":"2022/01/25/Tic-Tac-Toe/","link":"","permalink":"https://youngsay.cn/2022/01/25/Tic-Tac-Toe/","excerpt":"","text":"井字棋，英文名叫Tic-Tac-Toe，是一种在3*3格子上进行的连珠游戏，和五子棋类似，由于棋盘一般不画边框，格线排成井字故得名。 想必大家小时候都玩过井字棋,今天分享大家一个用C语言做简单的井字棋游戏的教程,通过井字棋游戏,既能回忆起童年的美好,也能熟悉简单的C语言语法. 游戏演示： 我们准备三个文件,分别为game.c,test.c,game.h game.c文件用来写实现游戏功能的各个函数代码,test.c文件写游戏的总流程,game.h文件用来声明函数和初始值. 先来看test.c文件 文件内有三个函数,分别为菜单,游戏,主函数. 1234567void menu()&#123; printf(&quot;-----------------------\\n&quot;); printf(&quot;--------1.开始游戏-----\\n&quot;); printf(&quot;--------2.退出游戏-----\\n&quot;); printf(&quot;-----------------------\\n&quot;);&#125; 菜单很简单,就是开始游戏和退出游戏.我们可以在主函数中switch-case语句实现,输入1开始游戏,输入2退出游戏,其他输入均提示重新输入. 123456789101112131415161718192021int main()&#123; menu(); srand((unsigned int)time(NULL)); int input = 0; do &#123; printf(&quot;请输入选项\\n&quot;); scanf(&quot;%d&quot;, &amp;input); switch (input) &#123; case 1: game(); break; case 2: break; default: break; &#125; &#125; while (input);&#125; 玩家输入1后进入游戏函数,游戏函数内对函数进行调用,函数的声明放在game.h头文件,定义放在game.c源文件. 1234567891011121314151617181920212223242526272829303132333435void game()&#123; char rst = 0; char board[ROW][COL] = &#123; 0 &#125;; //初始化棋盘 InitBoard(board,ROW,COL); //打印棋盘 DisplayBoard(board, ROW, COL); while (1) &#123; //玩家下棋 player_move(board, ROW, COL); DisplayBoard(board, ROW, COL); //判断输赢 rst = isWinner(board,ROW,COL); if (rst != &#x27;C&#x27;) &#123; break; &#125; //电脑下棋 computer_move(board, ROW, COL); DisplayBoard(board, ROW, COL); rst = isWinner(board, ROW, COL); if (rst != &#x27;C&#x27;) &#123; break; &#125; &#125; if (rst == &#x27;*&#x27;) &#123; printf(&quot;恭喜你，赢得了胜利！\\n&quot;); &#125; else if (rst == &#x27;#&#x27;) &#123; printf(&quot;很遗憾，你输了！\\n&quot;); &#125; else &#123; printf(&quot;平局了\\n&quot;); &#125; 我们来简单说一下我们要实现的功能.首先,要初始化一个棋盘,我们可以用用三行三列的数组.玩家开始游戏,要将空棋盘显示给玩家,这时我们要打印棋盘.接着玩家下棋,输入坐标,将坐标处放上棋子,我们用*代表玩家的棋子,玩家下好后电脑下棋,用#代表电脑.当玩家或电脑先实现三个棋子连在一起,游戏结束. 下面是game.h头文件,文件内时头文件的引用,数据的初始化,游戏函数的定义 12345678910111213141516#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#define ROW 3#define COL 3//初始化棋盘的void InitBoard(char board[ROW][COL], int row, int col);//打印棋盘void DisplayBoard(char board[ROW][COL],int row,int col);//玩家下棋void player_move(char board[ROW][COL], int row, int col);//电脑下棋void computer_move(char board[ROW][COL], int row, int col);//判断输赢char isWinner(char board[ROW][COL], int row, int col); 下面是game.c文件的各个函数的定义 首先是初始化棋盘,便利3x3的数组,将数组内的元素置为空格字符 12345678910//初始化棋盘的void InitBoard(char board[ROW][COL], int row, int col) &#123; int i = 0; for (i = 0; i &lt; row; i++) &#123; int j = 0; for (j = 0; j &lt; col; j++) &#123; board[i][j] = &#x27; &#x27;; &#125; &#125;&#125; 接着是打印棋盘,打印棋盘很简单,但为了美观要将棋盘打印为井字,所以要花一些巧思 123456789101112131415161718192021222324252627//打印棋盘void DisplayBoard(char board[ROW][COL],int row,int col) &#123; int i = 0; for (i = 0; i &lt; row; i++) &#123; int j = 0; for (j = 0; j &lt; col; j++) &#123; printf(&quot; %c &quot;, board[i][j]); if (j &lt; col - 1) &#123; printf(&quot;|&quot;); &#125; &#125; printf(&quot;\\n&quot;); if (i &lt; row - 1) &#123; for (j = 0; j &lt; col; j++) &#123; printf(&quot;---&quot;); if (j &lt; col - 1) &#123; printf(&quot;|&quot;); &#125; &#125; printf(&quot;\\n&quot;); &#125; &#125;&#125; 接着是玩家下棋,当玩家输入的坐标小于1或大于3的,提示坐标非法,当坐标合法且该位置没有棋子将该坐标放上棋子* 123456789101112131415161718192021//玩家下棋void player_move(char board[ROW][COL], int row, int col) &#123; int x = 0; int y = 0; while (1) &#123; printf(&quot;玩家下棋&gt;\\n&quot;); scanf(&quot;%d %d&quot;, &amp;x, &amp;y); if (x&lt;1 || x&gt;row || y&lt;1 || y&gt;col) &#123; printf(&quot;坐标非法\\n&quot;); &#125; else &#123; if (board[x - 1][y - 1] == &#x27; &#x27;) &#123; board[x - 1][y - 1] = &#x27;*&#x27;; break; &#125; &#125; &#125; &#125; 下面是电脑下棋,使用rand()和srand()生成随机值,rand()%row生成的值是0-2,+1后就是1-3,纵坐标同理,如果坐标处没有棋子放上棋子# 12345678910111213141516//电脑下棋void computer_move(char board[ROW][COL], int row, int col) &#123; int x = 0; int y = 0; printf(&quot;电脑下棋\\n&quot;); while(1) &#123; x = rand() % row; y = rand() % col; if(board[x][y] == &#x27; &#x27;) &#123; board[x][y] = &#x27;#&#x27;; break; &#125; &#125;&#125; 最关键一步就是判断输赢,判断输赢无非就是行,列和对角线.除了输赢,还有平局,isPeace函数是用来判断平局,遍历棋盘,如果有至少一处为空,继续游戏,如果棋盘满了则为平局.返回* 玩家赢,返回# 电脑赢,返回Q 平局,返回C 继续. 123456789101112131415161718192021222324252627282930313233343536373839404142434445int isPeace(char board[ROW][COL], int row, int col) &#123; int i = 0; for (i = 0; i &lt; row; i++) &#123; int j = 0; for (j = 0; j &lt; col; j++) &#123; if (board[i][j] == &#x27; &#x27;) &#123; return 0; &#125; &#125; return 1; &#125;&#125;//判断输赢char isWinner(char board[ROW][COL], int row, int col)&#123; //判断行 int i = 0; for (i = 0; i &lt; row; i++) &#123; if (board[i][0] == board[i][1] &amp;&amp; board[i][1] == board[i][2] &amp;&amp; board[i][1] != &#x27; &#x27;) &#123; return board[i][1]; &#125; &#125; //判断列 int j = 0; for (j = 0; j &lt; col; j++) &#123; if (board[0][j] == board[1][j] &amp;&amp; board[1][j] == board[2][j] &amp;&amp; board[1][j] != &#x27; &#x27;) &#123; return board[1][j]; &#125; &#125; //判断对角线 if (board[0][0] == board[1][1] &amp;&amp; board[0][0] == board[2][2] &amp;&amp; board[0][0] != &#x27; &#x27;) &#123; return board[1][1]; &#125; if (board[0][2] == board[1][1] &amp;&amp; board[0][2] == board[2][0] &amp;&amp; board[0][2] != &#x27; &#x27;) &#123; return board[1][1]; &#125; //判断平局 if (isPeace(board, row, col) == 1) &#123; return &#x27;Q&#x27;; &#125; else &#123; return &#x27;C&#x27;; &#125;&#125; 以上就是一个用c语言制作简单的井字棋的介绍.代码和逻辑都很简单,只需要一些基础的c语言知识便可实现.技术有限,哪里有请指正,任何问题欢迎评论区留言交流.","categories":[{"name":"分享","slug":"分享","permalink":"https://youngsay.cn/categories/%E5%88%86%E4%BA%AB/"}],"tags":[]},{"title":"【C语言】分支和循环语句常见问题","slug":"C-branch-loop","date":"2022-01-16T06:33:41.000Z","updated":"2022-01-23T12:10:18.613Z","comments":true,"path":"2022/01/16/C-branch-loop/","link":"","permalink":"https://youngsay.cn/2022/01/16/C-branch-loop/","excerpt":"","text":"分支语句if-else语句12345678910111213#include &lt;stdio.h&gt;int main()&#123; int a = 0; int b = 2; if (a == 1) if (b == 2) printf(&quot;hello\\n&quot;); else printf(&quot;panghu\\n&quot;); return 0;&#125;//输出结果： 123456789101112131415#include &lt;stdio.h&gt;int main()&#123; int a = 0; int b = 2; if (a == 1) if (b == 2) printf(&quot;hello\\n&quot;); else printf(&quot;胖虎\\n&quot;); else printf(&quot;panghu\\n&quot;); return 0;&#125;//输出结果：panghu 观察上面两段代码，输出结果分别是什么？ 由此可知：else的匹配规则：else总是与离它最近的未匹配的if匹配，与缩进无关。 switch-case语句switch()括号内是整形表达式。 case后接整型常量表达式。 12345678910111213141516171819int i = 0;scanf(&quot;%d&quot; , &amp;i);switch (i) &#123;case 1:case 2:case 3:case 4:case 5: printf(&quot;工作日\\n&quot;); break;case 6:case 7: printf(&quot;休息日\\n&quot;); break;default: printf(&quot;输入错误&quot;); break;&#125;return 0; 思考下面代码，输出结果是什么？ 123456789101112131415161718192021222324252627282930int main()&#123; int n = 1; int m = 2; switch (n) &#123; case 1: m++; case 2: n++; case 3: switch (n) &#123;//switch允许嵌套使用 case 1: n++; case 2: m++; n++; break; &#125; case 4: m++; break; default: break; &#125; printf(&quot;m = %d, n = %d\\n&quot;, m, n); return 0;&#125;//5 3 循环语句continue比较1234567int i = 1;while (i &lt; 10) &#123; if (i == 5) continue; printf(&quot;%d&quot;, i); i++;&#125; 观察上端代码，打印结果是什么？ 结果为1234，然后死循环。 continue是结束本次循环，进入下次循环。当i=5时进入if语句，然后跳出，然后再进入，以此往复。 再看下面的代码： 123456int i = 0;for (i = 1; i &lt; 10; i++) &#123; if (i == 5) continue; printf(&quot;%d&quot;, i);&#125; 结果是12346789，与while循环相比，这次遇到continue跳出本次循环后能够让i自增，不会进入死循环。 getchar()和putchar()缓存区问题： char arr[20] = &#123; 0 &#125;; printf(&quot;请输入密码\\n&quot;); scanf(&quot;%s&quot; , arr); printf(&quot;请确认密码 Y/N\\n&quot;); int ch = getchar(); if (&#39;Y&#39; == ch) &#123; printf(&quot;确认成功\\n&quot;); &#125; else &#123; printf(&quot;确认失败\\n&quot;); &#125; 当我输入1234时，还没等确认，直接提示确认失败。 原因是当我输入1234后会按回车换行，也就是\\n，此时缓存区会存在\\n，getchar()会从缓存区取出\\n，ch=\\n，不等于Y，弹出确认失败。 如何解决这种问题？ 方法1：在scanf语句后面加上getchar()来取出\\n，这样ch再访问缓存区就为空了。但这样也有弊端，例如当我输入1234 abcd时又出现错误了。 原因是输入格式%s只读取空格之前的内容，而getchar()只能读取一个字符，所以ch再次读取时发现缓存区还有其他字符且不是Y，提示确认失败·。 方法2： 12345678910111213141516char arr[20] = &#123; 0 &#125;;printf(&quot;请输入密码\\n&quot;);scanf(&quot;%s&quot; , arr);int tmp = 0;while ((tmp = getchar()) != &#x27;\\n&#x27;) &#123; ;&#125;printf(&quot;请确认密码 Y/N\\n&quot;);int ch = getchar();if (&#x27;Y&#x27; == ch) &#123; printf(&quot;确认成功\\n&quot;);&#125;else &#123; printf(&quot;确认失败\\n&quot;);&#125; 用while循环，多次读取，直到缓存区为空，跳出循环。 赋值和判断观察下面代码，该代码循环几次？ 12345int i = 0;int k = 0;for (i = 0, k = 0; k = 0; i++, k++) k++;return 0; 循环0次。为什么呢？原因是判断部分写成了k=0，=为赋值，使得条件为假，不进入for循环，代码执行0次。 循环的应用：12345678//非递归求5的阶乘int i = 1;int sum = 0;int rst = 1;for (i = 1; i &lt;= 5; i++) &#123; rst = rst * i;&#125;printf(&quot;%d&quot;, rst); 123456789//求1!+2!+……+5！之和int i = 1;int sum = 0;int rst = 1;for (i = 1; i &lt;= 5; i++) &#123; rst = rst * i; sum += rst;&#125;printf(&quot;%d&quot;, sum); strcmp()C 库函数 int strcmp(const char *str1, const char *str2) 把 str1 所指向的字符串和 str2 所指向的字符串进行比较。 该函数返回值如下： 如果返回值小于 0，则表示 str1 小于 str2。 如果返回值大于 0，则表示 str1 大于 str2。 如果返回值等于 0，则表示 str1 等于 str2。 因此比较两个字符串值是否相同时，不能用==，应该用strcmp()函数。 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;string.h&gt; int main ()&#123; char str1[15]; char str2[15]; int ret; strcpy(str1, &quot;abcdef&quot;); strcpy(str2, &quot;ABCDEF&quot;); ret = strcmp(str1, str2); if(ret &lt; 0) &#123; printf(&quot;str1 小于 str2&quot;); &#125; else if(ret &gt; 0) &#123; printf(&quot;str1 大于 str2&quot;); &#125; else &#123; printf(&quot;str1 等于 str2&quot;); &#125; return(0);&#125; rand()和srand()rand():Generates a pseudorandom number. 生成一个伪随机值 int rand( void ); 123printf(&quot;%d\\n&quot;,rand());printf(&quot;%d\\n&quot;, rand());printf(&quot;%d\\n&quot;, rand()); 运行上段代码，会发现每次运行结果都一样，这不是我们理想中的随机值。 Use the srand function to seed the pseudorandom-number generator before calling rand. 我们可以用srand()来使伪随机值变化。Sets a random starting point. void srand( unsigned int seed ); 我们可以用时间作为参数，只要每次播种的时间不同，那么生成的种子就不同，最终的随机数也就不同。 12345678910#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;int main() &#123; int a; srand((unsigned)time(NULL)); a = rand(); printf(&quot;%d\\n&quot;, a); return 0;&#125; C语言随机数生成教程，C语言rand和srand用法详解 (biancheng.net)","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"c","slug":"c","permalink":"https://youngsay.cn/tags/c/"}]},{"title":"【JavaSE】类和对象","slug":"Java-class-object","date":"2022-01-14T03:40:41.000Z","updated":"2022-01-23T12:10:31.013Z","comments":true,"path":"2022/01/14/Java-class-object/","link":"","permalink":"https://youngsay.cn/2022/01/14/Java-class-object/","excerpt":"","text":"类的成员：字段、方法、代码块、内部类和接口等 字段1234class Person&#123; public int age; public String name; public String sex; age，name，sex这些类中方法外的变量，是字段、属性、成员变量（3种称呼均可） 123456789public class TestDemo &#123; public static void main(String[] args) &#123; //类的实例化 Person person=new Person(); System.out.println(person.name);//null System.out.println(person.age);//0 &#125;&#125; 对象的字段如果没有初始化，访问时会被设置成默认值。 默认值规则 对于各种数字类型, 默认值为 0. 对于 boolean 类型,默认值为 false. 对于引用类型(String, Array, 以及自定制类), 默认值为 null 12Exception in thread &quot;main&quot; java.lang.NullPointerException at TestDemo.main(TestDemo.java:15) 对null进行访问，会出现空指针异常。 方法123456789101112131415161718192021222324class Person &#123; //字段、成员变量、属性 public int age; public String name; public String sex; //方法 //构造方法 public Person(String name) &#123; this.name = name; &#125; public void study() &#123; System.out.println(this.name+&quot;正在学习&quot;); &#125;&#125;public class TestDemo &#123; public static void main(String[] args) &#123; //类的实例化 Person person=new Person(&quot;panghutx&quot;); person.study(); &#125;&#125; 代码中的study()就是一个方法，和之前学到的方法（c语言为函数没什么区别） public Person(String name) &#123; this.name = name; &#125; 上段代码是一个构造方法 构造方法是一种特殊方法, 使用关键字new实例化新对象时会被自动调用, 用于完成初始化操作 语法规则：方法名与类名一致，没有返回值，支持重载 1234567891011//带有一个参数的构造方法public Person()&#123; System.out.println(&quot;I am the constructor method of one Parameter &quot;);&#125;//带有3个参数的构造方法public Person(String name,int age,String sex)&#123; this.name=name; this.age=age; this.sex=sex; System.out.println(&quot;I am the constructor method of three Parameters &quot;);&#125; 123//类的实例化Person person1=new Person();Person person2=new Person(&quot;panghutx&quot;,12,&quot;male&quot;); 输出结果为 123I am the constructor method of one Parameter I am the constructor method of three Parameters 代码块使用&#123;&#125;定义的一段代码. 构造代码块构造代码块(实例代码块)：定义在类中的代码块(不加修饰符)。构造代码块一般用于初始化实例成员变量。 实例代码块优先于构造函数执行。 静态代码块使用static定义的代码块。一般用于初始化静态成员属性。 静态代码块不管生成多少个对象，其只会执行一次，且是最先执行的。 12345678910111213141516171819202122232425262728293031323334353637class Person&#123; private String name;//实例成员变量 private int age; private String sex; private static int count = 0;//静态成员变量 由类共享数据 方法区 public Person()&#123; System.out.println(&quot;I am Person init()!&quot;); &#125; //实例代码块 &#123; this.name = &quot;bit&quot;; this.age = 12; this.sex = &quot;man&quot;; System.out.println(&quot;I am instance init()!&quot;); &#125; //静态代码块 static &#123; count = 10;//只能访问静态数据成员 System.out.println(&quot;I am static init()!&quot;); &#125; public void show()&#123; System.out.println(&quot;name: &quot;+name+&quot; age: &quot;+age+&quot; sex: &quot;+sex); &#125; &#125; public class Main &#123; public static void main(String[] args) &#123; Person p1 = new Person(); Person p2 = new Person();//静态代码块是否还会被执行？ &#125; &#125; 执行结果： 12345I am static init()!I am instance init()!I am Person init()!I am instance init()!I am Person init()! static关键字static修饰属性、方法、类、代码块 static修饰属性static修饰的属性不与对象绑定，所有类共享，只有一份，存在于方法区。 访问方法：类名.static属性 123456789101112131415161718192021class TestDemo&#123; public int a; public static int count;&#125;public class Main&#123; public static void main(String[] args) &#123; TestDemo t1 = new TestDemo(); t1.a++; TestDemo.count++; System.out.println(t1.a); System.out.println(TestDemo.count); System.out.println(&quot;============&quot;); TestDemo t2 = new TestDemo(); t2.a++; TestDemo.count++; System.out.println(t2.a); System.out.println(TestDemo.count); &#125;&#125; 输出结果： 1234511============12 static修饰方法static修饰的方法无需创建对象，可以由类直接调用，调用方法：类名.方法。静态方法只能访问静态变量，不能访问非静态变量。 123456789101112131415class TestDemo&#123; public int a; public static int count; public static void change() &#123; count = 100; //a = 10; error 不可以访问非静态数据成员 &#125;&#125;public class Main&#123; public static void main(String[] args) &#123; TestDemo.change()；//无需创建实例对象 就可以调用 System.out.println(TestDemo.count); &#125;&#125; 注意：this和super两个关键字不能在静态上下文中使用(this 是当前实例的引用, super是当前实例父类实例的引用, 也 是和当前实例相关). this关键字this关键字代表当前对象的引用，不是当前对象。 一个对象的产生分为两步： ①为对象分配内存②调用合适的构造方法 对象的产生需要调用合适的构造方法，在构造方法内部可以使用this，对象还没有产生我们就已经使用了this，恰恰说明this不代表当前对象。 this的用法： this():调用构造方法 this.data:调用当前对象的属性 this.func():调用当前对象的方法","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://youngsay.cn/tags/JavaSE/"}]},{"title":"【JavaSE】数组的定义和使用","slug":"Java-array","date":"2022-01-12T14:40:41.000Z","updated":"2022-01-23T12:10:48.820Z","comments":true,"path":"2022/01/12/Java-array/","link":"","permalink":"https://youngsay.cn/2022/01/12/Java-array/","excerpt":"","text":"一维数组一维数组的定义123int[] arr=&#123;1,2,3,4,5&#125;;int[] arr1=new int[]&#123;1,2,3,4,5&#125;;int[] arr2=new int[5]; 一维数组的遍历method 1： 123for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i]);&#125; method 2： 123for (int x:arr) &#123; System.out.print(x);&#125; method 3： 1System.out.println(Arrays.toString(arr)); 理解引用int[] arr=new int[]&#123;1,2,3&#125;创建一个数组，变量arr是一个引用类型，里面只保存了一个整数（数组的起始内存地址），指向&#123;1，2，3&#125;的存储地址。 初识JVM内存区域划分 虚拟机栈：重点存储局部变量表，int[] arr这样的引用类型就存储在这里 堆：JVM管理的最大内存区域，new创建的对象都存储在这里，如new int[]&#123;1，2，3&#125; 方法区：用于存储已被虚拟机加载的类信息、常量、静态变量等数据 二维数组 二维数组的定义123int[][] array=&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;;int[][] array1=new int[][]&#123;&#123;7,8,9&#125;,&#123;10,11,12&#125;&#125;;int[][] array2=new int[2][3]; 二维数组的遍历method 1： 123456for (int i = 0; i &lt; array.length; i++) &#123; for (int j = 0; j &lt; array[i].length; j++) &#123; System.out.print(array[i][j]+&quot; &quot;); &#125; System.out.println();&#125; method 2： 123456for ( int[] x:array) &#123; for ( int y:x) &#123; System.out.print(y); &#125; System.out.println();&#125; method 3： 1System.out.println(Arrays.deepToString(array)); 数组练习数组拷贝 1public static int[] copyOf(int[] original,int newLength) original - 要复制的数组 newLength - 要返回的副本的长度 1public static int[] copyOfRange(int[] original,int from,int to) original - 要从中复制范围的数组from - 要复制的范围的初始索引（包括）to - 要复制的范围的最终索引（不包括） 12345678int[] arr=&#123;1,2,3,4,5&#125;;int[] arr2=Arrays.copyOf(arr,arr.length);System.out.println(Arrays.toString(arr2)); //&#123;1，2，3，4，5&#125;arr[0]=100;System.out.println(Arrays.toString(arr2)); //&#123;1，2，3，4，5&#125;System.out.println(Arrays.toString(arr)); //&#123;100，2，3，4，5&#125;int[] arr3=Arrays.copyOfRange(arr,1,3); // 拷贝[1,3)范围内的数组System.out.println(Arrays.toString(arr3)); //&#123;2，3&#125; 数组排序（冒泡排序）1234567891011121314151617181920public static void main(String[] args) &#123; int[] arr=&#123;11,2,31,14,5&#125;; bubbleSort(arr); System.out.println(Arrays.toString(arr));&#125;public static void bubbleSort(int[] arr)&#123; for (int i = 0; i &lt; arr.length-1; i++) &#123; boolean flg=false; for (int j = 0; j &lt; arr.length-1-i; j++) &#123; if(arr[j]&gt;arr[j+1])&#123; int tmp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=tmp; flg=true; &#125; &#125; if(flg==false) break; &#125;&#125; 数组排序（偶数在前，奇数在后）123456789101112131415161718192021222324public static void main(String[] args) &#123; int[] arr=&#123;1,2,3,4,5&#125;; transform(arr); System.out.println(Arrays.toString(arr));&#125;public static void transform(int[] arr)&#123; int left=0; int right=arr.length-1; while(left&lt;right)&#123; while(left&lt;right&amp;&amp;arr[left]%2==0)&#123; left++; &#125; //遇到奇数了 while(left&lt;right&amp;&amp;arr[right]%2!=0)&#123; right--; &#125; //遇到偶数了 if(left&lt;right)&#123; int tmp=arr[left]; arr[left]=arr[right]; arr[right]=tmp; &#125; &#125;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://youngsay.cn/tags/JavaSE/"}]},{"title":"【C语言】基础语法的简单概括","slug":"C-prime-knowledge","date":"2022-01-08T01:33:41.000Z","updated":"2022-01-23T12:10:05.005Z","comments":true,"path":"2022/01/08/C-prime-knowledge/","link":"","permalink":"https://youngsay.cn/2022/01/08/C-prime-knowledge/","excerpt":"","text":"数据类型为了更加丰富地表达生活中的各种值，C语言中有不同的数据类型。每个数据类型有其占用空间的大小。我们用sizeof可以获取某个数据类型所占用空间的字节数。 下面这段代码： 1234567printf(&quot;%d&quot;, sizeof(char));printf(&quot;%d&quot;, sizeof(short));printf(&quot;%d&quot;, sizeof(int));printf(&quot;%d&quot;, sizeof(long));printf(&quot;%d&quot;, sizeof(long long));printf(&quot;%d&quot;, sizeof(float));printf(&quot;%d&quot;, sizeof(double)); 在vs2019运行时，输出结果是：1244848 在linux平台运行时，结果是：1248848 对比发现，long在不同的编译器结果不同。c语言并没有规定long的大小，只是规定了sizeof(long)&gt;=sizeof(int)。 变量的作用域和生命周期 作用域：变量作用的范围。变量在哪里可以使用，哪里就是它的作用域。 局部变量的作用域是变量所在的局部范围；全局变量的作用域是整个工程。 生命周期：变量由创建到销毁这一时间段 局部变量的生命周期是：局部变量的作用域；全局变量的生命周期是：整个程序。 常量字面常量const修饰的常变量123const double pi = 3.14;pi = 6.66;//报错信息：表达式必须是可修改的左值 由const修饰的变量只是不可以再次修改，但本质仍是变量。 define定义的标识符常量12#define MAX 100printf(&quot;max = %d\\n&quot;, MAX); 枚举常量123456789101112enum MyEnum&#123; MALE, FAMALE, SECRET&#125;;int main()&#123; printf(&quot;%d&quot;, MALE); //0 printf(&quot;%d&quot;, FAMALE); //1 printf(&quot;%d&quot;, SECRET); //2&#125; 字符串12345678int main()&#123; char arr1[] = &quot;hello&quot;; char arr2[] = &#123; &#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27; &#125;; printf(&quot;%s\\n&quot;, arr1); printf(&quot;%s\\n&quot;, arr2);&#125; 字符串的结束标志是一个\\0的转义字符。在计算字符串长度的时候\\0不算作字符串内容。printf输出内容是\\0之前的内容，arr2找不到\\0出现了乱码，用strlen计算长度时也会出现随机值。 转义字符下段代码的输出结果是什么？ 1printf(&quot;%d\\n&quot;, strlen(&quot;c:\\test\\628\\test.c&quot;)); 输出结果是14。 \\t—–&gt;水平制表符 \\62—&gt;将8进制数数字62转换成10进制数字50 注： \\ddd中ddd表示1-3位八进制数字，范围是0-7，所以上题中是\\62，不是\\628 \\xdd中dd表示2个十六进制数字。 如: 12printf(&quot;%c\\n&quot;, &#x27;\\x31&#x27;); //1//将16进制数字31转换为10进制数字49，ascii码值代表的字符为 ‘1’ 关键字123auto break case char const continue default do double else enum extern float for goto if int long register return short signedsizeof static struct switch typedef union unsigned void volatile while define定义标识符常量12345678910#include&lt;stdio.h&gt;#define N 5int main()&#123; int arr[N] = &#123;0,1,2,3,4&#125;; int i = 0; for (i = 0; i &lt; N; i++) &#123; printf(&quot;%d&quot;, arr[i]); &#125;&#125; 定义宏1234567#define MAX(a,b)(a)&gt;(b)?(a):(b)int main()&#123; int x = 10; int y = 20; printf(&quot;%d&quot;, MAX(x,y)); //20&#125; static static是用来修饰变量和函数的 修饰局部变量-称为静态局部变量 修饰全局变量-称为静态全局变量 修饰函数-称为静态函数 修饰局部变量观察下面两段代码 1234567891011121314#include&lt;stdio.h&gt;void add() &#123; static int b = 0; b++; printf(&quot;%d&quot;, b); //12345&#125;int main()&#123; int i = 0; for (i = 0; i &lt; 5; i++) &#123; add(); &#125; return 0;&#125; 1234567891011121314#include&lt;stdio.h&gt;void add() &#123; int b = 0; b++; printf(&quot;%d&quot;, b); //11111&#125;int main()&#123; int i = 0; for (i = 0; i &lt; 5; i++) &#123; add(); &#125; return 0;&#125; 对比发现，static修饰局部变量改变了变量的生命周期，让静态局部变量出了作用域依然存在，到程序结束，生命周期才结束。 static修饰局部变量时，改变了局部变量的存储位置，将局部变量由堆区存储到静态区。 修饰全局变量和函数一个全局变量（函数）被static修饰，使得这个全局变量（函数）只能在本源文件内使用，不能在其他源文件内使用。 全局变量（函数）具有外部链接属性，可以用extern外部引用，但被static修饰后，外部链接变成了内部链接，只能在当前源文件内部使用。 typedef类型重命名：使类型名简单化，书写更方便 1234567//将类型unsigned int重命名为uint_32，下次可以直接使用类型uint_32typedef unsigned int uint_32;int main()&#123; unsigned int a = 0; uint_32 b = 0;&#125; 结构体123456789101112131415161718192021//定义结构体类型struct MyStruct&#123; char name[20]; int age; char sex[6];&#125;;//dvoid stu(struct MyStruct* ps) &#123; printf(&quot;%s,%d,%s&quot;, ps-&gt;name, ps-&gt;age, ps-&gt;sex);&#125;int main()&#123; //结构体实例化 struct MyStruct stu1 = &#123;&quot;菜鸟小胖p&quot;,20,&quot;保密&quot;&#125;; struct MyStruct stu2 = &#123; &quot;小明&quot;,101,&quot;男&quot; &#125;; //打印结构体 printf(&quot;%s,%d,%s\\n&quot;, stu1.name, stu1.age, stu1.sex); //函数打印结构体 stu(&amp;stu2);&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"c","slug":"c","permalink":"https://youngsay.cn/tags/c/"}]},{"title":"2021年度总结","slug":"2021","date":"2022-01-01T09:24:01.000Z","updated":"2022-01-23T12:07:34.465Z","comments":true,"path":"2022/01/01/2021/","link":"","permalink":"https://youngsay.cn/2022/01/01/2021/","excerpt":"","text":"2022年来了，我又长大了一岁。 过去这一年，有快乐有失落，有收获有遗憾。 伤感的话不再说，遗憾的事不再提，新的一年继续好好生活。 等等，在好好生活之前还是写一下年终总结吧，虽然今天已经是2022年…… 回顾过去的这一年，每一天都很平常，有时很快乐，有时会难过，也许有成长，难免有遗憾。就在这平凡的一天又一天中，平凡的我又长大了一岁。 我没有写日记的习惯，很多事过去了就过去了，也许以后就再也不会想起。比如现在我想写一个年度总结，我不知道写些什么。好在有这样一个博客，或多或少能留存一些当时的记忆。 2021年3月29日，新博客建成，发布第一篇博客： 新学期，新博客，新开始! 在此之前也搭建过其他博客，总是写着写着感觉没啥意思，最终都删库跑路了。这是我持续时间最长的博客，我会一直让它活下去（希望别被打脸）。 回看第一篇博客，感慨万千。当时写到“我想学计算机相关专业，但无奈被调剂到了应用物理”，现在我已经是计算机科学与技术专业的学生了，2021/9/17 收到了转专业成功的消息，这个可以算是今年很开心的一件事。当时我提到“一直对编程感兴趣，尤其是前端”，现在我已经俩月没学前端了，2021/11/6 发的vue那篇笔记应该是我最后一次学习前端，也是刚开始接触vue。现在专业课开了Python和C语言，所以就把js先搁置了。最初学的时候就不扎实，现在再回看当时的笔记已经很陌生了。 2021年6月2号，在听讲座后不久，发布了： 讲座，机会，关系! 这是听完学长讲座后不久写的一篇博客。学长是我原来学院信科专业的学生，考上了北理工研究生，讲座期间在字节跳动实习，现在怎样我也不知道了。当时我还加了他的微信，至今也没发过消息……学长的讲座对我影响很大，在听完他讲座后的一段时间学习很积极，但劲头持续时间不长（捂脸）。 2021年7月21日，放暑假两周后发布： 暑假，目的论，自卑情结 这篇博客是看了《被人讨厌的勇气》的读后感，对我有些许启发。我惰性很强，自制力很差，如果我再胸无大志的话，便是个完完全全快乐的人。但我又有燕雀之志（虽无鸿鹄之志，但也有些小追求），所以有时会很焦虑，只能做半个快乐的人。我因为自制力差，经常沉迷于网络而浪费很多时间，但我又有些追求，时而积极，时而消极。积极时我经常为过去的消极而懊悔，为失去了的宝贵时间而焦虑，但积极一阵后便又迎来了消极，周而复始，反反复复。 2021年9月6日：大二上开学，2021年12月24日，本学期结束。 这学期自我感觉良好，比以往更加充实快乐。 回顾这一年，当时的很多想法已经变了，当时的很多困惑现在已不再困惑，当时认为天大的事现在看来也许都不叫事。最后引用余华的一句话来结束本篇博客，“没有什么比时间更具有说服力了，因为时间无需通知我们就可以改变一切”。","categories":[{"name":"日常","slug":"日常","permalink":"https://youngsay.cn/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"【JavaSE】方法及递归的使用","slug":"Java-method","date":"2021-11-23T05:05:41.000Z","updated":"2022-01-23T12:10:41.744Z","comments":true,"path":"2021/11/23/Java-method/","link":"","permalink":"https://youngsay.cn/2021/11/23/Java-method/","excerpt":"","text":"初识方法Java中的方法类似于c语言中的函数 观察下面代码，体会方法的好处。 123456789101112//求两个数的最大值public static int maxTwoNum(int a,int b) &#123; return a&gt;b ? a : b;&#125;//求三个数的最大值public static int maxThreeNum(int a,int b,int c) &#123; int max=maxTwoNum(a,b); return maxTwoNum(max,c);&#125;public static void main(String[] args) &#123; int a=10,b=23,c=4; System.out.println(maxThreeNum(a,b,c)); 灵活使用方法，可以减少重复代码，使代码更简单。 实参、形参的关系Java当中只有按值传递 分析如下代码：交换两个整型变量 12345678910111213public static void swap(int x,int y)&#123; int tmp=x; x=y; y=tmp;&#125;public static void main5(String[] args) &#123; //交换两个整型变量的错误演示 int a=10; int b=20; swap(a,b); System.out.println(a); System.out.println(b);&#125; 输出结果为10 20，没有完成两数的交换。对于基础类型来说, 形参相当于实参的拷贝. 即 传值调用 1234567891011public static void swap1(int[] arr)&#123; int tmp=arr[0]; arr[0]=arr[1]; arr[1]=tmp;&#125;public static void main(String[] args) &#123; //交换两个整数的正确方法 int[] arr=&#123;10,20&#125;; swap1(arr); System.out.println(Arrays.toString(arr));&#125; 解决方案：传引用类型参数，如数组。 练习：求n个阶乘之和 123456789101112131415161718192021public static int add(int n) &#123; int j=1; int sum=0; for(j=1;j&lt;=n;j++)&#123; sum += factor(j); &#125; return sum;&#125;public static int factor(int j)&#123; int i=1; int rst=1; for(i=1;i&lt;=j;i++)&#123; rst *= i; &#125; return rst;&#125;public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int num=scan.nextInt(); System.out.println(add(num));&#125; 方法的重载（overload）：同一个方法名字, 提供不同版本的实现, 称为方法重载 方法名相同 返回值不做要求 参数列表不同（参数个数或参数类型不同） 同一个类当中 123456789public static int sum(int a,int b) &#123; return a+b;&#125;public static double sum(double a,double b) &#123; return a+b;&#125;public static void main(String[] args) &#123; System.out.println(sum(4,6));&#125; 面试题：重载和重写的区别 方法的递归一个方法在执行过程中调用自身, 就称为 “递归”。 递归把大问题化解成小问题，求解递归问题，要找到终止条件和递归公式。 求n的阶乘 12345678910public static int factor(int n) &#123; if(n==1)&#123; return 1; &#125;else &#123; return n * factor(n - 1); &#125;&#125;public static void main(String[] args) &#123; System.out.println(factor(4));&#125; 求n个阶乘之和12345678910111213141516public static int factor(int i)&#123; if(i==1)&#123; return 1; &#125;else&#123; return i*factor(i-1); &#125;&#125;public static void main(String[] args) &#123; int sum=0; Scanner scan = new Scanner(System.in); int num=scan.nextInt(); for (int i = 1; i &lt; num; i++) &#123; sum+= factor(i); &#125; System.out.println(sum);&#125; 按顺序打印一个数字的每一位(例如 1234 打印出 1 2 3 4)123456789public static void func(int n) &#123; if(n&gt;9)&#123; func(n/10); &#125; System.out.print(n%10+&quot; &quot;);&#125;public static void main(String[] args) &#123; func(123);&#125; 递归求 1 + 2 + 3 + … + 1012345678910public static int sum(int n) &#123; if (n==1) &#123; return 1; &#125; else &#123; return n+sum(n-1); &#125;&#125;public static void main(String[] args) &#123; System.out.println(sum(10));&#125; 写一个递归方法，输入一个非负整数，返回组成它的数字之和.例如，输入 1729, 则应该返回1+7+2+9， 它的和是19 123456789public static int func(int n) &#123; if(n&gt;9)&#123; return n%10+func(n/10); &#125; return n;&#125;public static void main(String[] args) &#123; System.out.println(func(5211));&#125; 求斐波那契数列的第N项：1234567public static int fib(int n) &#123; if (n == 1 || n == 2) &#123; return 1; &#125; return fib(n - 1) + fib(n - 2);&#125; 不建议用递归实现斐波那契数列，建议用循环。 1234567891011121314public static int func(int n) &#123; int n1=1; int n2=1; int n3=1; for(int i=3;i&lt;=n;i++) &#123; n3=n1+n2; n1=n2; n2=n3; &#125; return n3;&#125;public static void main(String[] args) &#123; System.out.println(func(1));&#125; 思考递归：横向思考，不要展开递归的代码 代码执行：纵向执行","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://youngsay.cn/tags/JavaSE/"}]},{"title":"【JavaSE】程序逻辑控制练习","slug":"Java-logic-control","date":"2021-11-20T08:55:41.000Z","updated":"2022-01-23T12:10:37.970Z","comments":true,"path":"2021/11/20/Java-logic-control/","link":"","permalink":"https://youngsay.cn/2021/11/20/Java-logic-control/","excerpt":"","text":"输入1-7，输出工作日或休息日1234567891011121314151617Scanner scan = new Scanner(System.in);switch(scan.nextInt()) &#123; case 1: case 2: case 3: case 4: case 5: System.out.println(&quot;工作日&quot;); break; case 6: case 7: System.out.println(&quot;休息日&quot;); break; default: System.out.println(&quot;输入错误&quot;); break;&#125; switch 中的值只能是 整数|枚举|字符|字符串，long、double、float、boolean不能作为switch参数的类型。 判断一个数是否为素数（3种方法）1234567891011121314Scanner scan = new Scanner(System.in);int num=scan.nextInt();int i=1;for(i=2;i&lt;num;i++) &#123; //方法2：i&lt;=num/2 //方法3：i&lt;=Math.sqrt(num); if(num%i==0) &#123; System.out.println(num+&quot;不是素数&quot;); break; &#125;&#125;if(i&gt;=num)&#123; System.out.println(num+&quot;是素数&quot;);&#125; 打印100以内的所有素数123456789101112int j=0;for(j=2;j&lt;=100;j++) &#123; int i=1; for(i=2;i&lt;j;i++)&#123; if(j%i==0)&#123; break; &#125; &#125; if(i==j)&#123; System.out.println(j+&quot;是素数&quot;); &#125;&#125; 输出1000-2000之间的所有闰年12345int year=1000;for(year=1000;year&lt;=2000;year++) &#123; if(year%4==0&amp;&amp;year%100!=0||year%400==0) &#123; System.out.println(year+&quot;是闰年&quot;); &#125; 输出乘法口诀表12345678int i=1;int j=1;for(i=1;i&lt;=9;i++) &#123; //i--行数 for(j=1;j&lt;=i;j++)&#123; //j--列数 列数的多少取决于第一行 第一行有一列，第二行有两列，…… System.out.print(j+&quot;*&quot;+i+&quot;=&quot;+i*j+&quot;&quot;); &#125; System.out.println();&#125; 求两个数的最大公约数1234567891011Scanner scan = new Scanner(System.in);int a=scan.nextInt();int b=scan.nextInt();int c=b;while(a%b!=0) &#123; c=a%b; a=b; b=c;&#125;System.out.println(a+&quot;和&quot;+b+&quot;的最大公约数是&quot;+c);&#125; 计算1/1-1/2+1/3……+1/99-1/100的值12345678int flag=1;int j=1;double sum=0;for(j=1;j&lt;=100;j++) &#123; sum += 1.0/j*flag; flag=-flag;&#125;System.out.println(sum); 编写程序数一下1到100的所有整数中出现多少个数字912345678int i=1;int count=0;for(i=1;i&lt;=100;i++)&#123; if(i%10==9||i/10==9) &#123; count++; &#125;&#125;System.out.println(count); 求出0~999之间的所有”水仙花”123456int i=100; for(i=100;i&lt;1000;i++) &#123; if(Math.pow(i%10,3)+Math.pow(i/10%10,3)+Math.pow(i/100%10,3)==i) &#123; System.out.println(i); &#125; &#125; 改进：求出1-6位数的自幂数 附：其他位数的自幂数名字 一位自幂数：独身数；三位自幂数：水仙花数；四位自幂数：四叶玫瑰数；五位自幂数：五角星数；六位自幂数：六合数 12345678910111213141516171819int i=1;for(i=1;i&lt;=9999999;i++) &#123; int count=0; int temp=i; int sum=0; //p while (temp!=0) &#123; count++; temp=temp/10; &#125; temp=i; while(temp!=0)&#123; sum += Math.pow(temp%10,count); temp=temp/10; &#125; if(sum==i)&#123; System.out.println(sum); &#125;&#125; 编写代码模拟三次密码输入场景，最多输入3次123456789101112131415Scanner scan =new Scanner(System.in);String input = scan.next();int count=2;for(count=2;count&gt;0;count--) &#123; if(input.equals(&quot;zzz123&quot;))&#123; //🔺不能用= System.out.println(&quot;密码正确，登陆成功&quot;); break; &#125;else &#123; System.out.println(&quot;输入错误，你还有&quot;+count+&quot;次机会&quot;); &#125; input = scan.next();&#125;if(count&lt;=0)&#123; System.out.println(&quot;三次均输错，退出程序&quot;);&#125; 输入一个数，输出该数二进制中1的个数：12345678910Scanner scan = new Scanner(System.in);int num=scan.nextInt();int count=0;int i=0;for(i=0;i&lt;32;i++) &#123; if(((num&gt;&gt;i)&amp;1)==1)&#123; count++; &#125;&#125;System.out.println(num+&quot;二进制中1的个数为：&quot;+count); 改进： 12345678Scanner scan =new Scanner(System.in);int n = scan.nextInt();int count=0;while(n!=0)&#123; n=n&amp;(n-1); count++;&#125;System.out.println(count);","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://youngsay.cn/tags/JavaSE/"}]},{"title":"【JavaSE】数据结构与运算符","slug":"Java-data-type","date":"2021-11-20T03:27:41.000Z","updated":"2022-01-23T12:10:34.284Z","comments":true,"path":"2021/11/20/Java-data-type/","link":"","permalink":"https://youngsay.cn/2021/11/20/Java-data-type/","excerpt":"","text":"初识Java第一个java程序12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(&quot;HelloWorld&quot;); &#125;&#125; 一个java文件中，只能有一个public类，且类名要与文件相同。 类存在于源文件里面；方法存在于类中；语句存在于方法中。 类名要采用大驼峰形式（首字母均大写）命名。 面试问题： main方法为什么是static： String[] args的作用是什么：运行时命令行参数 如何运行java程序 大致过程就是，我们写好的.java文件（源文件）被编译器编译后变成.class文件（字节码），然后被JVM的类加载器加载到内存，通过字节码校验器去做一些校验，校验通过后交由解释器将字节码文件解释成计算机能够识别的机器指令。 面试问题：双亲委派模型、类加载器 JDK Java开发环境 ；JRE Java运行环境 ；JVM Java虚拟机 12345678910class zzz &#123; public static void main(String[] args) &#123; System.out.println(&quot;zzz&quot;); &#125;&#125;public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(&quot;HelloWorld&quot;); &#125;&#125; Java中，一个类就会生成一个字节码文件。 为何这样设置？为了方便使用，如果需要HelloWorld这个类，就加载对应的字节码文件。 变量和类型 变量均存储在内存中。 变量整形12int i=10; //定义一个整形变量System.out.println(i); 一个int变量占4个字节。 什么是字节? 字节是计算机中表示空间大小的基本单位. 计算机使用二进制表示数据. 我们认为 8 个二进制位(bit) 为一个字节(Byte). 我们平时的计算机为 8GB 内存, 意思是 8G 个字节. 其中 1KB = 1024 Byte, 1MB = 1024 KB, 1GB = 1024 MB. 所以 8GB 相当于 80 多亿个字节 12System.out.println(Integer.MAX_VALUE); // 2147483647System.out.println(Integer.MIN_VALUE); // -2147483648 4 个字节表示的数据范围是 -2^31 -&gt; 2^31-1 , 也就大概是 -21亿 到 +21亿 1234int maxValue = Integer.MAX_VALUE;System.out.println(maxValue+1); // -2147483648int minValue = Integer.MIN_VALUE;System.out.println(minValue-1); // 2147483647 如果运算的结果超出了 int 的最大范围, 就会出现溢出的情况。 图：int的取值范围 长整型long占8个字节，取值范围是-2^63—2^63-1 1234long num=10L;System.out.println(num);System.out.println(Long.MAX_VALUE);System.out.println(Long.MIN_VALUE); 初始化长整型变量是记得在数字后面加上L 双精度浮点型double占8个字节，浮点数在内存中的存储与整形不同，不能单纯用2^n表示其取值范围，且浮点数的存储会存在精度误差。 12double num = 1.1;System.out.println(num * num) // 1.2100000000000002 单精度浮点型float占4个字节，初始化时要在数字后面加上f 12float num = 1.0f; // 写作 1.0F 也可以System.out.println(num); 字符型char在java中占2个字节 1char ch=&#x27;A&#x27;; Java 中使用单引号 + 单个字母 的形式表示字符字面值. 计算机中的字符本质上是一个整数. 在 C 语言中使用 ASCII 表示字符, 而 Java 中使用 Unicode 表示字符. 因此一个字符占用两个字节, 表示的字符种类更多, 包括中文. 使用一个汉字表示一个字符时，报错是要用javac -encoding UTF-8 文件名.java字节型 byte占1个字节，范围大小是-128–&gt;127 byte类型相加减时会进行整形提升，要用int保存。 短整型short占2个字节，范围大小是-2^15-2^15-1，范围较小，一般不使用。 布尔型boolean只有两种取值，true或false。Java中的布尔型和整形不能相互转换，不能用1或0表示布尔型。 字符串型String占8个字节，Java 使用 双引号 + 若干字符 的方式表示字符串字面值。 1String s = &quot;胖虎同学&quot;; 使用+可以进行字符串的拼接，任何类型的变量与字符串进行拼接时，都会转换成字符串。 123int a=20;int b=21;System.out.println(&quot;&quot;+a+b); //2021 总结 常量12final int a = 10;a = 20; // 编译出错. 提示 无法为最终变量a分配值 常量不能在程序运行过程中发生修改。 类型转换 不同数字类型的变量之间赋值, 表示范围更小的类型能隐式转换成范围较大的类型 如果需要把范围大的类型赋值给范围小的, 需要强制类型转换, 但是可能精度丢失。不相关的类型不能进行类型转换。 将一个字面值常量进行赋值的时候, Java 会自动针对数字范围进行检查. 总结 运算符算术运算符+-*/% 1234System.out.println(5/2); // 2System.out.println(5.0/2); //2.5System.out.println((double)5/2); //2.5System.out.println((double)(5/2)); // 2.0 1234System.out.println(5%2); // 1System.out.println(-5%2); //-1System.out.println(5%-2); //1System.out.println(-5%-2); //-1 Java中，不仅仅可以对 int 求模, 也能对 double 来求模。 值得注意的是，下图中i=10，而c语言是11。 关系运算符== != &lt; &gt; &lt;= &gt;= 关系运算符表达式返回值都是布尔值。 逻辑运算符&amp;&amp; || ! Java中，逻辑非！只能作用于布尔值 123int a=10;int b=20;System.out.println(!a &lt; b); 位运算符&amp; | ~ ^ 移位运算符 &gt;&gt; &lt;&lt; &gt;&gt;&gt; 无符号右移 &gt;&gt;&gt;：最右侧位不要了, 最左侧补 0. 123int a = 0xffffffff;System.out.printf(&quot;%x\\n&quot;, a &gt;&gt;&gt; 1);// 运行结果(注意, 是按十六进制打印的) 7fffffff 左移 1 位, 相当于原数字 * 2. 左移 N 位, 相当于原数字 * 2 的N次方 右移 1 位, 相当于原数字 / 2. 右移 N 位, 相当于原数字 / 2 的N次方 由于计算机计算移位效率高于计算乘除, 当某个代码正好乘除 2 的N次方的时候可以用移位运算代替","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://youngsay.cn/tags/JavaSE/"}]},{"title":"c语言：操作符误区总结","slug":"c-pointer","date":"2021-11-13T03:31:01.000Z","updated":"2022-01-23T12:10:01.489Z","comments":true,"path":"2021/11/13/c-pointer/","link":"","permalink":"https://youngsay.cn/2021/11/13/c-pointer/","excerpt":"","text":"4个二进制位可以表示一个16进制数字 1111 –&gt;f 指针类型的意义： 指针类型决定了：指针解引用的权限有多大（整型指针解引用访问4个字节，字符型指针解引用只能访问1个字节） 指针类型决定了，指针走一步，能走多远（步长） 例题1： 123456 int a = 0x11223344;char* pc = &amp;a;*pc = 0; //只改变一个字节int* pa = &amp;a;*pa = 0;//改变了四个字节 char* 的指针解引用就只能访问一个字节，而 int* 的指针的解引用能访问四个字节。 例题2： 1234567int arr[10] = &#123; 0 &#125;;int* p = arr;char* pc = arr;printf(&quot;%p\\n&quot;, p);printf(&quot;%p\\n&quot;, p + 1);//加了4，因为int4字节printf(&quot;%p\\n&quot;, pc);printf(&quot;%p\\n&quot;, pc + 1);//加了1，因为char1字节 野指针：指针指向的位置是不可知的 为什么出现野指针： 指针使用时未初始化： 12int* p;//未初始化，地址是随机的*p = 10;//非法访问内存 指针越界： 12345678910//越界访问int arr[10] = &#123; 0 &#125;;int* p = arr;int i = 0;for (i = 0; i &lt;= 10; i++)&#123; *p = i; p++;&#125; 指针指向的空间释放： 12345678910111213int* test()&#123; int a = 10; return &amp;a;&#125;int main()&#123; int*p = test(); *p = 20; return 0;&#125; 退出test函数后空间释放，找不到指针p的地址。 总结：如何规避野指针？ 1.指针初始化 2.小心指针越界 3.指针指向空间释放即设置NULL 4.指针使用之前检查有效性 指针的运算： 指针±整数： 12345678int arr[10] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;int* p = arr; //元素1的地址int* pend = arr + 9; //元素10的地址while (p &lt; pend)&#123; printf(&quot;%d\\n&quot;, *p); p++;&#125; 指针-指针： 123456789int main()&#123; int arr[10] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;; char c[5]; printf(&quot;%d\\n&quot;, &amp;arr[9] - &amp;c[0]);//err，两个指针指向不同空间 printf(&quot;%d\\n&quot;, &amp;arr[9] - &amp;arr[0]);//这个输出9 return 0;&#125; 两指针相减的前提是指针指向同一块空间，指针-指针得到的是两个指针之间元素的个数 例题：求字符串长度： 12345678910111213141516171819//1.strlen()函数//2.递归//3.int my_strlen(char* str)&#123; char* start = str; while (*str != &#x27;\\0&#x27;) &#123; str++; &#125; return str - start;&#125;int main()&#123; int len = my_strlen(&quot;abc&quot;);//这里&quot;abc&quot;传入的只有首字母a的地址 printf(&quot;%d\\n&quot;, len); return 0;&#125; 指针和数组： 123456789int main()&#123; int arr[10] = &#123; 0,1,2,3,4,5,6,7,8,9 &#125;; int* p = arr; int i = 0; for (i = 0; i &lt; 10; i++) &#123; printf(&quot;&amp;arr[%d]=%p &lt;==&gt; *(p+%d)=%p\\n&quot;,i,&amp;arr[i],i,p+i);&#125; arr[i]=*(p+i) =*(arr+i); &amp;arr[i]=p+i=arr+i; 1arr[2] &lt;==&gt; *(arr+2) &lt;==&gt; *(p+2) &lt;==&gt; *(2+p) &lt;==&gt; *(2+arr) == 2[arr] 二级指针： 12345678int main()&#123; int a = 3; int* pa = &amp;a; int** ppa = &amp;pa; //ppa就是一个二级指针，用来存放指针pa，而指针pa也是一个指针，用来存放a。 printf(&quot;%d,%d,%d\\n&quot;, a,*pa,**ppa);//结果均为3&#125; 禁止套娃！！！","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"c","slug":"c","permalink":"https://youngsay.cn/tags/c/"}]},{"title":"Vue笔记：指令","slug":"vue1","date":"2021-11-06T11:25:01.000Z","updated":"2021-11-06T12:44:34.013Z","comments":true,"path":"2021/11/06/vue1/","link":"","permalink":"https://youngsay.cn/2021/11/06/vue1/","excerpt":"","text":"什么是vue 构建用户界面 用vue往html里填充数据 框架 框架是一套现成的解决方案，只能遵守框架规范写自己的业务功能 vue的特性 数据驱动视图 数据的变化会驱动视图自动更新 双向数据绑定 在网页中，form表单负责采集数据，Ajax负责提交数据 js数据的变化，会被自动渲染到页面上 页面上表单采集的数据发生变化时，会被vue自动获取到，更新到js数据中 数据驱动视图和双向数据绑定的底层原理是MVVM（Mode数据源、View视图、ViewModel就是vue实例 vue的基本使用1234567891011121314151617&lt;body&gt; &lt;!-- 希望vue控制div，把数据填充到div内部 --&gt; &lt;div id=&quot;app&quot;&gt;&#123;&#123; username &#125;&#125;&lt;/div&gt; &lt;!-- 1.导入Vue库文件，在window全局就有了vue这个构造函数 --&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;!-- 2.创建Vue的实例对象 --&gt; &lt;script&gt; const vm = new Vue(&#123; //el属性是固定写法，表示当前vm实例要控制页面上的那个区域，接受的值是一个选择器 el: &#x27;#app&#x27;, //date对象就是要渲染到页面的数据 data: &#123; username: &#x27;胖虎&#x27; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; vue指令1.内容渲染指令12345v-text：会覆盖元素内部原有指令，只能渲染纯文本内容&#123;&#123;&#125;&#125; :插值表达式,内容占位符，不会覆盖原有内容，只能渲染纯文本内容，不能用在元素的属性节点v-html:把带标签的指令渲染成html内容 2.属性绑定指令v-bind: 可简写为:为元素属性动态绑定值 在使用v-bind属性绑定期间，如果绑定内容需要进行动态拼接，则字符串的外面应该包裹单引号，如： 123&lt;div :title=&quot;&#x27;box&#x27; + index&quot;&gt; 这是一个div&lt;/div&gt; 在 &#123;&#123;&#125;&#125;插值表达式和v-bind指令中可以使用js语法 3.事件绑定指令v-on:可简写为@，为元素绑定事件 1234567&lt;button @click=&#x27;add&#x27;&gt;+1&lt;/button&gt;methods: &#123; add()&#123; this.count+=1; &#125; 如果默认对象事件e被覆盖，可以手动传递$event 1234567&lt;button @click=&#x27;add(1,$event)&#x27;&gt;+1&lt;/button&gt;methods: &#123; add(n,e)&#123; this.count+=1; &#125; 事件修饰符在事件处理函数中调用event.preventDefault()和event.stopPropagation()很常见，为了更方便对事件触发进行控制，vue提供了事件修饰符概念。 .prevent：组织默认行为（链接跳转、表单提交） .stop：阻止事件冒泡 1234567&lt;a href=&quot;http:www.baidu.com&quot; @click.prevent=&quot;btn&quot;&gt;百度一下&lt;/a&gt;methods: &#123; btn()&#123; console.log(&quot;hhh&quot;); &#125;&#125; 4.双向绑定指令v-model ：input输入框、textarea、select，v-model 会根据控件类型自动选取正确的方法来更新元素。 1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;p&gt;input 元素：&lt;/p&gt; &lt;input v-model=&quot;message&quot; placeholder=&quot;编辑我……&quot;&gt; &lt;p&gt;消息是: &#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;胖虎&#x27;, &#125;&#125;)&lt;/script&gt; v-model指令修饰符.number：自动将用户的输入值转为数值类型 .trim：自动过滤用户输入的首尾空白字符 5.条件渲染指令v-if：每次动态创建或移除元素，实现元素的显示和隐藏 v-show：动态为元素添加或移除display:none样式，来实现元素的显示和隐藏 6.列表渲染指令v-for：用来辅助开发者基于一个数组来循环渲染一个列表结构。v-for 指令需要使用 item in list 形式的特殊语法 12345678910111213141516171819202122232425&lt;div id=&quot;app&quot;&gt; &lt;table class=&quot;table table-bordered table-hover table-striped&quot;&gt; &lt;thead&gt; &lt;th&gt;索引&lt;/th&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=&quot;(item,index) in list&quot; :key=&quot;item.id&quot;&gt; &lt;td&gt;&#123;&#123;index&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;data: &#123; list:[ &#123;id:1, name:&#x27;胖虎&#x27;&#125;, &#123;id:2 ,name:&#x27;大熊&#x27;&#125;, &#123;id:3 ,name:&#x27;小夫&#x27;&#125; ]&#125;,","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://youngsay.cn/tags/Vue-js/"}]},{"title":"Python笔记：条件、循环及其他语句","slug":"python5","date":"2021-11-03T11:25:01.000Z","updated":"2021-11-05T11:40:51.533Z","comments":true,"path":"2021/11/03/python5/","link":"","permalink":"https://youngsay.cn/2021/11/03/python5/","excerpt":"","text":"Python基础教程（第三版）第5章：条件、循环及其他语句 print()end=&#39;&#39; //不换行 sep=&#39;&#39; //自定义分隔符 123print(&quot;my name is&quot;,end=&#x27;&#x27;)print(&quot;panghu&quot;) //打印结果：my name is panghuprint(&quot;I&quot;,&quot;love&quot;,&quot;you&quot;,sep=&quot;!&quot;) //I!love!you import当你确定要导入模块中的一切时，可使用from somemodule import *如果有两个模块，都包某一函数时，可使用as 12import math as foobarprint(foobar.sqrt(4)) //2.0 序列解包1234values=1,2,3x,y,z=valuesprint(values) //(1,2,3)print(z) //3 *元素符：分配多余的值 12345values=1,2,3,4x,*y,z=valuesprint(x) // 1print(y) //[2,3]print(z) //4 条件语句中的布尔值在Python的条件语句中，不止False``0表示假，None &quot;&quot; () [] &#123;&#125;都表示假 循环中的else子句python中的break、continue和c语言中的功能一样。 break 语句可以跳出 for 和 while 的循环体。 continue 语句被用来跳过当前循环块中的剩余语句，然后继续进行下一轮循环。 1234567n = 5while n &gt; 0: n -= 1 if n == 2: break print(n)print(&#x27;循环结束。&#x27;) 输出结果为 12343循环结束。 当将break换成continue时，输出结果是 123454310循环结束。 以上和c语言没什么不同，python循环语句有一点与c不同。 循环语句可以有else 子句，它在穷尽列表(以for循环)或条件变为 false (以while循环)导致循环终止时被执行，但循环被 break 终止时不执行。 打印100以内的素数： 12345678910num=[];i=2for i in range(2,100): j=2 for j in range(2,i): if(i%j==0): break else: num.append(i)print(num) 比较运算符x is y x和y是同一个对象 x is not y x和y是不同的对象 x in y x是容器（如序列）y的成员 x not in y x不是容器（如序列）y的成员 1234x=y=[1,2,3]z=[1,2,3]print(x==z) //Trueprint(x is z) // False ==用来检查两个对象是否相等，而is用来检查两个对象是否相同（是同一个对象）。 遍历字典123d = &#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 2, &#x27;z&#x27;: 3&#125;for key in d: print(key, &#x27;corresponds to&#x27;, d[key]) 12for key, value in d.items(): print(key, &#x27;corresponds to&#x27;, value) zip()一个很有用的并行迭代工具是内置函数zip，它将两个序列“缝合”起来，并返回一个由元组组成的序列。返回值是一个适合迭代的对象，要查看其内容，可使用list将其转换为列表。 123name=[&quot;panghu&quot;,&quot;daxiong&quot;,&quot;jiqimao&quot;]age=[20,21,22]print(list(zip(name,age))) //[(&#x27;panghu&#x27;, 20), (&#x27;daxiong&#x27;, 21), (&#x27;jiqimao&#x27;, 22)]","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://youngsay.cn/tags/Python/"}]},{"title":"ECMAScript 6入门","slug":"es6","date":"2021-10-31T04:25:01.000Z","updated":"2021-10-31T12:55:55.085Z","comments":true,"path":"2021/10/31/es6/","link":"","permalink":"https://youngsay.cn/2021/10/31/es6/","excerpt":"","text":"letvar和let声明变量的区别： let声明的变量是块级变量，只存在{}内。 1234if(true)&#123; let a=0;&#125;console.log(a); 会出现Uncaught ReferenceError: a is not defined的报错，而在{}内打印console.log(a)而不会报错。 let声明的变量没有变量提升 12console.log(a);let a=0; 如上代码会报错Uncaught ReferenceError: Cannot access &#39;a&#39; before initialization let声明的变量会出现暂时死区 在{}外用var声明变量，{}内用let声明一个相同的变量，{}外用var声明的变量便没有意义。 12345var a=10;if(true)&#123; console.log(a); let a=20;&#125; 如上代码依旧会报错Uncaught ReferenceError: Cannot access &#39;a&#39; before initialization const 具有块级作用域 1234 if (true) &#123; const a = 10; &#125;console.log(a) // a is not defined 声明变量要赋值 1const PI; 未初始化会报错Uncaught SyntaxError: Missing initializer in const declaration 常量赋值后，简单数据类型值不能修改，复杂数据类型地址不能更改。 1234const a = [];a.push(&#x27;Hello&#x27;); // 可执行a.length = 0; // 可执行a = [&#x27;Dave&#x27;]; // 报错 解构赋值数组结构1234let [a,b,c]=[1,2,3];console.log(a); //1console.log(b); //2console.log(c); //3 对象结构1234567let obj=&#123; name:&#x27;panghu&#x27;, age:20&#125;;let &#123;name,age&#125;=obj;console.log(name); //panghuconsole.log(age); //20 箭头函数=&gt;12345const sum=(n1,n2)=&gt;&#123; n1+n2;&#125;const result=sum(10,20);console.log(result); 当键头后的{}内只有一个表达式，可去掉{}；当()里的参数只有一个，可去掉()。 123const al=v=&gt;alert(v) //al是函数名，v是函数形参const result=al(20)console.log(result); 剩余参数12345sum=(a,...b)=&gt;&#123; console.log(a); //3 console.log(b); //[4,5]&#125;sum(3,4,5); 1234let students = [&#x27;胖虎&#x27;, &#x27;张三&#x27;, &#x27;李四&#x27;];let [s1, ...s2] = students; console.log(s1); // &#x27;胖虎&#x27; console.log(s2); // [&#x27;张三&#x27;, &#x27;李四&#x27;]","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://youngsay.cn/tags/JavaScript/"}]},{"title":"c语言：操作符误区总结","slug":"c-operator","date":"2021-10-24T14:31:01.000Z","updated":"2022-01-23T12:10:08.463Z","comments":true,"path":"2021/10/24/c-operator/","link":"","permalink":"https://youngsay.cn/2021/10/24/c-operator/","excerpt":"","text":"左移操作符：&lt;&lt; 左边丢弃，右边补0 12345678int main()&#123; int a = 2; //把a的二进制位向左移动一位 int b = a &lt;&lt; 1; printf(&quot;b = %d\\n&quot;, b);//输出为4 return 0;&#125; 右移操作符：&gt;&gt; 1.算术右移：右边丢弃，左边补原符号位 2.逻辑右移：右边丢弃，左边补0 1234567#include&lt;stdio.h&gt;int main()&#123; int a = -3; int b = a &gt;&gt; 1; printf(&quot;%d&quot;, b); //输出为-2&#125; 负数在内存中存放的是二进制的补码。 原码：直接根据数值写出的二进制序列 反码：符号位不变，其他位按位取反 补码：反码+1 以-3为例： 原码：10000000000000000000000000000011 反码：11111111111111111111111111111100 补码：11111111111111111111111111111101 异或：^ 同为0，异为1 练习：a=3，b=5，交换a、b两个数的值 方法1：创建中间变量 1234567891011#include&lt;stdio.h&gt;int main()&#123; int a = 3; int b = 5; int temp = 0; temp = a; a = b; b = temp; printf(&quot;a=%d,b=%d&quot;, a, b); //a=5,b=3&#125; 方法2：加减运算（数值太大可能溢出） 123456789int main()&#123; int a = 3; int b = 5; a = a + b; b = a - b; a = a - b; printf(&quot;a=%d,b=%d&quot;, a, b);&#125; 方法三：异或运算 12345678910#include&lt;stdio.h&gt;int main()&#123; int a = 3; int b = 5; a = a ^ b; b = a ^ b; a = a ^ b; printf(&quot;a=%d,b=%d&quot;, a,b);&#125; 同值异或值为0，任何值异或0都是值本身。a^a=0 0^a=a 单目运算符： sizeof也是单目运算符，可以计算变量所占空间的大小，单位是字节。 123456int a = 5;int arr[5] = &#123; 0 &#125;;printf(&quot;%d\\n&quot;, sizeof(a));//4 printf(&quot;%d\\n&quot;, sizeof(int));//4 printf(&quot;%d\\n&quot;, sizeof(arr));//20 sizeof(数组名)printf(&quot;%d\\n&quot;, sizeof(int [5]));//20 sizeof(数组类型) sizeof()，括号内可以说变量名，也可以是变量类型，如果是变量名可以去掉小括号，如sizeof a 思考一下下面这段代码，两次输出是什么？ 1234short s = 5;int a = 10;printf(&quot;%d\\n&quot;, sizeof(s = a + 2));printf(&quot;%d\\n&quot;, s); 输出结果是2、5。s的类型是short，sizeof(short)结果必然是2，而sizeof括号里的表达式不参与运算，所以s仍未5。 前置和后置： 1234int a = 10;int b = a++;//后置++，先使用，再++printf(&quot;%d\\n&quot;, a);//11printf(&quot;%d\\n&quot;, b);//10 1234int a = 10;int b = ++a;//前置++，先++，后使用printf(&quot;%d\\n&quot;, a);//11printf(&quot;%d\\n&quot;, b);//11 指针大小永远是4字节或8字节 123456789101112131415161718void test1(int arr[])//相当于int *arr&#123; printf(&quot;%d\\n&quot;, sizeof(arr));//4&#125;void test2(char ch[])//相当于char *arr&#123; printf(&quot;%d\\n&quot;, sizeof(ch));//4&#125;int main()&#123; int arr[10] = &#123; 0 &#125;; char ch[10] = &#123; 0 &#125;; printf(&quot;%d\\n&quot;, sizeof(arr));//40 printf(&quot;%d\\n&quot;, sizeof(ch));//10 test1(arr); test2(arr); return 0;&#125; 结构成员访问操作符：. -&gt; . 结构体.成员名 -&gt; 结构体指针-&gt;成员名 12345678910111213141516#include&lt;stdio.h&gt;struct students&#123; //结构体的成员（变量） char name[10]; int age;&#125;;int main()&#123; struct students a = &#123; &quot;胖虎&quot;,20 &#125;; struct students *pb = &amp;a; //说明pb是struct students类型的指针 //结构体变量名.成员名 printf(&quot;姓名：%s，年龄：%d\\n&quot;, a.name,a.age); //结构体指针-&gt;成员名 printf(&quot;姓名：%s，年龄：%d&quot;, pb-&gt;name,pb-&gt;age);&#125; 整型提升： C的整型算术运算总是至少以缺省整型类型的精度来进行的。 为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为整型提升。 12345678910111213141516171819int main()&#123; char a = 3; //0000000000000000000000000000011 (int a) //00000011 --a //0000000000000000000000000000011 (a的整型提升) char b = 127; //0000000000000000000000001111111 (int b) //01111111 --b //0000000000000000000000001111111 (b的整型提升) //0000000000000000000000010000010 int c //10000010 --c //1111111111111111111111110000010 补码 (c的整型提升) //1000000000000000000000001111101 反码 //1000000000000000000000001111110 原码 char c = a + b; printf(&quot;%d&quot;, c); return 0;&#125; 整形提升是按照变量的数据类型的符号位来提升的 1234567891011121314151617//负数的整形提升char c1 = -1;变量c1的二进制位(补码)中只有8个比特位：1111111因为 char 为有符号的 char所以整形提升的时候，高位补充符号位，即为1提升之后的结果是：11111111111111111111111111111111//正数的整形提升char c2 = 1;变量c2的二进制位(补码)中只有8个比特位：00000001因为 char 为有符号的 char所以整形提升的时候，高位补充符号位，即为0提升之后的结果是：00000000000000000000000000000001//无符号整形提升，高位补0 总结：char和short类型，在参与表达式运算时达不到整型长度，会发生整型提升。","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"c","slug":"c","permalink":"https://youngsay.cn/tags/c/"}]},{"title":"c语言：数组误区总结","slug":"c-array","date":"2021-10-22T12:31:01.000Z","updated":"2022-01-23T12:10:22.031Z","comments":true,"path":"2021/10/22/c-array/","link":"","permalink":"https://youngsay.cn/2021/10/22/c-array/","excerpt":"","text":"创建数组时，数组的长度必须用常量表达式进行定义，较好的方法是用宏来定义数组。 12#define N 10;int arr[N]; 但在C99中的变长数组，也可以使用非常量表达式。 关于字符数组的初始化，使用方法2初始化数组会在末尾自动创建\\0。 12char ch1[] = &#123; &#x27;p&#x27;,&#x27;a&#x27;,&#x27;n&#x27;,&#x27;g&#x27;,&#x27;h&#x27;,&#x27;u&#x27; &#125;;char ch2[] = &quot;panghu&quot;; 这就会导致打印结果、字符串长度的不同。 strlen() 函数从字符串的开头位置依次向后计数，直到遇见\\0，然后返回计时器的值。最终统计的字符串长度不包括\\0。 12345678910#include &lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char ch1[] = &#123; &#x27;p&#x27;,&#x27;a&#x27;,&#x27;n&#x27;,&#x27;g&#x27;,&#x27;h&#x27;,&#x27;u&#x27; &#125;; char ch2[] = &quot;panghu&quot;; printf(&quot;%s,%d\\n&quot;, ch1, strlen(ch1)); printf(&quot;%s,%d\\n&quot;, ch2,strlen(ch2)); return 0;&#125; 因为数组ch1没有添加终止符\\0，打印内容出现了意外，字符串长度也是一个随机数。 由数组中各元素的地址可知，一维数组在内存中是连续存放的，随着数组下标的增长，地址由低到高变化。（二维数组也是如此） 12345678910#include &lt;stdio.h&gt;int main()&#123; int arr[10] = &#123; 0 &#125;; int i = 0; for (i = 0; i &lt; 10; i++) &#123; printf(&quot;&amp;arr[%d]=%p\\n&quot;, i,&amp;arr[i]); &#125; return 0;&#125; 所以当我们知道数组中首元素的地址，便可以打印出所有元素。 123456789101112#include &lt;stdio.h&gt;int main()&#123; int arr[10] = &#123; 0,1,2,3,4,5,6,7,8,9 &#125;; int *p = arr; int i = 0; for (i = 0; i &lt; 10; i++) &#123; printf(&quot;arr[%d]=%d\\n&quot;,i, *p); p++; &#125; return 0;&#125; 关于arr和&amp;arr： 12345int arr[] = &#123; 0,1,2,3,4 &#125;;printf(&quot;%p\\n&quot;, arr); //首元素地址printf(&quot;%p\\n&quot;, &amp;arr[0]);printf(&quot;%d\\n&quot;, sizeof(arr)); //整个数组的大小printf(&quot;%p\\n&quot;, &amp;arr); //整个数组的地址 数组名是首元素的地址。 sizeof(数组名)表示的是整个数组的大小，单位是字节。 &amp;数组名表示的是整个数组，取出的是整个数组的地址。 首元素地址和数组地址的值是一样的，但意义不同，可以试着输出&amp;数组名+1和数组名+1，进行比较。 数组作为函数传参时，形参可以写成两种形式： 一是数组形式，二是指针形式。 12345678int arr[10];//函数定义void test(int arr[10]) //写法②：void test(int *arr)&#123;&#125;&#123; ……&#125;test(arr); //函数调用","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"c","slug":"c","permalink":"https://youngsay.cn/tags/c/"}]},{"title":"WebApiⅢ：事件、事件对象","slug":"js-shijian","date":"2021-09-16T09:45:54.000Z","updated":"2021-09-16T13:07:35.955Z","comments":true,"path":"2021/09/16/js-shijian/","link":"","permalink":"https://youngsay.cn/2021/09/16/js-shijian/","excerpt":"","text":"注册事件 传统方式 btn.onclick = function() &#123;&#125; 传统事件注册具有唯一性：同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数 方法监听注册方式 1eventTarget.addEventListener(type,listener[,useCapture]) type：事件类型字符串，比如 click、mouseover。这里不需要加onlistener：事件处理函数，事件发生时，会调用该监听函数useCapture：可选参数，是一个布尔值，默认是false。 1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;button&gt; 传统注册事件 &lt;/button&gt; &lt;button&gt; 事件监听注册事件 &lt;/button&gt; &lt;script&gt; var btns = document.querySelectorAll(&#x27;button&#x27;); //传统注册事件 btns[0].onclick = function()&#123; alert(&#x27;hi&#x27;); &#125; btns[0].onclick = function()&#123; alert(&#x27;传统注册事件&#x27;); &#125; //运行程序，点击传统注册事件按钮，弹出提示框：传统注册事件。第一个hi提示框被覆盖，不会弹出。 //事件侦听注册事件 btns[1].addEventListener(&#x27;click&#x27;,function()&#123; alert(&#x27;事件监听注册事件&#x27;); &#125;) btns[1].addEventListener(&#x27;click&#x27;,function()&#123; alert(&#x27;事件监听注册事件2&#x27;); &#125;) //运行程序，点击事件监听注册事件按钮，弹出提示框：事件监听注册事件，点击确定后，再次弹出“事件监听注册事件2”的提示框 //在事件侦听注册事件的方法中事件类型要加引号并且没有on &lt;/script&gt;&lt;/body&gt; 删除事件 传统方式 eventTarget.onclick = null; 方法监听注册方式 1eventTarget.removeEventListener(type,listener[,useCapture]) 1234567891011121314151617&lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;&lt;div&gt;3&lt;/div&gt;&lt;script&gt; var divs = document.querySelectorAll(&#x27;div&#x27;); divs[0].onclick = function() &#123; alert(11); // 1. 传统方式删除事件 divs[0].onclick = null; &#125; // 2. removeEventListener 删除事件 divs[1].addEventListener(&#x27;click&#x27;, fn) // 里面的fn 不需要调用加小括号 function fn() &#123; alert(22); divs[1].removeEventListener(&#x27;click&#x27;, fn); &#125;&lt;/script&gt; DOM事件流事件流描述的是从页面接受事件的顺序，这个传播顺序就是DOM事件流。 DOM事件流会历经 捕获阶段、当前目标阶段、冒泡阶段 这三个阶段 js代码只能执行捕获或冒泡其中的一个阶段 onclick、attachEvent只有冒泡阶段 addEventListener(type,listener,true)表示在事件捕获阶段调用事件处理程序，如果第三个参数是false表示在事件冒泡阶段调用事件处理程序。 事件冒泡12345678910111213141516171819202122&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt;&lt;/div&gt;&lt;script&gt; // onclick 和 attachEvent（ie） 在冒泡阶段触发 // 冒泡阶段 如果addEventListener 第三个参数是 false 或者 省略 // son -&gt; father -&gt;body -&gt; html -&gt; document var son = document.querySelector(&#x27;.son&#x27;); // 给son注册单击事件 son.addEventListener(&#x27;click&#x27;, function() &#123; alert(&#x27;son&#x27;); &#125;, false); // 给father注册单击事件 var father = document.querySelector(&#x27;.father&#x27;); father.addEventListener(&#x27;click&#x27;, function() &#123; alert(&#x27;father&#x27;); &#125;, false); // 给document注册单击事件，省略第3个参数 document.addEventListener(&#x27;click&#x27;, function() &#123; alert(&#x27;document&#x27;); &#125;)&lt;/script&gt; 事件捕获123456789101112131415161718192021&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt;&lt;/div&gt;&lt;script&gt; // 如果addEventListener() 第三个参数是 true 那么在捕获阶段触发 // document -&gt; html -&gt; body -&gt; father -&gt; son var son = document.querySelector(&#x27;.son&#x27;); // 给son注册单击事件，第3个参数为true son.addEventListener(&#x27;click&#x27;, function() &#123; alert(&#x27;son&#x27;); &#125;, true); var father = document.querySelector(&#x27;.father&#x27;); // 给father注册单击事件，第3个参数为true father.addEventListener(&#x27;click&#x27;, function() &#123; alert(&#x27;father&#x27;); &#125;, true); // 给document注册单击事件，第3个参数为true document.addEventListener(&#x27;click&#x27;, function() &#123; alert(&#x27;document&#x27;); &#125;, true)&lt;/script&gt; 事件对象事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象。 比如： 谁绑定了这个事件。 鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置。 键盘触发事件的话，会得到键盘的相关信息，如按了哪个键。 123456789&lt;div&gt;123&lt;/div&gt;&lt;script&gt; var div = document.querySelector(&#x27;div&#x27;); div.onclick = function(e) &#123; // 事件对象 可以写成e、evt、event e = e || window.event; //兼容性写法 console.log(e); &#125;&lt;/script&gt; 事件对象的属性和方法 123456789101112131415&lt;ul&gt; &lt;li&gt;abc&lt;/li&gt; &lt;li&gt;abc&lt;/li&gt; &lt;li&gt;abc&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var ul = document.querySelector(&#x27;ul&#x27;); ul.addEventListener(&#x27;click&#x27;, function(e) &#123; // 我们给ul 绑定了事件 那么this 就指向ul console.log(this); // ul // e.target 触发了事件的对象 我们点击的是li e.target 指向的就是li console.log(e.target); // li &#125;);&lt;/script&gt; 阻止默认行为html中一些标签有默认行为，例如a标签被单击后，默认会进行页面跳转。 1234567891011121314151617&lt;a href=&quot;https://blog.wangyouwu.cn&quot;&gt;胖虎同学&lt;/a&gt;&lt;script&gt; // 2. 阻止默认行为 让链接不跳转 var a = document.querySelector(&#x27;a&#x27;); a.addEventListener(&#x27;click&#x27;, function(e) &#123; e.preventDefault(); // dom 标准写法 &#125;); // 3. 传统的注册方式 a.onclick = function(e) &#123; // 普通浏览器 e.preventDefault(); 方法 e.preventDefault(); // 低版本浏览器 ie678 returnValue 属性 e.returnValue = false; // 我们可以利用return false 也能阻止默认行为 没有兼容性问题 return false; &#125;&lt;/script&gt; 阻止事件冒泡12345678910111213141516171819202122&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;son儿子&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var son = document.querySelector(&#x27;.son&#x27;); // 给son注册单击事件 son.addEventListener(&#x27;click&#x27;, function(e) &#123; alert(&#x27;son&#x27;); e.stopPropagation(); // stop 停止 Propagation 传播 window.event.cancelBubble = true; // 非标准 cancel 取消 bubble 泡泡 &#125;, false); var father = document.querySelector(&#x27;.father&#x27;); // 给father注册单击事件 father.addEventListener(&#x27;click&#x27;, function() &#123; alert(&#x27;father&#x27;); &#125;, false); // 给document注册单击事件 document.addEventListener(&#x27;click&#x27;, function() &#123; alert(&#x27;document&#x27;); &#125;) &lt;/script&gt; 事件委托事件委托也称为事件代理，在 jQuery 里面称为事件委派。 给父元素注册事件，利用事件冒泡，当子元素的事件触发，会冒泡到父元素，然后去控制相应的子元素。 123456789101112131415&lt;ul&gt; &lt;li&gt;点我一下试试&lt;/li&gt; &lt;li&gt;点我一下试试&lt;/li&gt; &lt;li&gt;点我一下试试&lt;/li&gt; &lt;li&gt;点我一下试试&lt;/li&gt; &lt;li&gt;点我一下试试&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; // 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点 var ul = document.querySelector(&#x27;ul&#x27;); ul.addEventListener(&#x27;click&#x27;, function(e) &#123; // e.target 这个可以得到我们点击的对象 e.target.style.backgroundColor = &#x27;pink&#x27;; &#125;)&lt;/script&gt; 常用鼠标事件 禁止鼠标右键 contextmenu 禁止鼠标选中 selectstar 12345678910111213&lt;body&gt; 休想复制我 &lt;script&gt; // 1. contextmenu 禁用右键菜单 document.addEventListener(&#x27;contextmenu&#x27;, function(e) &#123; e.preventDefault(); &#125;) // 2. selectstart 禁止选中文字 document.addEventListener(&#x27;selectstart&#x27;, function(e) &#123; e.preventDefault(); &#125;) &lt;/script&gt;&lt;/body&gt; 鼠标事件对象 12345678910111213141516171819&lt;script&gt; // 鼠标事件对象 MouseEvent document.addEventListener(&#x27;click&#x27;, function(e) &#123; // 1. client 鼠标在可视区的x和y坐标 console.log(e.clientX); console.log(e.clientY); console.log(&#x27;---------------------&#x27;); // 2. page 鼠标在页面文档的x和y坐标 console.log(e.pageX); console.log(e.pageY); console.log(&#x27;---------------------&#x27;); // 3. screen 鼠标在电脑屏幕的x和y坐标 console.log(e.screenX); console.log(e.screenY); &#125;) &lt;/script&gt; 常用键盘事件 onkeypress不识别功能键，如shift等，但区分大小写 三个事件执行顺序：keydown、keypress、keyup 1234567891011121314151617&lt;script&gt; // 常用的键盘事件 //1. keyup 按键弹起的时候触发 document.addEventListener(&#x27;keyup&#x27;, function() &#123; console.log(&#x27;我弹起了&#x27;); &#125;) //3. keypress 按键按下的时候触发 不能识别功能键 比如 ctrl shift 左右箭头啊 document.addEventListener(&#x27;keypress&#x27;, function() &#123; console.log(&#x27;我按下了press&#x27;); &#125;) //2. keydown 按键按下的时候触发 能识别功能键 比如 ctrl shift 左右箭头啊 document.addEventListener(&#x27;keydown&#x27;, function() &#123; console.log(&#x27;我按下了down&#x27;); &#125;) // 4. 三个事件的执行顺序 keydown -- keypress -- keyup&lt;/script&gt; 键盘事件对象 12345678910111213141516&lt;script&gt; // 键盘事件对象中的keyCode属性可以得到相应键的ASCII码值 document.addEventListener(&#x27;keyup&#x27;, function(e) &#123; console.log(&#x27;up:&#x27; + e.keyCode); // 我们可以利用keycode返回的ASCII码值来判断用户按下了那个键 if (e.keyCode === 65) &#123; alert(&#x27;您按下的a键&#x27;); &#125; else &#123; alert(&#x27;您没有按下a键&#x27;) &#125; &#125;) document.addEventListener(&#x27;keypress&#x27;, function(e) &#123; // console.log(e); console.log(&#x27;press:&#x27; + e.keyCode); &#125;)&lt;/script&gt;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://youngsay.cn/tags/JavaScript/"}]},{"title":"WebApiⅡ：自定义属性、节点","slug":"js-node","date":"2021-09-13T13:45:54.000Z","updated":"2021-09-16T09:05:23.331Z","comments":true,"path":"2021/09/13/js-node/","link":"","permalink":"https://youngsay.cn/2021/09/13/js-node/","excerpt":"","text":"自定义属性获取属性值 element.属性 ：获取内置属性值 element.getAttribute(‘属性’) ：获取自定义属性值 12345678910&lt;div id=&quot;demo&quot; index=&quot;1&quot; class=&quot;nav&quot;&gt;&lt;/div&gt;&lt;script&gt; var div = document.querySelector(&#x27;div&#x27;); // 1. 获取元素的属性值 // (1) element.属性 console.log(div.id); //demo //(2) element.getAttribute(&#x27;属性&#x27;) console.log(div.getAttribute(&#x27;id&#x27;)); //demo console.log(div.getAttribute(&#x27;index&#x27;)); //1&lt;/script&gt; 设置属性值 element.属性 = ‘属性值’ element.setAttribute (‘属性’,’属性值’) ：设置自定义属性值 123456// (1) element.属性= &#x27;值&#x27; div.id = &#x27;test&#x27;; div.className = &#x27;navs&#x27;;// (2) element.setAttribute(&#x27;属性&#x27;, &#x27;值&#x27;); 主要针对于自定义属性 div.setAttribute(&#x27;index&#x27;, 2); div.setAttribute(&#x27;class&#x27;, &#x27;footer&#x27;); 移除属性element.removeAttribute (&#39;属性&#39;) h5自定义属性自定义属性获取是通过getAttribute(‘属性’) 获取。 但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性。 1234567891011121314151617&lt;div getTime=&quot;20&quot; data-index=&quot;2&quot; data-list-name=&quot;andy&quot;&gt;&lt;/div&gt;&lt;script&gt; var div = document.querySelector(&#x27;div&#x27;); // console.log(div.getTime); console.log(div.getAttribute(&#x27;getTime&#x27;)); div.setAttribute(&#x27;data-time&#x27;, 20); console.log(div.getAttribute(&#x27;data-index&#x27;)); console.log(div.getAttribute(&#x27;data-list-name&#x27;)); // h5新增的获取自定义属性的方法 它只能获取data-开头的 // dataset 是一个集合里面存放了所有以data开头的自定义属性 console.log(div.dataset); console.log(div.dataset.index); console.log(div.dataset[&#x27;index&#x27;]); // 如果自定义属性里面有多个-链接的单词，我们获取的时候采取 驼峰命名法 console.log(div.dataset.listName); console.log(div.dataset[&#x27;listName&#x27;]);&lt;/script&gt; 节点网页中的所有内容都是节点（标签、属性、文本、注释等），在DOM 中，节点使用 node 来表示。 一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性。 元素节点 nodeType 为1 属性节点 nodeType 为2 文本节点 nodeType 为3（文字、空格、换行） 实际开发中，节点操作主要操作元素节点 父级节点node.parentNode parentNode返回某节点的父节点（最近的），没有则返回null 12345678&lt;div class=&quot;demo&quot;&gt; &lt;div class=&quot;dad&quot;&gt; &lt;span class=&quot;son&quot;&gt;×&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; console.log(son.parentNode); &lt;/script&gt; 子节点parentNode.chlidNodes(标准) 返回值包含所有子节点，包括元素、文本节点等，so一般不用childNodes parentNode.children(非标准) 返回值只有元素字节，so提倡用children 12345678910111213141516171819&lt;ul&gt; &lt;li&gt;胖虎同学&lt;/li&gt; &lt;li&gt;panghutx&lt;/li&gt; &lt;li&gt;www.wangyouwu.cn&lt;/li&gt; &lt;li&gt;blog.wangyouwu.cn&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; // DOM 提供的方法（API）获取 var ul = document.querySelector(&#x27;ul&#x27;); var lis = ul.querySelectorAll(&#x27;li&#x27;); // 1. 子节点 childNodes 所有的子节点 包含 元素节点 文本节点等等 console.log(ul.childNodes); console.log(ul.childNodes[0].nodeType); //3 console.log(ul.childNodes[1].nodeType); //1 // 2. children 获取所有的子元素节点 也是我们实际开发常用的 console.log(ul.children); console.log(ul.children[0]); //第一个li console.log(ul.children[ul.children.length - 1]);//最后一个li&lt;/script&gt; 创建/添加节点 创建节点 document.creatElement(&#39;tagName&#39;) 添加节点 node.appendChild(child) 将节点添加到父节点的子节点列表末尾 node.inserBefore(child,指定元素) 将节点添加到父节点的子节点列表开头 1234567891011121314&lt;ul&gt; &lt;li&gt;胖虎同学&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; // 1. 创建节点元素节点 var li = document.createElement(&#x27;li&#x27;); // 2. 添加节点 node.appendChild(child) node 父级 child 是子级 后面追加元素 var ul = document.querySelector(&#x27;ul&#x27;); ul.appendChild(li); // 3. 添加节点 node.insertBefore(child, 指定元素); var lili = document.createElement(&#x27;li&#x27;); ul.insertBefore(lili, ul.children[0]); // 4. 我们想要页面添加一个新的元素 ： 1. 创建元素 2. 添加元素&lt;/script&gt; 删除节点node.removeChild() 从node节点中删除子节点，返回的是删除节点 123456789101112131415161718192021&lt;button&gt;删除&lt;/button&gt; &lt;ul&gt; &lt;li&gt;胖虎&lt;/li&gt; &lt;li&gt;胖虎同学&lt;/li&gt; &lt;li&gt;胖虎同学的博客&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 1.获取元素 var ul = document.querySelector(&#x27;ul&#x27;); var btn = document.querySelector(&#x27;button&#x27;); // 2. 删除元素 node.removeChild(child) // ul.removeChild(ul.children[0]); // 3. 点击按钮依次删除里面的孩子 btn.onclick = function() &#123; if (ul.children.length == 0) &#123; this.disabled = true; &#125; else &#123; ul.removeChild(ul.children[0]); &#125; &#125; &lt;/script&gt; 克隆节点node.cloneNode() 如果括号参数为空或false，则为浅拷贝，只克隆节点本身，不克隆里面的子节点 括号参数为true，则为深拷贝，会克隆字节本身以及里面所有子节点 123456789101112&lt;ul&gt; &lt;li&gt;1111&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var ul = document.querySelector(&#x27;ul&#x27;); // 1. node.cloneNode(); 括号为空或者里面是false 浅拷贝 只复制标签不复制里面的内容 // 2. node.cloneNode(true); 括号为true 深拷贝 复制标签复制里面的内容 var lili = ul.children[0].cloneNode(true); ul.appendChild(lili);&lt;/script&gt; DOM重点总结文档对象模型（Document Object Model），处理可拓展标记语言的编程接口，可以改变网页内容、结构、样式。 关于DOM操作，主要针对元素操作，主要有创建、增删改查、属性操作、实践操作。 创建： document.write innerHTML creatElement 增加 appendChild insertBefore 删除 removeChild 改 查 属性操作 事件操作","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://youngsay.cn/tags/JavaScript/"}]},{"title":"《认知觉醒》：真正的成长不是懂得多少道理，而是做出多少改变","slug":"read-renzhi","date":"2021-09-05T10:49:01.000Z","updated":"2021-09-05T10:16:09.983Z","comments":true,"path":"2021/09/05/read-renzhi/","link":"","permalink":"https://youngsay.cn/2021/09/05/read-renzhi/","excerpt":"","text":"年轻的时候，人人都自命不凡，认定美好生活会自然到来。后来他们不得不敲碎那颗高傲的心，在无奈和叹息中接受平庸的自己。 杨绛说：“你的问题在于想得太多，读书太少”。学而不思则罔，思而不学则怠，学习和思考是缺一不可的。看完《认知觉醒》，我觉得还有一点更重要的，行动。“道理我都懂，就是做不到”，“听过很多道理，依然过不好这一生”，都是因为缺少行动。懂得百点不如改变一点，真正的成长不是懂得多少道理，而是做出多少改变。 做出行动和改变急于求成、避难趋易是人的天性。从难度上来讲，阅读&lt;思考&lt;行动，一些人往往选择最简单的阅读，却不愿行动，这是避难趋易的天性；读完一本书马不停蹄地读下一本，没有思考和行动，却又想立刻见到成效，这是急于求成的天性。就功课的学习而言，我喜欢看视频学习，很少刷题。我知道刷题能取得更快的提升，但我还是看视频来麻木自己。因为相对刷题，看视频是更省力的方式，这都是避难趋易的天性在作怪。所以一件事如何去做，不必去找什么方法技巧，你最不愿意尝试的那个就是最有效的方法。什么最重要，每个人都心知肚明，却不愿面对，人们愿意活在自己的舒适区。 正确的行动往往是反天性的，让你觉得舒服和容易的事往往得不到好结果， 而一开始你认为难受和困难的事才能让你真正产生收获， 活在舒适区边缘活在轻车熟路的舒适区不会有任何提升，闯入望尘莫及的困难区也很难进步，我们应该在舒适区边缘不断试探。在舒适区边缘，既有挑战又有成就，能够不断扩宽自己舒适区的边界。如果只是阅读，就是单纯的输入，这是活在自己的舒适区，不会有成效。而阅读时的思考，思考后的改变，就是在舒适区的边缘试探，虽然有挑战但有收获。很多人的焦虑痛苦就是只顾着表层的学习，努力到感动自己，却一直没有跳出舒适区。如果不关注思考、行动、改变，就不会学有所获，还会怀疑是自己学的不够，陷入“越学越焦虑”的怪圈。 “多即是少，少即是多”，停在表层，我们就会陷入欲望漩涡，什么都想学、什么都想要，忙忙碌碌却收效甚微；若是能深入底层，盯住实际改变，我们就能跳出盲目、焦虑、浮躁的怪圈。 读一本书，不求记住多少知识。哪怕一个观点对你有益，让你因此改变，这就够了，因为你已经走出了舒适区。舒适区边缘10%的努力，也要胜过舒适区100%的努力（自我欺骗）。活在舒适区边缘，不专注表面，就会走出焦虑怪圈。怕什么真理无穷，进一步有进一步的欢喜。 找寻更好的视角 无论你当前处于何种情绪旋涡，只要自己愿意， 总能找到更好的角度。 只是有的人面对再好的事情时都盯着一点瑕疵不放， 而有的 人却能从任何一件糟糕的事情中找到闪光点并放大，忽视其他不足之处。 就像《被讨厌的勇气》所说的，要寻找更大的共同体。不要拘泥于一个共同体，不要只看到一个视角。身处逆境，有的人深陷其中不能自拔，有的人处在逆境却不自知，反而乐在其中。一辆车停在那里不动，我们可以找到一个更好的角度去拍摄它。一件事也许不能改变，但我们可以改变看待事情的态度。就像”塞翁失马，焉知非福“，”祸兮福所倚，福兮祸所伏“，”反者道之动“，这都是事物发展的规律、是哲学的智慧，不是一种自我欺骗。即使有人仍认为这是一种自我欺骗，但我们每天不都是在自我欺骗吗。人就是解释型动物，活着有意义吗，人们为了有意义，赋予了活着的意义；世界有意义吗，人们为了有意义，赋予了世界的意义。 tips “ 刻意练习四要素”：定义明确的目标、极度的专注、有效的反馈、在拉伸区练习。 时常问自己：这个道理还能用在什么地方？ 游戏心态：我不是在做这件事，我是在做另一件事。","categories":[{"name":"日常","slug":"日常","permalink":"https://youngsay.cn/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"阅读","slug":"阅读","permalink":"https://youngsay.cn/tags/%E9%98%85%E8%AF%BB/"}]},{"title":"【第三期】我爱记单词😎","slug":"word3","date":"2021-09-01T10:07:01.000Z","updated":"2021-09-09T09:18:02.631Z","comments":true,"path":"2021/09/01/word3/","link":"","permalink":"https://youngsay.cn/2021/09/01/word3/","excerpt":"","text":"9.1 craft n. 工艺，手艺；飞机；宇宙飞船；航天器；技巧；传统或人工的饮食 v. 精心制作（尤指手工） draft comply v.遵从、顺从 agree consent approve subscribe permission preserve v.保护、维持、禁猎 n.禁猎区、保护区、加工成的食品 reserve conserve retain remain severe proceed v. 开始行动；开展，（行动）进行；继续；接着做 process procession procedure clap v/n.击掌👏 collapse v. 突然失败；崩溃；倒闭；（因生病或受伤而）昏倒；（价格）突然下跌；（货币）突然贬值； n. 倒塌；突然倒闭；崩溃；瓦解 col(表加强）+lapse（滑倒）=彻底滑倒=崩溃；倒坍 slide principle n. 原理，原则；（个人行为）准则；规范；定理 hazardn. 危险，风险v. 冒失地提出，冒险猜测；冒…的风险；使处于危险 flawn. （物质或物件的）瑕疵，缺陷，毛病；（人性格中的）毛病，缺陷v. 损害；削弱；使失效 law snackn. （两餐之间的）点心，小吃v. 吃零食；吃快餐 snake neck contrastn. （明显的）差别（尤指反差）；对比，对照；对照物，对立面v. （使成）对比，（使成）对照 contract survivaln. 生存；继续存活，（尤指在困境中的）幸存；幸存事物 survive citev. 引用（文章，书本，作家）以作为论据或说明之证，引证；举例；嘉奖 quote 9.2 accidentaladj. 意外的，偶然的；非故意的 accident trialn. 考验，试验，测试；审判；（对人的忍耐、自制力的）考验，磨练 perceivev. 把（人，物）看作，认为；察觉，感觉，认知；认识到，意识到；理解perceive as 视为；当作 rebeln. 反叛分子，造反者，叛逆者，起义者v. 造反，反抗；反对；不服从，抗命rebel against v. 反抗 disguisev. 伪装；掩饰，掩盖n. 装扮，伪装 hide conceal carriern. 通讯公司；运输工具 career lodgev. 提出（投诉、抗议等）；把…嵌入；租房；暂住，借宿n. 传达室, （供参加户外运动者暂住的）乡间小屋, 门房, 管理员室 conformv. 遵守社会接受的习俗（或规范）；顺从；符合（规则，标准，法律）comply confirm thirstyadj. 渴的，口干的；渴望的 propertyn. 房地产；个人财产，资产；所有物；【律】所有权，处置权；特性，性质 proper estate revenuen. （国家）岁入，税收；（尤指公司或组织数额庞大的）收入，收益 proteinn. 【总称】（尤指作为饮食成分）蛋白质；朊 deficiencyn. 缺乏，不足；缺陷，缺点缺点 defect; disadvantage; weakness; shortcoming; thrivev. 兴旺发达，繁荣；旺盛；茁壮成长；植物茂盛生长 flourish dumpvt. 堆放，扔掉，倾倒（垃圾或废料等）；倾销 bump lumpn. 垃圾场 conquervt. 战胜，破除，克服（问题，弱点） 9.3 crewn. （船上的）全体船员；（飞机上的）全体机组人员等v. 充当船员或机务人员; 配备船员; 配备机务或乘务人员 cue clue prohibitionn. 禁止，阻止；禁令，禁律 **prohibit ban forbid ** torturen. 酷刑，拷问；折磨；痛苦，痛苦（或忧虑）的原因vt. 拷打；使痛苦；折磨 admirationn. 钦佩，赞美；欣赏，倾慕 admire easen. 安逸，悠闲；容易，不费力 easyv. 减轻，舒缓，缓解；逐渐引导某人熟悉（某活动） manufacturev. 生产，制造n. （大规模）生产，制造；制造业 factory substantialadj. 大量的；相当程度的；实质的；基本上的，大体上的；很重要的；很有价值的 considerable essential8. peern. 同辈；同龄人；同等地位的人，（才能）相匹敌的人；（英国）贵族v. 凝视，盯着看，费力地看9. delegatev. 把（任务，责任）委托（或委派、授权）给他人（尤指下属）n. 代表；会议代表10. infectiousadj. （疾病，致病生物体）传染的，有传染性的 infect11. overseasadj. 来自（或去、有关）国外的（尤指海外）；外国的；海外的adv. 在（或向）国外（尤指海外） 9.4 commercialadj. 贸易的；商业的；商务的 commercen. 电视广告；电台广告 preferencen. 喜好；偏好；更加喜爱；偏爱；偏爱的事物 promptadj. 迅速的，立刻的；敏捷的v. （事件，事实）引起，激起；促使（某人）采取行动；提示n. 鼓励，催促；提示；【计算机】提示信息；【给演员的】提词，提白 lobbyn. （尤指公共建筑入口处的）大堂，穿堂，休息室；游说团体；游说 hobbyv. （就某一问题）进行游说活动 stickyadj. 黏性的；（天气）湿热的 stick prejudicen. 偏见；歧视，反感；损害，侵害 precautionv. 使存有偏见；伤害，损害 comprisev. 组成，构成；包含 compose consist constitute episoden. （连载小说中的）一节；（广播或电视连续剧的）一集；一段经历；片段，插曲；（某疾病的）发作期 originatev. 发源；来自；发端于；创立；发明 confinev. 限制；使局限于；监禁 shedvt. 脱落，脱去；抛弃（不合意、多余或过时的东西）；取消；射出，发出（光）；（phrase. shed tears）流泪；哭n. 小屋；棚式建筑；货棚；牲口棚；工作棚 9.5 precaution n.预备、防备、警惕 pre之前的，caution谨慎，precaution 预防 execute v. 处决；执行；实施（计划，命令，行动过程）；完成 executive compromise n. 折中状态；折中（办法）；妥协 v. 妥协，让步；降低标准 establish v. 设立；建立；制定；证实；查明；确定；安置；安顿；使开业；使立足；使稳定 harmonious adj. 和睦的，一致的；和谐的 harmony harmonyos liberate vt. 解放（思想），使摆脱思想（或行为）上的束缚 preservation n. 保存；保护，维护；保养；维持 preserve calculation n. 评估；估定；估计；计算 speculate estimate appraise evaluate instruct v. 教，指导；指示；命令，吩咐 instructor graven.坟墓adj.严峻的、重大的 imposev.把…强加于、要求履行(义务)、征税 deann.教务长、系主任 penaltyn.不利后果、处罚、罚金 9.6 orbitn. 轨道，轨迹v. 绕轨道而行 noveltyn. 新奇；新奇性；与众不同；新奇的事物；新鲜事，不同寻常的经历；小装饰 competitionn. 竞赛，比赛；竞争，角逐 compete assetn. （个人或公司的）资产；（有用的或宝贵的）物品；人才 implyv. 暗示；暗指 cue hint indicate neutraladj. 中立的，中性的 virtuen. 美德；优点，长处 prospectn. （成功或发财的）机会，可能性；前途，前景 9.7 facultyn. 能力，才能；（大学系、科或学院的）全体教学（或科研）人员 crucialadj. 决定性的；关键性的；至关重要的 advertisev. 为（产品、服务或事件）做广告，宣传 integrityn. 诚实，正直；完整，完好 recruitvt. 招募（新兵），招聘，招收（员工，支持者）；吸收（新成员）n. 新兵；新成员，新支持者 alternativeadj. （一或多个事物）可选择的；可替代的；非主流的，非传统的n. 替换物; （二者或多者中）选择之一，可能性之一 assemblev. 使（人或物为共同目的）聚集；召集，调集；装配（机器或物品的）部件 appointment spann. 持续时间；一段时间；全长，距离v. （桥、拱等）横跨，跨越；持续一段时间 exceedv. （在数量或大小上）超过；超越；超出（限定）proceed insurancen. 保险；保险业 insure exposuren. 暴露；接触；曝光；日晒雨淋；经历 expose 9.8 hostileadj. 怀有敌意的；敌对的 renderv. 致使，造成；给予，提供（服务、帮助等） modestadj. 谦虚的， 谦逊的；（数量，等级，水平）适中的，适度的；有限的；朴素的 confessv. （常指因略感羞愧、窘迫而）勉强承认；忏悔 strategicadj. 对全局有重要意义的，关键的；战略（上）的 surgeryn. 外科手术；外科；诊所 moraladj. 道德（上）的；有道德的，品行端正的 virtuen. 道德；品行；伦理；道德规范 agreeableadj. 令人愉快的；惬意的 combatn. 搏斗；打仗；战斗v. 与…战斗，与…斗争；防止；减轻 bankruptadj. 破产的；一贫如洗的；缺乏…的n. 破产者v. 使破产 ancestorn. 祖宗，祖先 descendant dairyadj. 乳制品的；乳品业的n. 牛奶以及乳制品；乳品店；乳品场；乳品公司 povertyn. 贫穷，贫困 missionn. 任务；代表团；使命，天职；航天飞行 charityn. 慈善机构；慈善事业 interferev. （未经邀请或没必要）参与，涉入；插手，干涉；扰乱，干扰（过程或活动）（使不能继续或正常进行） deceivevt. （某事）使（某人）以错误印象，误导（某人）；欺骗，蒙蔽，行骗 notifyv. （正式）通报，知照，通知，告知 9.9 literacyn.识字，有读写能力；（特定领域的）能力（或知识、技能） infiniteadj. 大量的；极度的；无限的，无穷的；无边的；无法计量（或计算）的，无数的 finiten. 无限，无尽的事物 perceptionn. 观念，看法，印象；感知，感觉；察觉；感知能力；认识能力 boostvt. 推动，推进；增强n. 提高，增加；推动，激励 perceptionn. 观念，看法，印象；感知，感觉；察觉；感知能力；认识能力 relayv. 转送，转发；播放，转播；转达信息，转告（消息）n. 接力赛；接替者；中继设备 reservev. 预订（房间、座位、入场券等）；把…专门留给n. 储备，储量；储备金，准备金；储存物资；保护区 decisiveadj. 决定性的；决断的，果断的 racialadj. 人种的，种族的；民族的；种族差异引起的，与种族差异有关的 impressionn. （尤指粗浅未多思考的）印象，感想，观感 prominentadj. 显眼的，显著的；突出的，杰出的；重要的；卓越的，著名的 apparentadj. 清晰可见的，清晰明了的；明显的；表面上的","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"英语","slug":"英语","permalink":"https://youngsay.cn/tags/%E8%8B%B1%E8%AF%AD/"}]},{"title":"《你的第一本哲学书》读书分享","slug":"read-allmeans","date":"2021-08-20T12:49:01.000Z","updated":"2021-08-20T10:20:50.694Z","comments":true,"path":"2021/08/20/read-allmeans/","link":"","permalink":"https://youngsay.cn/2021/08/20/read-allmeans/","excerpt":"","text":"引言《你的第一本哲学书》是本很精简的哲学入门书，没有专业术语，没有各种学派，直接面向最基本的哲学问题。看译后记发现个有趣的事：原著书名是“What does it all mean”，译者综合考虑译为《哲学冒险》，结果出版社考虑对读者的吸引力，起名为“你的第一本哲学书”😂 我们每天都使用一些平常的概念，却从未加以反思；而哲学的主要工作就是去询问和理解这些概念。 你要探究的概念越是基础，可以帮助你的工具也就越是匮乏。 以我的能力读这本书还是很费力，作者谈及的都是一些习以为常的事情，都是在平时没有思考过而默认的概念。 自由意志假设在学习和娱乐面前，我选择了娱乐。期末考试要来了，我后悔地说道：“我本可以好好学习”。 “我本可以好好学习”这句话什么意思？在同样的时间、环境、条件下，我仍然可以选择学习。人们在外在条件一模一样的情况下，并不需要发生任何不同的事情作为前提，就能够做某些他们实际上并没有做的事情。这意味着什么呢？ 这说明在选择娱乐之前，学习仍是开放的可能性，选择学习还是娱乐是由我的自由意志决定的，不由外界决定。 不过，决定论认为我们做什么事情都是事先决定好的，永远也不可能做实际上所没有做的事。 世界上所发生的一切事情都是被自然法则所主宰的，就好像行星的运动被自然法则所主宰一样，一个行为的诸多条件正是通过这些自然法则的安排，才能够决定这个行为，并且排除掉其他一切可能性。 如果真是这样，那很可怕。当我想学习还是娱乐时，我的选择已经被决定，娱乐还是学习这一想法只不过是事先被决定的结果在我的意识中出现的过程。在我出生之前，我这一时刻选择娱乐的决定已经被决定，我的选择是直接被前一刻的情境所决定的，而前一刻的情境又是被再往前一刻的情境所决定的，这样可以无穷追溯下去。 如果真是这样，”我本可以好好学习“这句话毫无意义。这都是被决定好的。我不能责备自己没有好好学习，更不能决定罪犯，惩罚坏人便没有意义。因为一个人做了他绝不可能不做的事而去惩罚他，这是没有意义的。 如果决定论是真的，社会秩序将荡然无存，人类的一切行为也没有了意义。决定论是否正确，我们不得而知。 假设决定论是假的，”我本可以好好学习“这句话又是什么意思？你相信是你通过做出选择，决定了自己将要做什么。这一选择并非事先被决定，但是也不是自己发生的。你选择了它，并且你也能够选择别的。但是这又意味着什么？ 一些人认为，这个问题没有答案。自由行为是世界上的一种基本特性，不能够再加以分解。某件事情不需要原因而发生，和一个行为不需要原因而被人做出，二者间有着微妙的不同。 即使我们的选择并非事先已被决定，我们以何种方式能够做我们实际上所没有做的事情，仍然很难理解。两种选择在事先皆有可能，但是除非是“我”决定选其中某个，否则我仍然不需要对这种选择负责，正如如果它是被在我之外的原因所决定的，我不需要为此负责一样。如果决定论是正确的，先前的条件就该为我们的行为负责，如果决定论是错误的，就没什么东西要负责了。 …… 死亡人终会死去，我们无法想象死后的样子。 如果二元论正确，人是由身体和灵魂组成，身体和灵魂时独立的，身体死后灵魂会不会离开身体，依附一个新的身体而存在。即使二元论正确，也可能不存在死后生活，灵魂很可能完全依赖身体。 如果二元论是错的，就不存在死后生活。 我们以何种态度面对自己的死亡？如果不存在死后生活，死亡就是一了百了，我们又是什么态度？ 书中写道，必然是一种消极的善或者恶。换句话说，它是一片虚无，如果是好的，那么一定是因为它避免了某种坏事（例如无聊或痛苦），如果是坏的，也一定是因为它失去了某种好事（例如在世时有趣的或愉悦的体验）。 如果死后就是一了百了，这也许并不可怕。在我们出生之前的漫长岁月里，世界如常存在，但是却没有我们，对此我们安之若素。那么，想到我们死后就不复存在，这又有什么可怕的呢？ 人生的意义我认为，人生不论有无意义，这都毫无意义。无论有无意义，我们照样过着自己的日子。 但总有人把自己看得很重要，他希望自己的人生整体从外在看，也具有意义。 许多人活着不只是为了活下去和过得舒适，而是为了满足自己的雄心壮志，付出了种种艰辛努力，其心理动力往往就是来自于一种“重要感”。这种感觉就是：你所做的一切不只是对你来说才重要，在某种更大的意义上来说，它本身就很重要。如果我们放弃了这种重要感，我们就不再能鼓起前进的风帆。如果浮生若梦，万事无常，最终都归于尘土，那么也许我们的雄心壮志不过徒然为荒诞不经的玩笑而已。 从另一方面来说，如果我们无可救药地执着于自己的意义，或许也只能安于自身的可笑。也许生命不仅没有意义，而且也是一出荒诞剧？","categories":[{"name":"日常","slug":"日常","permalink":"https://youngsay.cn/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"阅读","slug":"阅读","permalink":"https://youngsay.cn/tags/%E9%98%85%E8%AF%BB/"}]},{"title":"《穷爸爸 富爸爸》读书分享","slug":"read-richdad","date":"2021-08-20T07:49:01.000Z","updated":"2021-08-20T07:41:44.535Z","comments":true,"path":"2021/08/20/read-richdad/","link":"","permalink":"https://youngsay.cn/2021/08/20/read-richdad/","excerpt":"","text":"前言《穷爸爸 富爸爸》是暑假读的第二本书，关于这本书也褒贬不一。取其精华，去其糟粕。关于财富，书中提到：财富就是支撑一个人生存多长时间的能力，或者说，如果我今天停止工作，我还能活多久？财富的增加不是依靠收入，而是资产的积累。头脑是真正的资产，要养成终身学习的习惯，再次引用书中一段话：轻松的道路往往会越走越艰难，而艰难的道路往往会越走越轻松。 不为钱而工作人们为了实现欲望而工作。他们认为钱能买来快乐，可用钱买来的快乐往往是短暂的，所以不久他们就需要更多的钱来买更多的快乐、更多的开心、更多的舒适和更多的安全感。于是他们继续工作，以为钱能安抚他们备受恐惧和欲望折磨的灵魂，但实际上钱是无法做到这一点的。 工作只是试图用暂时的办法来解决长期的问题。钱控制了他们的生活，确切地说是，对钱的无知和恐惧控制了他们的生活。所以他们拼命工作。他们的思想被他们的感情，而不是他们的头脑控制着。” 不为钱而工作不是说不在乎钱，不谈钱就像依赖钱一样是一种精神上的疾病。我们不能陷入为钱工作的死循环，要看到他人看不到的东西。 资产和负债 书中写道：资产是能把钱放进你口袋里的东西。负债是把钱从你口袋里取走的东西。 也就是说，资产带来收入，负债带来支出。 增加财富就是要积累资产。拼命工作增加的只是收入，将收入买入资产还是负债，抑或支出，划分了穷人、中产阶级和富人。 富人买入资产。 穷人只有支出。 中产阶级购买自以为是资产的负债。 一个受过高等教育的人，也可能是财务上的文盲。他们努力工作，却不知道如何让钱为自己工作，甚至不知道他们真正的问题在于他们选择的消费方式，那才是他们在财务困境中苦苦挣扎的原因。 书中有这样一段话： 日本人注重3种力量：剑、宝石和镜子。 剑象征着武器的力量。美国人在武器上已经花了上千亿美元，是世界上的超级军事大国。 宝石象征着金钱的力量。有句格言很有道理：“记住黄金规则：有黄金的人制定规则。” 镜子象征着自知的力量。从日本的传奇故事中我们得知，自知是3种力量中最宝贵的。 穷人和资产阶级往往被金钱控制着，却不相信自知的力量。人们总是不相信自己内在的智慧，只会随波逐流，人云亦云。他们做事情只是因为其他人也这么做，他们总是服从而不去提问。他们总是轻率地重复别人告诉他们的东西，例如：“分期付款”、“你的房子就是你的资产”、“你的房子是你最大的投资”、“欠债可以抵税”、“找一个稳定的工作”、“别犯错误”、“别冒险”之类的话。他们害怕与别人不同。大多数人热衷于“稳定”是出于恐惧。 学校的教育也是一样，学校教育我们就像企业的流水线产品，被要求循规蹈矩，所以说学校是生产好雇员而不是好雇主的地方。 关注自己的事业什么是自己的事业，你的事业不是你的工作，如果你把工作当成事业，便会耗尽一生去关注别人的事业并使他人致富。你事业的重心是你的资产项，而不是收入项。夫人关心的是资产而其他人关心的是收入。 麦当劳的创始人雷·克罗克说，我的事业不是做汉堡🍔，而是房地产。在他的商业计划中，麦当劳的大额收入来源是出售分店所得的费用。 教育比金钱更有价值书中有个有意思的观点，job=just over broke，工作一次就是比破产强一点。工人付出最大努力以免于被解雇，而雇主提供最低工资以防止工人辞职。即使这样，也没人敢不满，他们只想找一份稳定的工作，大部分人都是为了短期的工资和福利工作。你越努力工作，老板也就越富有。 相反，工作是为了能力的提升，要弄清自己想要获得什么技能，不要为钱而工作。从长远看，教育比金钱更有价值。 克服困难掌握财务知识的人却不能积累丰厚的资产项，其主要原因书中列举了5个，这里举出两个。 恐惧心理 投资有风险，没有人会一直成功。要克服恐惧心理，正视失败。对于胜利者，失败会激励他们；对于失败者，失败则会击垮他们。他们在财务上不成功是因为对他们而言亏钱所造成的痛苦远远大于致富所带来的乐趣。 愤世嫉俗 书中谈到小鸡的故事，“天要塌下来了，天要塌下来了”，小鸡总是围着谷仓转，警告大家即将到来的厄运。我们知道有的人也爱这么做，其实我们每个人的心里也都有一只“小鸡”。愤世嫉俗的人就像“小鸡”一样，每当心里害怕、怀疑的时候，他们就会像“小鸡”一样杞人忧天。愤世者抱怨现实，而成功者分析现实。我们需要极大的勇气，不让谣言和杞人忧天的怀疑加剧我们的恐惧和疑虑。","categories":[{"name":"日常","slug":"日常","permalink":"https://youngsay.cn/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"阅读","slug":"阅读","permalink":"https://youngsay.cn/tags/%E9%98%85%E8%AF%BB/"}]},{"title":"《被讨厌的勇气》读书分享","slug":"read-courage","date":"2021-08-20T03:49:01.000Z","updated":"2021-08-20T07:36:54.446Z","comments":true,"path":"2021/08/20/read-courage/","link":"","permalink":"https://youngsay.cn/2021/08/20/read-courage/","excerpt":"","text":"『因为拥有了被讨厌的勇气，于是有了真正幸福的可能』 前言暑假快结束了，想为假期读过几本书写几篇读书笔记。暑假读的第一本书是《被讨厌的勇气》，书中有很多启发我的观点。其中之一是自卑和自卑情结，这我在之前谈到过；还有一个是对人生的描述，人生是点状的，是每一个刹那，不是一条线、一个整体。书中还有个有趣的比喻：当你站在舞台上，聚光灯打向你，你什么也看不见。当聚光灯打向“此时此刻”，也就看不到过去和将来。书中很难理解和践行的是共同体的概念，要做到自我接纳、他者信任和他者贡献。用了一上午时间，略读了一遍，不知不觉写了3000字。 像《理想国》一样，这本书由现代不常用的对话体写就，通过哲人和青年五夜的对话，向我们阐释了阿德勒心理学。 不幸来源弗洛伊德的原因论认为，过去决定了现在的我们，现在的不幸、行为都能在过去找到原因，如果是这样，我们将没有能力改变现状，我们将是无力、痛苦的。阿德勒心理学否认了弗洛伊德的原因论，他认为过去并不重要，重要的是我们赋予过去的意义。你的不幸、痛苦不是因为过去，而是因为你的选择。 「你在人生的某个阶段里选择了“不幸”。这既不是因为你生在了不幸的环境中，也不是因为你陷入了不幸的境地中，而是因为你认为“不幸”对你自身而言是一种“善”。」 就像“弱者”常常利用自己的弱者优势，站在道德制高点。阿德勒指出：“在我们的文化中，弱势其实非常强大而且具有特权。”就像田园女👊一样，义务和责任避而不谈，大搞“按闹分配”，我不行，我不做，你要为我做，你要为我担责。而女权主义是我能行，我要做，我去做，我担责，我争取权益，我实现自我。 「阿德勒的目的论是说：“无论之前的人生发生过什么，都对今后的人生如何度过没有影响。”决定自己人生的是活在“此时此刻”的你自己。」 人际关系「之所以感觉孤独并不是因为只有你自己一个人，感觉自己被周围的他人、社会和共同体所疏远才会孤独。我们要想体会孤独也需要有他人的存在。也就是说，人只有在社会关系中才会成为“个人”。」 就像孤独是个群体概念，有了他人的存在，才有孤独的存在。阿德勒提出，人的烦恼皆源于人际关系。如果宇宙中没有他人只有自己，那么一切烦恼将会消失。这和后面提到的共同体并不冲突。我们过分在意他人的看法，甚至有些人是在为他人而活，觉得自己的一举一动都会被别人关注。事实上，在意你的，只有你自己。 阿德勒心理学是勇气心理学，也是“使用的心理学”。提出人的烦恼皆源于人际关系，是让你不过分在乎他人的看法，为自己而活。 课题分离「首先要思考一下“这是谁的课题”。然后进行课题分离——哪些是自己的课题，哪些是别人的课题，要冷静地划清界限。而且，不去干涉别人的课题也不让别人干涉自己的课题。」 孩子的学习是自己的课题，家长可以为孩子营造好的学习环境、提供力所能及的帮助，而不应该干涉他的学习，毕竟这是他的课题。很多人活得很累、烦恼很多，就是因为不会课题分离。 他人对你的看法、对你的期待这不是由你决定的，这不是你的课题。自由就是不寻求认可，不活在他人的期待中。倘若自己都不为自己活出自己的人生，那还有谁会为自己而活呢？ 共同体「不幸之源也在于人际关系。反过来说，幸福之源也在于人际关系。共同体感觉是幸福的人际关系的最重要的指标。」 我们都处在共同体之中，共同体不仅包括家庭、学校、城市，还包括国家、人类、过去、未来……只要有两个人，就可以构成共同体。我们把每个人都当作伙伴，我们生活在伙伴之中，我们能够从中找到自己的位置，这就是共同体的感觉。把对自己的执著（self interest）变成对他人的关心（social interest）。 对自己的执着，就是以自己为中心。那些过分在意他人看法的人，在意他人如何关注、评价自己，是在满足自己的欲求，看似迎合他人，实际上眼里只有自己。 「无论是你还是我，我们都不是世界的中心，必须用自己的脚主动迈出一步去面对人际关系课题；不是考虑“这个人会给我什么”，而是要必须思考一下“我能给这个人什么”。这就是对共同体的参与和融入。」 我们要在更广阔的天地寻找自己的位置。如果一个人只看到家庭、学校这个共同体，那么在学校受欺负、交不到朋友或者学习不好的人就无法在这里产生归属感，然后逃到家庭这个更小的共同体，就会躲在家里不愿出去，产生心理问题。 除了家庭、学校，还有更大的共同体，在家庭、学校之外，还有更广阔的世界，我们可以在更大的共同体中找到归属感。当你在家庭、学校感到身陷囹圄，只要发现世界之大，就会明白这只不过是“杯中风暴”。跳出被子，再猛烈的风也会变成微风。 「当我们在人际关系中遇到困难或者看不到出口的时候，首先应该考虑的是“倾听更大共同体的声音”这一原则。」 人生和谐如何建立共同体感觉，在共同体中获得归属感，要做到：“自我接纳”“他者信赖”和“他者贡献”。 要分清“能够改变的”和“不能改变的”。我们无法改变“被给予了什么”。但是，关于“如何去利用被给予的东西”，我们却可以用自己的力量去改变。这就是不去关注“无法改变的”，而是去关注“可以改变的”。这就是自我接纳。 你现在一味地担心“被背叛”，也只关注因此受到的伤痛。但是，如果不敢去信赖别人，那最终就会与任何人都建立不了深厚的关系。正如前面的功课分离，被背叛是他人的课题，而信赖他人是自己的课题。我们可以相信也可以怀疑；并且，我们的目标是把别人当作朋友。如此一来，是该选择信任还是怀疑，答案就非常明显了。 工作的本质是对他人的贡献。劳动不是赚钱的手段，而是实现他者贡献的途径。通过劳动，参与共同体，获得自己的存在价值。很多富豪们已经有了一生都花不完的财富，但还在忙碌工作着，是因为无穷的欲望吗？是因为他者贡献来实现自我价值，获得归属感。 「正因为接受了真实的自我——也就是“自我接纳”——才能够不惧背叛地做到“他者信赖”；而且，正因为对他人给予无条件的信赖并能够视他人为自己的伙伴，才能够做到“他者贡献”；同时，正因为对他人有所贡献，才能够体会到“我对他人有用”进而接受真实的自己，做到“自我接纳”。」 我们惯用大家、一切、总是这类的词语，“大家都讨厌我”这个大家其实就是几个人。犹太教教义中有这么一段话：“假如有10个人，其中势必会有1个人无论遇到什么事都会批判你。他讨厌你，你也不喜欢他。而且，10个人中也会有2个人能够成为与你互相接纳一切的好朋友。剩下的7个人则两者都不是。” 这种时候，是应该关注讨厌你的1个人还是喜欢你的2个人，或是大多数的7个人呢？当你因为某件事或某个缺点被别人讨厌或笑话，但笑话你的只是少数人，而你因为少数人就判断了所有人。真正的问题在于无法做到自我接纳、他者信赖和他者贡献，却将焦点聚集到微不足道的一个方面并企图以此来评价整个世界。这就是缺乏人生和谐的错误生活方式。 此时此刻请你想象一下自己站在剧场舞台上的样子。此时，如果整个会场都开着灯，那就可以看到观众席的最里边。但是，如果强烈的聚光灯打向自己，那就连最前排也看不见。我们的人生也完全一样。正因为把模糊而微弱的光打向人生整体，所以才能够看到过去和未来；不，是感觉能够看得到。但是，如果把强烈的聚光灯对准“此时此刻”，那就会既看不到过去也看不到未来。 我们应该更加认真地过好“此时此刻”。如果感觉能够看得到过去也能预测到未来，那就证明你没有认真地活在“此时此刻”，而是生活在模糊而微弱的光中。人生是连续的刹那，根本不存在过去和未来。你是想要通过关注过去或未来为自己寻找免罪符。过去发生了什么与你的“此时此刻”没有任何关系，未来会如何也不是“此时此刻”要考虑的问题。假如认真地活在“此时此刻”，那就根本不会说出那样的话。 人生中最大的谎言就是不活在“此时此刻”。纠结过去、关注未来，把微弱而模糊的光打向人生整体，自认为看到了些什么。你之前就一直忽略“此时此刻”，只关注根本不存在的过去和未来。对自己的人生和无可替代的刹那撒了一个大大的谎言。 世界很简单，人生也一样！","categories":[{"name":"日常","slug":"日常","permalink":"https://youngsay.cn/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"阅读","slug":"阅读","permalink":"https://youngsay.cn/tags/%E9%98%85%E8%AF%BB/"}]},{"title":"WebApiⅠ：操作元素","slug":"WebApi1","date":"2021-08-19T12:45:54.000Z","updated":"2021-08-19T00:28:54.782Z","comments":true,"path":"2021/08/19/WebApi1/","link":"","permalink":"https://youngsay.cn/2021/08/19/WebApi1/","excerpt":"","text":"1.1. Web API介绍1.1.1 API的概念API（Application Programming Interface，应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，无需理解其内部工作机制细节，只需直接调用使用即可。 1.1.2 Web API的概念​ Web API 是浏览器提供的一套操作浏览器功能和页面元素的 API ( BOM 和 DOM )。 ​ MDN 详细 API : https://developer.mozilla.org/zh-CN/docs/Web/API ​ 因为 Web API 很多，所以我们将这个阶段称为 Web APIs。 ​ 此处的 Web API 特指浏览器提供的一系列API(很多函数或对象方法)，即操作网页的一系列工具。例如：操作html标签、操作页面地址的方法。 1.1.3 API 和 Web API 总结 API 是为我们程序员提供的一个接口，帮助我们实现某种功能，我们会使用就可以了，不必纠结内部如何实现 Web API 主要是针对于浏览器提供的接口，主要针对于浏览器做交互效果。 Web API 一般都有输入和输出（函数的传参和返回值），Web API 很多都是方法（函数） 学习 Web API 可以结合前面学习内置对象方法的思路学习 1.2. DOM 介绍1.2.1 什么是DOM​ 文档对象模型（Document Object Model，简称DOM），是 W3C组织推荐的处理可扩展标记语言的标准编程接口 ​ W3C 已经定义了一系列的 DOM 接口，通过这些 DOM 接口可以改变网页的内容、结构和样式。 ​ DOM是W3C组织制定的一套处理 html和xml文档的规范，所有的浏览器都遵循了这套标准。 1.2.2. DOM树 DOM树 又称为文档树模型，把文档映射成树形结构，通过节点对象对其处理，处理的结果可以加入到当前的页面。 文档：一个页面就是一个文档，DOM中使用document表示 节点：网页中的所有内容，在文档树中都是节点（标签、属性、文本、注释等），使用node表示 标签节点：网页中的所有标签，通常称为元素节点，又简称为“元素”，使用element表示 DOM把以上内容都看作是对象。 1.3. 获取元素为什么要获取页面元素？ 例如：我们想要操作页面上的某部分(显示/隐藏，动画)，需要先获取到该部分对应的元素，再对其进行操作。 1.3.1. 根据ID获取1语法：document.getElementById(id) 作用：根据ID获取元素对象参数：id值，区分大小写的字符串返回值：元素对象 或 null 案例代码 1234567891011&lt;body&gt; &lt;div id=&quot;news&quot;&gt;2021-8-16:吴亦凡被批捕&lt;/div&gt; &lt;script&gt; // 因为我们文档页面从上往下加载，所以先得有标签 所以我们script写到标签的下面 var new = document.getElementById(&#x27;news&#x27;); console.log(news); console.log(typeof new); // console.dir 打印我们返回的元素对象 更好的查看里面的属性和方法 console.dir(new); &lt;/script&gt;&lt;/body&gt; 1.3.2. 根据标签名获取元素1语法：document.getElementsByTagName(&#x27;标签名&#x27;) 或者 element.getElementsByTagName(&#x27;标签名&#x27;) 作用：根据标签名获取元素对象参数：标签名返回值：伪数组 案例代码 123456789101112131415161718192021222324&lt;ul&gt; &lt;li&gt;炼金术士&lt;/li&gt; &lt;li&gt;牧羊少年的奇幻之旅&lt;/li&gt; &lt;li&gt;The Alchemist&lt;/li&gt;&lt;/ul&gt;&lt;ul id=&quot;nav&quot;&gt; &lt;li&gt;小王子&lt;/li&gt; &lt;li&gt;追风筝的人&lt;/li&gt; &lt;li&gt;月亮与六便士&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; // 1.返回的是 获取过来元素对象的集合 以伪数组的形式存储的 var lis = document.getElementsByTagName(&#x27;li&#x27;); console.log(lis); console.log(lis[1]); // 2. 我们想要依次打印里面的元素对象我们可以采取遍历的方式 for (var i = 0; i &lt; lis.length; i++) &#123; console.log(lis[i]); &#125; // 3. element.getElementsByTagName() 可以得到这个元素里面的某些标签 var nav = document.getElementById(&#x27;nav&#x27;); //获得nav元素 var navLis = nav.getElementsByTagName(&#x27;li&#x27;); console.log(navLis);&lt;/script&gt; 因为得到的是一个对象的集合，所以我们想要操作里面的元素就需要遍历。 getElementsByTagName()获取到是动态集合，即：当页面增加了标签，这个集合中也就增加了元素。 1.3.3. H5新增获取元素 代码 说明 备注 document.getElementsByClassName (‘类名’) 根据类名获得某些元素集合 document.querySelector(‘选择器’) 根据指定选择器返回第一个元素对象 加符号 ‘#nav’ document.querySelectorAll(‘选择器’) 根据指定选择器返回所有元素对象 加符号 ‘#nav’ 案例代码 123456789101112131415161718192021222324252627&lt;body&gt; &lt;div class=&quot;box&quot;&gt;盒子1&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;盒子2&lt;/div&gt; &lt;div id=&quot;nav&quot;&gt; &lt;ul&gt; &lt;li&gt;首页&lt;/li&gt; &lt;li&gt;产品&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; // 1. getElementsByClassName 根据类名获得某些元素集合 var boxs = document.getElementsByClassName(&#x27;box&#x27;); console.log(boxs); // 2. querySelector 返回指定选择器的第一个元素对象 切记 里面的选择器需要加符号 .box #nav var firstBox = document.querySelector(&#x27;.box&#x27;); console.log(firstBox); var nav = document.querySelector(&#x27;#nav&#x27;); console.log(nav); var li = document.querySelector(&#x27;li&#x27;); console.log(li); // 3. querySelectorAll()返回指定选择器的所有元素对象集合 var allBox = document.querySelectorAll(&#x27;.box&#x27;); console.log(allBox); var lis = document.querySelectorAll(&#x27;li&#x27;); console.log(lis); &lt;/script&gt;&lt;/body&gt; 1.3.4 获取特殊元素 获取body元素 获取html元素 document.body document.documentElement 1.4. 事件基础1.4.1. 事件概述JavaScript 使我们有能力创建动态页面，而事件是可以被 JavaScript 侦测到的行为。 简单理解： 触发— 响应机制。 ​ 网页中的每个元素都可以产生某些可以触发 JavaScript 的事件，例如，我们可以在用户点击某按钮时产生一个 事件，然后去执行某些操作。 1.4.2. 事件三要素 事件源（谁）：触发事件的元素 事件类型（什么事件）： 例如 click 点击事件 事件处理程序（做啥）：事件触发后要执行的代码(函数形式)，事件处理函数 案例代码 12345678910111213body&gt; &lt;button id=&quot;btn&quot;&gt;点我点我&lt;/button&gt; &lt;script&gt; // 点击一个按钮，弹出对话框 // 1. 事件三要素：事件源 事件类型 事件处理程序 //(1) 事件源 事件被触发的对象 谁 按钮 var btn = document.getElementById(&#x27;btn&#x27;); //(2) 事件类型 如何触发 什么事件 比如鼠标点击(onclick) 还是鼠标经过 还是键盘按下 //(3) 事件处理程序 通过一个函数赋值的方式 完成 btn.onclick = function() &#123; alert(&#x27;谁让你点我的&#x27;); &#125; &lt;/script&gt; 1.4.3. 执行事件的步骤 获取事件源 注册事件（绑定事件） 添加事件处理程序（采取函数赋值形式） 案例代码 123456789101112131415&lt;body&gt; &lt;div&gt;123&lt;/div&gt; &lt;script&gt; // 执行事件步骤 // 点击div 控制台输出 我被选中了 // 1. 获取事件源 var div = document.querySelector(&#x27;div&#x27;); // 2.绑定事件 注册事件 // div.onclick // 3.添加事件处理程序 div.onclick = function() &#123; console.log(&#x27;我被选中了&#x27;); &#125; &lt;/script&gt;&lt;/body&gt; 1.4.4. 常见的鼠标事件 鼠标事件 触发事件 onclick 鼠标点击左键触发 onmouseover 鼠标经过触发 onmouseout 鼠标离开触发 onfocus 获得鼠标焦点触发 onblur 失去鼠标焦点触发 onmouseup 鼠标弹起触发 onmousedown 鼠标按下触发 1.5. 操作元素​ JavaScript的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内容、属性等。（注意：这些操作都是通过元素对象的属性实现的） 1.5.1. 改变元素内容（获取或设置） innerText改变元素内容 12345678910111213141516171819202122232425&lt;body&gt; &lt;button&gt;显示当前系统时间&lt;/button&gt; &lt;div&gt;某个时间&lt;/div&gt; &lt;p&gt;1123&lt;/p&gt; &lt;script&gt; // 当我们点击了按钮， div里面的文字会发生变化 // 1. 获取元素 var btn = document.querySelector(&#x27;button&#x27;); var div = document.querySelector(&#x27;div&#x27;); // 2.注册事件 btn.onclick = function() &#123; // div.innerText = &#x27;2021-8-17&#x27;; div.innerHTML = getDate(); &#125; function getDate() &#123; var date = new Date(); var year = date.getFullYear(); var month = date.getMonth() + 1; var dates = date.getDate(); var arr = [&#x27;星期日&#x27;, &#x27;星期一&#x27;, &#x27;星期二&#x27;, &#x27;星期三&#x27;, &#x27;星期四&#x27;, &#x27;星期五&#x27;, &#x27;星期六&#x27;]; var day = date.getDay(); return &#x27;今天是：&#x27; + year + &#x27;年&#x27; + month + &#x27;月&#x27; + dates + &#x27;日 &#x27; + arr[day]; &#125; &lt;/script&gt;&lt;/body&gt; innerText和innerHTML的区别 获取内容时的区别： ​ innerText会去除空格和换行，而innerHTML会保留空格和换行 设置内容时的区别： ​ innerText不会识别html，而innerHTML会识别 案例代码 12345678910111213141516171819&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;p&gt; 我是文字 &lt;span&gt;123&lt;/span&gt; &lt;/p&gt; &lt;script&gt; // innerText 和 innerHTML的区别 // 1. innerText 不识别html标签 非标准 去除空格和换行 var div = document.querySelector(&#x27;div&#x27;); // div.innerText = &#x27;&lt;strong&gt;今天是：&lt;/strong&gt; 2019&#x27;; // 2. innerHTML 识别html标签 W3C标准 保留空格和换行的 div.innerHTML = &#x27;&lt;strong&gt;今天是：&lt;/strong&gt; 2019&#x27;; // 这两个属性是可读写的 可以获取元素里面的内容 var p = document.querySelector(&#x27;p&#x27;); console.log(p.innerText); console.log(p.innerHTML); &lt;/script&gt;&lt;/body&gt; 1.5.2. 常用元素的属性操作 innerText、innerHTML 改变元素内容 src、href id、alt、title 1元素对象.属性名 = 修改的内容 案例代码 123456789101112131415161718192021&lt;body&gt; &lt;button id=&quot;ldh&quot;&gt;刘德华&lt;/button&gt; &lt;button id=&quot;zxy&quot;&gt;张学友&lt;/button&gt; &lt;br&gt; &lt;img src=&quot;images/ldh.jpg&quot; alt=&quot;&quot; title=&quot;刘德华&quot;&gt; &lt;script&gt; // 修改元素属性 src // 1. 获取元素 var ldh = document.getElementById(&#x27;ldh&#x27;); var zxy = document.getElementById(&#x27;zxy&#x27;); var img = document.querySelector(&#x27;img&#x27;); // 2. 注册事件 处理程序 zxy.onclick = function() &#123; img.src = &#x27;images/zxy.jpg&#x27;; img.title = &#x27;张学友&#x27;; &#125; ldh.onclick = function() &#123; img.src = &#x27;images/ldh.jpg&#x27;; img.title = &#x27;刘德华&#x27;; &#125; &lt;/script&gt;&lt;/body&gt; 1.5.3. 表单元素的属性操作 获取属性的值 元素对象.属性名 设置属性的值 元素对象.属性名 = 值 表单元素中有一些属性如：disabled、checked、selected，元素对象的这些属性的值是布尔型。 案例代码 123456789101112131415161718&lt;body&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;input type=&quot;text&quot; value=&quot;输入内容&quot;&gt; &lt;script&gt; // 1. 获取元素 var btn = document.querySelector(&#x27;button&#x27;); var input = document.querySelector(&#x27;input&#x27;); // 2. 注册事件 处理程序 btn.onclick = function() &#123; // 表单里面的值 文字内容是通过 value 来修改的 input.value = &#x27;被点击了&#x27;; // 如果想要某个表单被禁用 不能再点击 disabled 我们想要这个按钮 button禁用 // btn.disabled = true; this.disabled = true; // this 指向的是事件函数的调用者 btn &#125; &lt;/script&gt;&lt;/body&gt; 1.5.4. 样式属性操作我们可以通过 JS 修改元素的大小、颜色、位置等样式。 常用方式 element.style 行内样式操作 element.className 类名样式操作 方式1：通过操作style属性 元素对象的style属性也是一个对象！ 元素对象.style.样式属性 = 值; 注意： JS里面的样式采取驼峰命名法，如：fontSize、backgroundColor JS修改style样式操作，产生的是行内样式，css权重比较高 案例代码 12345678910111213&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; // 1. 获取元素 var div = document.querySelector(&#x27;div&#x27;); // 2. 注册事件 处理程序 div.onclick = function() &#123; // div.style里面的属性 采取驼峰命名法 this.style.backgroundColor = &#x27;purple&#x27;; this.style.width = &#x27;250px&#x27;; &#125; &lt;/script&gt;&lt;/body&gt; 方式2：通过操作className属性 元素对象.className = 值; 因为class是关键字，所有使用className。 案例代码 123456789101112131415161718&lt;body&gt; &lt;div class=&quot;first&quot;&gt;文本&lt;/div&gt; &lt;script&gt; // 1. 使用 element.style 获得修改元素样式 如果样式比较少 或者 功能简单的情况下使用 var test = document.querySelector(&#x27;div&#x27;); test.onclick = function() &#123; // this.style.backgroundColor = &#x27;purple&#x27;; // this.style.color = &#x27;#fff&#x27;; // this.style.fontSize = &#x27;25px&#x27;; // this.style.marginTop = &#x27;100px&#x27;; // 2. 我们可以通过 修改元素的className更改元素的样式 适合于样式较多或者功能复杂的情况 // 3. 如果想要保留原先的类名，我们可以这么做 多类名选择器 // this.className = &#x27;change&#x27;; this.className = &#x27;first change&#x27;; &#125; &lt;/script&gt;&lt;/body&gt; 1.6. 总结","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://youngsay.cn/tags/JavaScript/"}]},{"title":"【第二期】我爱记单词🙄","slug":"work2","date":"2021-08-18T13:07:01.000Z","updated":"2021-09-01T10:39:13.390Z","comments":true,"path":"2021/08/18/work2/","link":"","permalink":"https://youngsay.cn/2021/08/18/work2/","excerpt":"","text":"8.18 # 单词 音标 解释 1 evolve 英:/ɪ’vɒlv/ 美:/ɪ’vɑlv/ vt. &amp; vi. 演变; 进化时 态: evolved, evolving, evolves 形容词: evolvable 名 词: evolvement 2 promote 英:/prə’məʊt/ 美:/prə’mot/ vt. 提升, 提拔筹划, 发起, 创立推销〈正〉促进; 推动; 增进时 态: promoted, promoting, promotes 3 novelty 英:/‘nɒv(ə)ltɪ/ 美:/‘nɑvlti/ n. 新颖; 新奇性新奇的人[事物]新颖小巧而价廉的物品 4 frame 英:/freɪm/ 美:/frem/ n. 框架；结构；画面vt. 设计；陷害；建造；使…适合vi. 有成功希望adj. 有木架的；有构架的时 态: framed, framing, frames 5 embrace 英:/ɪm’breɪs/ 美:/ɪm’bres/ em 进入…之中；包围 + brace 胳膊 → 被胳膊包围 → 拥抱 vt. &amp; vi. 拥抱vt. 包括; 包含接受信奉, 皈依n. 拥抱, 怀抱时 态: embraced, embracing, embraces 形容词: embraceable 名 词: embracement 6 consent 英:/kən’sent/ 美:/kən’sɛnt/ n. 准许, 同意, 赞成vi. 同意; 赞成时 态: consented, consenting, consents 名 词: consenter 7 radical 英:/‘rædɪk(ə)l/ 美:/‘rædɪkl/ adj. 根本的, 基本的; 彻底的, 完全的激进的, 激进派的副 词: radically 名 词: radicalness 8 restrain 英:/rɪ’streɪn/ 美:/rɪ’stren/ vt. 抑制, 遏制; 管制, 克制, 约束时 态: restrained, restraining, restrains 形容词: restrainable 副 词: restrainedly 名 词: restrainer 9 herd 英:/hɜːd/ 美:/hɝd/ n. 兽群，畜群；放牧人vi. 成群，聚在一起vt. 放牧；使成群时 态: herded, herding, herds 10 satellite 英:/‘sætəlaɪt/ 美:/‘sætəlaɪt/ n. 卫星人造卫星卫星国, 附庸国, 卫星都市 11 steer 英:/stɪə/ 美:/stɪr/ vt. &amp; vi. 驾驶, 掌舵时 态: steered, steering, steers 形容词: steerable 名 词: steerer 12 wit 英:/wɪt/ 美:/wɪt/ n. 智力；才智；智慧时 态: wist witting first and third person singular present tense wot 13 liable 英:/‘laɪəb(ə)l/ 美:/‘laɪəbl/ adj. 有法律责任的, 有义务的易患…的, 易受…之害的有做某事的倾向 14 rational 英:/‘ræʃ(ə)n(ə)l/ 美:/‘ræʃnəl/ adj. 理性的；合理的n. 有理数副 词: rationally 15 blend 英:/blend/ 美:/blɛnd/ vt. &amp; vi. (使)混合, (使)混杂n. 混合物时 态: blended, blent blending, blends 8.19 # 单词 音标 解释 1 myth 英:/mɪθ/ 美:/mɪθ/ n. 神话；虚构的人，虚构的事 2 heal 英:/hiːl/ 美:/hil/ vt. 治愈，痊愈；和解vi. 痊愈时 态: healed, healing, heals 形容词: healable 3 interior 英:/ɪn’tɪɜːrɪə/ 美:/ɪn’tɪrɪɚ/ n. 内部内地adj. 内部的内地的, 国内的名 词: interiority 副 词: interiorly 4 resort 英:/rɪ’zɔːt/ 美:/rɪ’zɔrt/ n. 凭借，手段；常去之地；度假胜地vi. 求助，诉诸；采取某手段或方法；常去时 态: resorted, resorting, resorts 5 nursery 英:/‘nɜːs(ə)rɪ/ 美:/‘nɝsəri/ n. 托儿所；苗圃；温床 6 elevator 英:/‘elɪveɪtə/ 美:/‘ɛlɪvetɚ/ n. 电梯；升降舵；升降机；起卸机 7 polar 英:/‘pəʊlə/ 美:/‘polɚ/ adj. 极地的；两极的；正好相反的n. [数]极面；极线 8 verify 英:/‘verɪfaɪ/ 美:/‘vɛrɪfaɪ/ vt. 核实；查证时 态: verified verifying, verifies 名 词: verifier 9 reckon 英:/‘rek(ə)n/ 美:/‘rɛkən/ vt. 猜想; 估计〈非正〉思忖; 设想考虑; 认为〈正〉计算时 态: reckoned, reckoning, reckons 10 inhabitant 英:/ɪn’hæbɪt(ə)nt/ 美:/ɪn’hæbɪtənt/ n. 居民, 住户; (栖息在某地区的)动物 11 specific 英:/spə’sɪfɪk/ 美:/spə’sɪfɪk/ adj. 特殊的，特定的；明确的；详细的；具有特效的n. 特效药；细节；特性副 词: specifically 名 词: specificity 12 convert 英:/kən’vɜːt/ 美:/kən’vɝt/ vt. &amp; vi. (使)转变, (使)转化皈依, 改变(信仰)时 态: converted, converting, converts 13 utility 英:/juː’tɪlɪtɪ/ 美:/ju’tɪləti/ n. 功用, 效用公用事业 14 deliberate 英:/dɪ’lɪb(ə)rət/ 美:/dɪ’lɪbərət/ adj. 故意的, 蓄意的慎重的, 深思熟虑的不慌不忙的, 从容不迫的vt. &amp; vi. 仔细考虑研讨, 商讨时 态: deliberated, deliberating, deliberates 副 词: deliberately 15 emphasis 英:/‘emfəsɪs/ 美:/‘ɛmfəsɪs/ n. 强调, 重点 16 vehicle 英:/‘viːɪk(ə)l/ 美:/‘viəkl/ n. 交通工具, 车辆传播媒介, 手段 17 mechanics 英:/mɪ’kænɪks/ 美:/mə’kænɪks/ n. 力学;机械学机件;过程;方法 18 ware 英:/weə/ 美:/wɛr/ n. 器具；货物；制品；陶器，器皿vt. 留心；小心时 态: wared, waring, wares 19 justify 英:/‘dʒʌstɪfaɪ/ 美:/‘dʒʌstə’fai/ vt. 证明…有理; 为…辩护时 态: justified, justifying, justifies 8.21 # 单词 音标 解释 1 overwhelm 英:/əʊvə’welm/ 美:/ˌovɚ’wɛlm/ vt. 覆盖, 淹没压倒, 制服; 打败使某人不知所措 时态: overwhelmed, overwhelming, overwhelms 2 readily 英:/‘redɪlɪ/ 美:/‘rɛdɪli/ adv. 容易地；乐意地；无困难地 3 trace 英:/treɪs/ 美:/tres/ vi. 追溯；沿路走vt. 追踪，查探；描绘；回溯n. 痕迹，踪迹；微量；迹线；缰绳 时态: traced, tracing, traces 形容词: traceable 4 exhaust 英:/ɪg’zɔːst/ 美:/ɪɡ’zɔst/ vt. 弄空, 取出用尽, 耗尽使非常疲倦vi. 排气n. 排气装置, 排气管[孔]机器排出的废气时 态: exhausted, exhausting, exhausts 名 词: exhauster 名 词: exhaustibility 形容词: exhaustible 5 critic 英:/‘krɪtɪk/ 美:/‘krɪtɪk/ n. 批评家，评论家；爱挑剔的人 6 vigorous 英:/‘vɪg(ə)rəs/ 美:/‘vɪɡərəs/ adj. 有力的；精力充沛的副 词: vigorously 名 词: vigorousness 7 contract 英:/‘kɒntrækt/ 美:/‘kɑntrækt/ vi. 感染；订约；收缩vt. 感染；订约；使缩短n. 合同；婚约时 态: contracted, contracting, contracts 形容词: contractible contrast对比 8 consult 英:/kən’sʌlt/ 美:/kən’sʌlt/ vt. 商量；查阅；向…请教vi. 请教；商议；当顾问时 态: consulted, consulting, consults 名 词: consulter **counsel consultant ** 9 tuition 英:/tjuː’ɪʃ(ə)n/ 美:/tʊ’ɪʃən/ n. 学费课程讲授 10 violent 英:/‘vaɪəl(ə)nt/ 美:/‘vaɪələnt/ adj. 暴力引起的, 粗暴的剧烈的, 强烈的副 词: violently violate 11 harsh 英:/hɑːʃ/ 美:/hɑrʃ/ adj. 粗糙的；刺耳的；严厉的；严酷的；刺目的比较级: harsher, harshest 副 词: harshly 名 词: harshness stale难闻的 12 recreation 英:/ˌrekrɪ’eɪʃ(ə)n/ 美:/ˌrɛkrɪ’eʃən/ n. 娱乐(方式); 消遣(方式) 13 torture 英:/‘tɔːtʃə/ 美:/‘tɔrtʃɚ/ tort(扭曲）+ure(行为，状态）→使人扭曲了行为或状态→折磨，痛苦 vt. 折磨；拷问；歪曲n. 拷问；折磨；歪曲时 态: tortured, torturing, tortures 名 词: torturer 14 mechanism 英:/‘mek(ə)nɪz(ə)m/ 美:/‘mɛkənɪzəm/ n. 机械装置构造, 机制办法, 技巧, 途径 mechanics n.技巧 15 preliminary 英:/prɪ’lɪmɪn(ə)rɪ/ 美:/prɪ’lɪmɪnɛri/ adj. 初步的, 预备的, 开端的n. 准备工作, 初步行动 16 pedestrian 英:/pɪ’destrɪən/ 美:/pə’dɛstrɪən/ pede脚步 str(eet) 街道 ian人 n. 步行者 名词: pedestrianism 17 drift 英:/drɪft/ 美:/drɪft/ n. 漂流，漂移；漂流物；趋势vi. 漂流，漂移；漂泊vt. 使…漂流；使…受风吹积 时态: drifted, drifting, drifts 形容词: drifty 18 contend 英:/kən’tend/ 美:/kən’tɛnd/ vi. 竞争；斗争；奋斗；争论vt. 主张；为…斗争时 态: contended, contending, contends 名 词: contender consent 19 pigeon 英:/‘pɪdʒɪn/ 美:/‘pɪdʒɪn/ n. 鸽子 20 badge 英:/bædʒ/ 美:/bædʒ/ n. 徽章；标记；证章vt. 授给…徽章 动 词: badge 21 myth 英:/mɪθ/ 美:/mɪθ/ n. 神话；虚构的人，虚构的事 22 heal 英:/hiːl/ 美:/hil/ vt. 治愈，痊愈；和解vi. 痊愈时 态: healed, healing, heals 形容词: healable 23 interior 英:/ɪn’tɪɜːrɪə/ 美:/ɪn’tɪrɪɚ/ n. 内部内地adj. 内部的内地的, 国内的名 词: interiority 副 词: interiorly 24 resort 英:/rɪ’zɔːt/ 美:/rɪ’zɔrt/ n. 凭借，手段；常去之地；度假胜地vi. 求助，诉诸；采取某手段或方法；常去时 态: resorted, resorting, resorts 8.22 # 单词 音标 解释 1 relieve 英:/rɪ’liːv/ 美:/rɪ’liv/ vt. 解除，减轻；使不单调乏味；换…的班；解围；使放心时 态: relieved, relieving, relieves 形容词: relievable 名 词: reliever 2 relief 英:/rɪ’liːf/ 美:/rɪ’lif/ n. 减轻，解除；救济；安慰 3 therapy 英:/‘θerəpɪ/ 美:/‘θɛrəpi/ n. 治疗，疗法 4 loosen 英:/‘luːs(ə)n/ 美:/‘lusn/ vt. &amp; vi. 解开; 放松松弛时 态: loosened, loosening, loosens 5 era 英:/‘ɪərə/ 美:/‘ɪrə/ n. 时代；年代；纪元 ERAabbr. Electrical Research Association &lt;英&gt;电气研究协会 ERAabbr. Electrical Research Association 〈英〉电气研究协会 Era耐蚀耐热合金钢 6 dirt 英:/dɜːt/ 美:/dɝt/ n. 污垢, 灰尘, 脏土泥土, 散土下流想法; 下流话恶言, 丑闻 7 phase 英:/feɪz/ 美:/fez/ n. 阶段, 时期(月亮、行星的)位相vt. 分阶段计划[安排]时 态: phased, phasing, phases 形容词: phasic 8 arouse 英:/ə’raʊz/ 美:/ə’raʊz/ vt. 唤醒引起, 激发时 态: aroused, arousing, arouses 名 词: arousal 9 panic 英:/ˈpænik/ 美:/ˈpænɪk/ n. 恐慌，惊慌；大恐慌adj. 恐慌的；没有理由的vt. 使恐慌vi. 十分惊慌 Panic潘神的,牧人之神的时 态: panicked, panicking, panics 形容词: panicky 10 conference 英:/‘kɒnf(ə)r(ə)ns/ 美:/‘kɑnfərəns/ n. 会议讨论, 商谈形容词: conferential 11 sophisticated 英:/sə’fɪstɪkeɪtɪd/ 美:/səˈfɪstɪkeɪtɪd/ adj. 老练的; 老于世故的精密的, 尖端的高雅的, 有教养的 12 enlighten 英:/ɪn’laɪt(ə)n/ 美:/ɪn’laɪtn/ vt. 启发, 开导时 态: enlightened, enlightening, enlightens 13 stack 英:/stæk/ 美:/stæk/ n. 堆；堆叠vt. 使堆叠；把…堆积起来vi. 堆积，堆叠时 态: stacked, stacking, stacks 形容词: stackable 名 词: stacker 14 inherit 英:/ɪn’herɪt/ 美:/ɪn’hɛrɪt/ vt. 继承；遗传而得vi. 成为继承人时 态: inherited, inheriting, inherits 名 词: inheritor 15 machinery 英:/mə’ʃiːn(ə)rɪ/ 美:/mə’ʃinəri/ n. (总称)机器体系, 机构 16 machine 英:/mə’ʃiːn/ 美:/mə’ʃin/ n. 机械，机器；机械般工作的人；机构vt. 用机器制造时 态: machined, machining, machines 形容词: machinable 形容词: machineless 8.23 # 单词 音标 解释 1 refrain 英:/rɪ’freɪn/ 美:/rɪ’fren/ vi. 制止；避免；节制，克制n. 叠句，副歌；重复时 态: refrained, refraining, refrains 2 density 英:/‘densɪtɪ/ 美:/‘dɛnsəti/ n. 密集, 稠密〈物〉〈化〉密度 3 comprise 英:/kəm’praɪz/ 美:/kəm’praɪz/ vt. 包含；由…组成时 态: comprised, comprising, comprises 形容词: comprisable 4 marine 英:/mə’riːn/ 美:/mə’rin/ adj. 海的, 海产的, 海生的海军的海事的, 海运的n. 水兵; 海军陆战队士兵 5 dean 英:/diːn/ 美:/din/ n. 迪安(姓氏, 男子名)n. 院长；系主任；教务长；主持牧师 名 词: deanship 6 overtake 英:/əʊvə’teɪk/ 美:/ˌovɚ’tek/ vt. 赶上；压倒；突然来袭vi. 超车时 态: overtook overtaken overtaking, overtakes 7 lease 英:/liːs/ 美:/lis/ n. 租约；租期；租赁物；租赁权vt. 出租；租得vi. 出租时 态: leased, leasing, leases 形容词: leasable 名 词: leaser 8 riot 英:/‘raɪət/ 美:/‘raɪət/ n. 暴乱, 骚乱极度丰富vi. 暴动, 闹事 RIOTabbr. REAL-Time Input-Output Transducer 实时输入输出传感时 态: rioted, rioting, riots 名 词: rioter 9 assemble 英:/ə’semb(ə)l/ 美:/ə’sɛmbl/ as 加强 + sembl 相类似，一样 + e → 不断集合类似的东西 → 集合 vt. 集合，聚集；装配；收集vi. 集合，聚集时 态: assembled, assembling, assembles 10 tutor 英:/‘tjuːtə/ 美:/‘tʊtɚ/ n. 导师家庭教师, 私人教师时 态: tutored, tutoring, tutors 11 scandal 英:/‘skænd(ə)l/ 美:/‘skændl/ n. 丑事, 丑闻流言蜚语; 闲话; 诽谤公愤; 反感 12 cherish 英:/‘tʃerɪʃ/ 美:/‘tʃɛrɪʃ/ vt. 珍爱, 珍视, 爱护怀有, 抱有时 态: cherished, cherishing, cherishes 13 expose 英:/ɪk’spəʊz/ 美:/ɪk’spoz/ vt. 使曝光；揭露，揭发；显示时 态: exposed, exposing, exposes 名 词: exposure 14 echo 英:/ˈekəu/ 美:/ˈɛko/ vt. 重复；反射vi. 随声附和；发出回声n. 回音；效仿 Echo通讯中用以代表字母e的词 15 expenditure 英:/ɪk’spendɪtʃə/ 美:/ɪk’spɛndɪtʃɚ/ n. 花费, 使用(尤指金钱的)支出额 16 venture 英:/‘ventʃə/ 美:/‘vɛntʃɚ/ vt. 敢于vi. 冒险；投机n. 冒险；风险；企业时 态: ventured, venturing, ventures 名 词: venturer 17 spur 英:/spɜː/ 美:/spɝ/ n. 马刺；鼓舞，刺激；山坡vi. 骑马疾驰；给予刺激vt. 激励，鞭策；给…装踢马刺 SPURabbr. Space Power Unit Reactor 宇宙飞行电源装置用的反应堆时 态: spurred, spurring, spurs 8.24 # 单词 音标 解释 1 intensity 英:/ɪn’tensɪtɪ/ 美:/ɪn’tɛnsəti/ n. 强烈, 剧烈(感情的)强烈程度 2 intense 英:/ɪn’tens/ 美:/ɪn’tɛns/ adj. 强烈的；紧张的；热情的；非常的比较级: intenser, intensest 副 词: intensely 3 flourish 英:/‘flʌrɪʃ/ 美:/‘flɝɪʃ/ vi. 茂盛, 繁荣兴旺发达vt. 挥动时 态: flourished, flourishing, flourishes 4 attachment 英:/ə’tætʃm(ə)nt/ 美:/ə’tætʃmənt/ n. 附着, 附属附属物, 附件连接;安装;附着连接物情感,爱慕;忠诚&lt;律&gt;扣押;扣押令 5 secure 英:/sɪ’kjʊə/ 美:/sə’kjʊr/ adj. 牢固的; 可靠的有把握的; 确切的vt. 握紧; 关牢使安全(使)获得; 把…弄到手比较级: securer, securest 形容词: securable 副 词: securely 名 词: securement 名 词: securer 6 presence 英:/‘prez(ə)ns/ 美:/‘prɛzns/ n. 出席；参加；风度；仪态；存在 7 fade 英:/feɪd/ 美:/fad/ vt. &amp; vi. (使)褪去, (使)变弱, (使)枯萎vi. 逐渐消失时 态: faded, fading, fades 8 summit 英:/‘sʌmɪt/ 美:/‘sʌmɪt/ n. (山等的)最高点; 峰顶高层会议 9 giant 英:/‘dʒaɪənt/ 美:/‘dʒaɪənt/ n. 巨人, 大力士伟人, 卓越人物adj. 特大的, 巨大的 10 annual 英:/‘ænjʊəl/ 美:/‘ænjuəl/ adj. 年度的；每年的n. 年刊，年鉴；一年生植物副 词: annually 11 federal 英:/‘fed(ə)r(ə)l/ 美:/‘fɛdərəl/ adj. 联邦(制)的联邦政府的副 词: federally 12 dispute 英:/dɪ’spjuːt/ 美:/‘dɪs’pjʊt/ vt. 辩论；阻止；抗拒；怀疑vi. 争论n. 辩论；争吵时 态: disputed, disputing, disputes 名 词: disputer 13 stale 英:/steɪl/ 美:/stel/ adj. 不新鲜的; 味道变坏的无趣味的; 老掉牙的没有生气的vi. 变陈旧; 走味比较级: staler, stalest 动 词: stale 副 词: stalely 名 词: staleness 14 illusion 英:/ɪ’l(j)uːʒ(ə)n/ 美:/ɪ’luʒn/ n. 错觉, 幻想, 错误观念假象形容词: illusionless 15 descendant 英:/dɪ’send(ə)nt/ 美:/dɪ’sɛndənt/ n. 后代, 后裔 16 sufficient 英:/sə’fɪʃ(ə)nt/ 美:/sə’fɪʃnt/ adequate enough adj. 足够的; 充足的副 词: sufficiently 8.26 # 单词 音标 解释 1 notable 英:/‘nəʊtəb(ə)l/ 美:/‘notəbl/ adj. 值得注意的，显著的；著名的n. 名人，显要人物副 词: notably 2 secondary 英:/‘sek(ə)nd(ə)rɪ/ 美:/‘sɛkəndɛri/ adj. 次要的, 次等的中级的, 第二的副 词: secondarily 3 moral 英:/‘mɒr(ə)l/ 美:/‘mɔrəl/ adj. 道德的；精神上的；品性端正的n. 道德；寓意副 词: morally 4 monster 英:/‘mɒnstə/ 美:/‘mɑnstɚ/ n. 怪物；巨人，巨兽；残忍的人adj. 巨大的，庞大的 5 discharge 英:/dɪs’tʃɑːdʒ/ 美:/dɪs’tʃɑrdʒ/ vt. 卸船偿还执行; 履行vt. &amp; vi. 放出; 流出开枪; 发射n. 获准离开, 释放排放出的物体时 态: discharged, discharging, discharges 缩 写: dis 形容词: dischargeable 名 词: discharger 6 alert 英:/ə’lɜːt/ 美:/ə’lɝt/ vt. 使警觉，使意识到；警告adj. 警惕的，警觉的；留心的n. 警报；警戒，警惕 ALERTabbr. Alcohol Level Evaluation Roadside Test 路边酒精浓度鉴定试验时 态: alerted, alerting, alerts 7 coordinate 英:/kəuˈɔ:dineit/ 美:/ko’ɔrdɪnet/ vt. 使协调; 使调和adj. 同等的, 并列的n. 〈数〉坐标时 态: coordinated, coordinating, coordinates 形容词: coordinative 名 词: coordinator 8 complicate 英:/‘kɒmplɪkeɪt/ 美:/‘kɑmplɪket/ vt. 使复杂化时 态: complicated, complicating, complicates 9 massive 英:/‘mæsɪv/ 美:/‘mæsɪv/ adj. 大而重的, 大块的可观的, 巨大的, 大量的 8.27 # 单词 音标 解释 1 enforce 英:/ɪn’fɔːs/ 美:/ɪn’fɔrs/ vt. 实施, 执行强迫, 迫使时 态: enforced, enforcing, enforces 名 词: enforceability 形容词: enforceable 名 词: enforcement 名 词: enforcer 2 simplicity 英:/sɪm’plɪsɪtɪ/ 美:/sɪm’plɪsəti/ n. 简单, 朴素, 率直 3 roar 英:/rɔː/ 美:/rɔr/ n. 吼；咆哮；轰鸣vi. 吼叫；咆哮；喧闹vt. 咆哮；呼喊；使……轰鸣时 态: roared, roaring, roars 名 词: roarer 4 lower 英:/‘ləʊə/ 美:/‘loɚ/ adj. 较低的, 低等的vt. &amp; vi. (使)降低; (使)跌落vt. 削弱; 削减时 态: loweredalso loured loweringlouring lowerslours 5 grace 英:/greɪs/ 美:/ɡres/ n. 优雅；恩惠；慈悲；魅力vt. 使优美 Gracen. 格雷斯（女子名）时 态: graced, gracing, graces 6 reverse 英:/rɪ’vɜːs/ 美:/rɪ’vɝs/ vt. &amp; vi. (使)反转; (使)颠倒; (使)翻转推翻, 取消使倒退, 逆转adj. 相反的, 颠倒的, 反向的n. 相反钱币的反面[背面]失败, 挫败时 态: reversed, reversing, reverses 副 词: reversely 名 词: reverser 7 dim 英:/dɪm/ 美:/dɪm/ adj. 暗淡的, 昏暗的, 不明亮的隐约的, 模糊不清的vt. &amp; vi. (使)变暗淡, (使)变模糊 DIMabbr. Design Information Manual 设计资料手册比较级: dimmer, dimmest 副 词: dimly 名 词: dimness 8 pad 英:/pæd/ 美:/pæd/ n. 衬垫；护具；便笺簿；填补vi. 步行；放轻脚步走vt. 填补；走 PAD包装拆器时 态: padded, padding, pads 名 词: padder 9 wrap 英:/ræp/ 美:/ræp/ vt. 包；隐藏；缠绕；掩护vi. 缠绕；穿外衣；包起来n. 外套；围巾 WRAPabbr. Web-Ready Appliances Protocol可上网家电协议时 态: wrapped, wrapt wrapping, wraps 10 distinct 英:/dɪ’stɪŋ(k)t/ 美:/dɪ’stɪŋkt/ adj. 截然不同的, 完全分开的清晰的, 明白的, 明显的副 词: distinctly 名 词: distinctness 11 orient 英:/‘ɔːrɪənt/ 美:/‘orɪənt/ vt. 使熟悉, 使适应使朝向; 使确定位置n. 东方, 亚洲时 态: oriented, orienting, orients 12 distribute 英:/dɪ’strɪbjuːt/ 美:/dɪ’strɪbjut/ vt. 分配, 分给散发; 散播; 分布时 态: distributed, distributing, distributes 13 estate 英:/ɪ’steɪt/ 美:/ɪ’stet/ n. 财产；房地产；身份 14 observe 英:/əb’zɜːv/ 美:/əb’zɝv/ vt. &amp; vi. 观察; 研究vt. 看到; 注意到遵守; 遵循评论[述]; 讲时 态: observed, observing, observes 副 词: observingly 8.28 # 单词 音标 解释 1 crack 英:/kræk/ 美:/kræk/ vt. &amp; vi. (使…)开裂, 破裂(使)身体上或精神上垮掉打开, 砸开(使)发出爆裂声n. 裂缝, 缝隙噼啪声, 爆裂声意外的一下重击试图, 尝试俏皮话强效可卡因（crack cocaine）时 态: cracked, cracking, cracks 2 trial 英:/‘traɪəl/ 美:/‘traɪəl/ n. 试验；磨炼；审讯；努力adj. 审讯的；试验的 3 pace 英:/peɪs/ 美:/peɪs/ vt. &amp; vi. 踱步于, 走动vt. 以步测量, 步测为…定步速n. 步速; 计划进度一步, 步子溜蹄, 步法 PACEabbr. Performance and Cost Evaluation 性能与成本估价时 态: paced, pacing, paces 副 词: pace 4 formal 英:/‘fɔːm(ə)l/ 美:/‘fɔrml/ adj. 正式的；拘谨的；有条理的n. 正式的社交活动；夜礼服副 词: formally 名 词: formalness 5 commerce 英:/‘kɒmɜːs/ 美:/‘kɑmɝs/ n. 商业, 贸易 6 leisure 英:/‘leʒə/ 美:/‘liʒɚ/ n. 闲暇；空闲；安逸adj. 空闲的；有闲的；业余的 7 guarantee 英:/gær(ə)n’tiː/ 美:/ˌɡærən’ti/ vt. 保证; 担保使(事情)可能发生n. 保证, 保障; 保证书; 保用期担保, 担保人担保品, 抵押品时 态: guaranteed, guaranteeing, guarantees 8 proportion 英:/prə’pɔːʃ(ə)n/ 美:/prə’pɔrʃən/ n. 均衡; 相称, 协调一物与他物在数量、大小等方面的关系; 比例部分; 份儿时 态: proportioned, proportioning, proportions 形容词: proportionable 副 词: proportionably 名 词: proportioner 名 词: proportionment 9 supervise 英:/‘suːpəvaɪz/ 美:/‘sʊpɚ’vaɪz/ vt. &amp; vi. 监督, 管理时 态: supervised, supervising, supervises 10 rebel 英:/ˈreb.əl/ 美:/ˈreb.əl/ n. 反政府的人; 反叛者; 造反者叛逆者vi. 反抗政府; 造反反抗权威; 叛逆时 态: rebelled, rebelling, rebels 8.29 # 单词 音标 解释 1 derive 英:/dɪ’raɪv/ 美:/dɪ’raɪv/ vt. &amp; vi. 得到源于时 态: derived, deriving, derives 形容词: derivable 2 punch /pʌn(t)ʃ/ vt. 用拳猛击打孔n. 猛击, 拳打冲床, 穿孔机力量 Punch潘趣(英国木偶戏 Punch and Judy 中的主角)时 态: punched, punching, punches 3 identical 英:/aɪ’dentɪk(ə)l/ 美:/aɪ’dɛntɪkl/ adj. 同一的副 词: identically 4 sympathetic 英:/sɪmpə’θetɪk/ 美:/ˌsɪmpə’θɛtɪk/ adj. 表示同情的赞同的, 支持的副 词: sympathetically 5 scholarship 英:/‘skɒləʃɪp/ 美:/‘skɑlɚʃɪp/ n. 学问, 学识奖学金 Scholarshipn. 奖学金,学问，学识 6 cue 英:/kjuː/ 美:/kju/ n. 提示，暗示；线索vt. 给…暗示时 态: cued, cuing, cues clue 7 inferior 英:/ɪn’fɪərɪə/ 美:/ɪn’fɪrɪɚ/ adj. 下级的，下等的；差的；自卑的n. 次品；下级名 词: inferiority superior 8 limb 英:/lɪm/ 美:/lɪm/ n. 肢，臂；枝干；分支vt. 切断…的手足；从…上截下树枝时 态: limbed, limbing, limbs 9 preference 英:/‘pref(ə)r(ə)ns/ 美:/‘prɛfrəns/ n. 较喜欢的东西, 偏爱优待, 优惠, 优先权 10 scheme 英:/skiːm/ 美:/skim/ vt. &amp; vi. 策划; 图谋n. 阴谋, 诡计计划, 方案时 态: schemed, scheming, schemes 名 词: schemer 11 interpret 英:/ɪn’tɜːprɪt/ 美:/ɪn’tɝprɪt/ vt. 解释; 说明vt. &amp; vi. 口译; 翻译时 态: interpreted, interpreting, interprets 形容词: interpretable 8.31 # 单词 音标 解释 1 altitude 英:/‘æltɪtjuːd/ 美:/‘æltɪtud/ n. 高度, 海拔高处, 高地形容词: altitudinal 2 subtract 英:/səb’trækt/ 美:/səb’trækt/ vt. 减去；扣掉时 态: subtracted, subtracting, subtracts 名 词: subtracter 3 impose 英:/ɪm’pəʊz/ 美:/ɪm’poz/ vi. 欺骗；利用；施加影响vt. 强加；以…欺骗；征税时 态: imposed, imposing, imposes 名 词: imposer 4 dictate 英:/dɪk’teɪt/ 美:/‘dɪktet/ vt. &amp; vi. 大声讲或读; 口授vt. 指示; 指定; 指令n. 命令, 规定, 要求时 态: dictated, dictating, dictates 5 breeze 英:/briːz/ 美:/briz/ n. 微风；轻而易举的事；煤屑；焦炭渣；小风波vi. 吹微风；逃走时 态: breezed, breezing, breezes 6 delivery 英:/dɪ’lɪv(ə)rɪ/ 美:/dɪ’lɪvəri/ n. 投递, 送交投递的邮件, 发送的货物分娩讲话方式, 演讲风格 7 curl 英:/kɜːl/ 美:/kɝl/ vt. 使…卷曲；使卷起来vi. 卷曲；盘绕n. 卷发；螺旋状物；卷曲时 态: curled, curling, curls 8 excess 英:/ɪk’ses/ 美:/ˈɛkˌsɛs/ n. 无节制；过度，过量；超过，超额adj. 额外的，过量的；附加的时 态: excessed, excessing, excesses 9 uncover 英:/ʌn’kʌvə/ 美:/ʌn’kʌvɚ/ vt. 揭露；发现；揭开vi. 发现；揭示；揭去盖子时 态: uncovered, uncovering, uncovers 10 loan 英:/ləʊn/ 美:/lon/ vt. 借出n. 借出借出物; 借款时 态: loaned, loaning, loans 名 词: loaner 11 penalty 英:/‘pen(ə)ltɪ/ 美:/‘pɛnəlti/ n. 惩罚, 处罚不利后果, 损失","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"英语","slug":"英语","permalink":"https://youngsay.cn/tags/%E8%8B%B1%E8%AF%AD/"}]},{"title":"js基础Ⅳ：内置对象","slug":"js4","date":"2021-08-16T08:26:54.000Z","updated":"2021-08-16T09:27:47.012Z","comments":true,"path":"2021/08/16/js4/","link":"","permalink":"https://youngsay.cn/2021/08/16/js4/","excerpt":"","text":"1 - 内置对象1.1 内置对象​ JavaScript 中的对象分为3种：自定义对象 、内置对象、 浏览器对象​ 前面两种对象是JS 基础 内容，属于 ECMAScript； 第三个浏览器对象属于 JS 独有的， JS API 讲解内置对象就是指 JS 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本而必要的功能（属性和方法），内置对象最大的优点就是帮助我们快速开发 ​ JavaScript 提供了多个内置对象：Math、 Date 、Array、String等 1.2 查文档Mozilla 开发者网络（MDN）提供了有关开放网络技术（Open Web）的信息，包括 HTML、CSS 和万维网及 HTML5 应用的 API。​ MDN:https://developer.mozilla.org/zh-CN/ 1.3 Math对象​ Math 对象不是构造函数，它具有数学常数和函数的属性和方法。跟数学相关的运算（求绝对值，取整、最大值等）可以使用 Math 中的成员。 属性、方法名 功能 Math.PI 圆周率 Math.floor() 向下取整 Math.ceil() 向上取整 Math.round() 四舍五入版 就近取整 注意 -3.5 结果是 -3 Math.abs() 绝对值 Math.max()/Math.min() 求最大和最小值 Math.random() 获取范围在[0,1)内的随机值 ​ 注意：上面的方法使用时必须带括号 ​ 获取指定范围内的随机整数： 123function getRandom(min, max) &#123; return Math.floor(Math.random() * (max - min + 1)) + min; &#125; 1.4 Date对象​ Date 对象和 Math 对象不一样，Date是一个构造函数，使用时需要实例化后才能使用其中具体方法和属性。Date 实例用来处理日期和时间 使用Date实例化日期对象 获取当前时间必须实例化： 1var now = new Date(); 获取指定时间的日期对象 1var future = new Date(&#x27;2022-8-16 16:50:00&#x27;); 注意：如果创建实例时并未传入参数，则得到的日期对象是当前时间对应的日期对象 使用Date实例的方法和属性 通过Date实例获取总毫秒数 总毫秒数的含义 ​ 基于1970年1月1日（世界标准时间）起的毫秒数 获取总毫秒数 123456789// 实例化Date对象var now = new Date();// 1. 用于获取对象的原始值console.log(date.valueOf()) console.log(date.getTime()) // 2. ★简单写可以这么做var now = + new Date(); // 3. HTML5中提供的方法，有兼容性问题var now = Date.now(); 1.5 数组对象创建数组的两种方式 字面量方式 示例代码如下： 1var arr = [1,&quot;test&quot;,true]; new Array() 示例代码如下： 1var arr = new Array(); 注意：上面代码中arr创建出的是一个空数组，如果需要使用构造函数Array创建非空数组，可以在创建数组时传入参数 ​ 参数传递规则如下： 如果只传入一个参数，则参数规定了数组的长度 如果传入了多个参数，则参数称为数组的元素 检测是否为数组 instanceof 运算符 instanceof 可以判断一个对象是否是某个构造函数的实例 1234var arr = [1, 23];var obj = &#123;&#125;;console.log(arr instanceof Array); // trueconsole.log(obj instanceof Array); // false Array.isArray() Array.isArray()用于判断一个对象是否为数组，isArray() 是 HTML5 中提供的方法 1234var arr = [1, 23];var obj = &#123;&#125;;console.log(Array.isArray(arr)); // trueconsole.log(Array.isArray(obj)); // false 添加删除数组元素的方法 数组中有进行增加、删除元素的方法，部分方法如下表 注意：push、unshift为增加元素方法；pop、shift为删除元素的方法 数组排序 数组中有对数组本身排序的方法，部分方法如下表 注意：sort方法需要传入参数来设置升序、降序排序 如果传入“function(a,b){ return a-b;}”，则为升序 如果传入“function(a,b){ return b-a;}”，则为降序 12345var arr=[1,12,3,4];arr.sort(function(a,b)&#123; //sort(函数) return a-b; //升序&#125;) console.log(arr); //1,3,4,12 数组索引方法 数组中有获取数组指定元素索引值的方法，部分方法如下表 数组转换为字符串 数组中有把数组转化为字符串的方法，部分方法如下表 注意：join方法如果不传入参数，则按照 “ , ”拼接元素 其他方法 1.6 字符串对象基本包装类型​ 为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String、Number和 Boolean。 ​ 基本包装类型就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法。 123// 下面代码有什么问题？var str = &#x27;andy&#x27;;console.log(str.length); ​ 按道理基本数据类型是没有属性和方法的，而对象才有属性和方法，但上面代码却可以执行，这是因为 ​ js 会把基本数据类型包装为复杂数据类型，其执行过程如下 ： 123456// 1. 生成临时变量，把简单类型包装为复杂数据类型var temp = new String(&#x27;andy&#x27;);// 2. 赋值给我们声明的字符变量str = temp;// 3. 销毁临时变量temp = null; 字符串的不可变​ 指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。 ​ 当重新给字符串变量赋值的时候，变量之前保存的字符串不会被修改，依然在内存中重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变。​ 由于字符串的不可变，在大量拼接字符串的时候会有效率问题 根据字符返回位置​ 字符串通过基本包装类型可以调用部分方法来操作字符串，以下是返回指定字符的位置的方法： ​ 案例：查找字符串”abcoefoxyozzopp”中所有o出现的位置以及次数 先查找第一个o出现的位置 然后 只要indexOf 返回的结果不是 -1 就继续往后查找 因为indexOf 只能查找到第一个，所以后面的查找，利用第二个参数，当前索引加1，从而继续查找 123456789var str = &#x27;abcoefoxyozzopp&#x27;;var index = str.indexOf(&#x27;o&#x27;);var num = 0;while(index != -1)&#123; console.log(index); //3 num++; index = str.indexOf(&#x27;o&#x27;,index+1);&#125;console.log(&#x27;o出现的次数是：&#x27;+ num +&#x27;次&#x27;); 根据位置返回字符​ 字符串通过基本包装类型可以调用部分方法来操作字符串，以下是根据位置返回指定位置上的字符： ​ 案例：判断一个字符串 ‘abcoefoxyozzopp’ 中出现次数最多的字符，并统计其次数 核心算法：利用 charAt(） 遍历这个字符串 把每个字符都存储给对象， 如果对象没有该属性，就为1，如果存在了就 +1 遍历对象，得到最大值和该字符 ​ 注意：在遍历的过程中，把字符串中的每个字符作为对象的属性存储在对象总，对应的属性值是该字符出现的次数 123456789101112131415161718192021222324var str = &#x27;abcoefoxyozzopp&#x27;;var o = &#123;&#125;;for (var i = 0; i &lt; str.length; i++) &#123; var chars = str.charAt(i); // chars 是 字符串的每一个字符 if (o[chars]) &#123; // o[chars] 得到的是属性值 o[chars]++; &#125; else &#123; o[chars] = 1; &#125;&#125;console.log(o);// 2. 遍历对象var max = 0;var ch = &#x27;&#x27;;for (var k in o) &#123; // k 得到是 属性名 // o[k] 得到的是属性值 if (o[k] &gt; max) &#123; max = o[k]; ch = k; &#125;&#125;console.log(max);console.log(&#x27;最多的字符是&#x27; + ch); 字符串操作方法​ 字符串通过基本包装类型可以调用部分方法来操作字符串，以下是部分操作方法： replace()方法​ replace() 方法用于在字符串中用一些字符替换另一些字符，其使用格式如下： 1字符串.replace(被替换的字符串， 要替换为的字符串)； split()方法​ split()方法用于切分字符串，它可以将字符串切分为数组。在切分完毕之后，返回的是一个新数组。 ​ 其使用格式如下： 1字符串.split(&quot;分割字符&quot;) 2 - 简单数据类型和复杂数据类型2.1 简单数据类型​ 简单类型（基本数据类型、值类型）：在存储时变量中存储的是值本身，包括string ，number，boolean，undefined，null 2.2 复杂数据类型​ 复杂数据类型（引用类型）：在存储时变量中存储的仅仅是地址（引用），通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等； 2.3 堆栈 堆栈空间分配区别： 1、栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈； 简单数据类型存放到栈里面 2、堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。 简单数据类型的存储方式 ​ 值类型变量的数据直接存放在变量（栈空间）中 复杂数据类型的存储方式 ​ 引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中 2.4 简单类型传参​ 函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。 1234567function fn(a) &#123; a++; console.log(a); &#125;var x = 10;fn(x);console.log(x); ​ 运行结果是：11 10 2.5 复杂数据类型传参​ 函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。 123456789101112function Person(name) &#123; this.name = name;&#125;function f1(x) &#123; // x = p console.log(x.name); // 2. 这个输出什么 ? x.name = &quot;罗志祥&quot;; console.log(x.name); // 3. 这个输出什么 ? &#125;var p = new Person(&quot;吴亦凡&quot;);console.log(p.name); // 1. 这个输出什么 ? f1(p);console.log(p.name); // 4. 这个输出什么 ? ​ 运行结果是：吴亦凡 吴亦凡 罗志祥 罗志祥","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://youngsay.cn/tags/JavaScript/"}]},{"title":"js基础Ⅲ：作用域和对象","slug":"js3","date":"2021-08-15T11:26:54.000Z","updated":"2021-08-15T11:44:30.732Z","comments":true,"path":"2021/08/15/js3/","link":"","permalink":"https://youngsay.cn/2021/08/15/js3/","excerpt":"","text":"1 - 作用域​ 通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。 JavaScript（es6前）中的作用域有两种： 全局作用域：作用于所有代码执行的环境(整个script标签内部)或独立的js文件。 局部作用域（函数作用域）：作用于函数内的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域。 ❗ jS没有块级作用域 块作用域由 { } 包括。 在其他编程语言中（如 java、c#等），在 if 语句、循环语句中创建的变量，仅仅只能在本 if 语句、本循环语句中使用，如下面的Java代码： java有块级作用域： 12345if(true)&#123; int num = 123; system.out.print(num); // 123&#125;system.out.print(num); // 报错 ​ 以上java代码会报错，是因为代码中 { } 即一块作用域，其中声明的变量 num，在 “{ }” 之外不能使用；而与之类似的JavaScript代码，则不会报错。 js中没有块级作用域（在ES6之前） 12345if(true)&#123; var num = 123; console.log(123); //123&#125;console.log(123); //123 2 - 变量的作用域在JavaScript中，根据作用域的不同，变量可以分为两种： 全局变量 局部变量 2.1 全局变量 在全局作用域下声明的变量叫做全局变量（在函数外部定义的变量）。 全局变量在代码的任何位置都可以使用 在全局作用域下 var 声明的变量 是全局变量 特殊情况下，在函数内不使用 var 声明的变量也是全局变量（不建议使用） 2.2 局部变量 在局部作用域下声明的变量叫做局部变量（在函数内部定义的变量） 局部变量只能在该函数内部使用 在函数内部 var 声明的变量是局部变量 函数的形参实际上就是局部变量 2.3 全局变量和局部变量的区别 全局变量：在任何一个地方都可以使用，只有在浏览器关闭时才会被销毁，因此比较占内存 局部变量：只在函数内部使用，当其所在的代码块被执行时，会被初始化；当代码块运行结束后，就会被销毁，因此更节省内存空间 3 - 作用域链​ 写在函数内部的是局部作用域，未写在任何函数内部即在全局作用域中；如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域；根据在**[内部函数可以访问外部函数变量]**的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链。 12345678910案例分析1：function f1() &#123; var num = 123; function f2() &#123; console.log( num ); &#125; f2();&#125;var num = 456;f1(); 1234567891011121314151617作用域链：采取就近原则的方式来查找变量最终的值var a = 1;function fn1() &#123; var a = 2; var b = &#x27;22&#x27;; fn2(); function fn2() &#123; var a = 3; fn3(); function fn3() &#123; var a = 4; console.log(a); //a的值 ? console.log(b); //b的值 ? &#125; &#125;&#125;fn1(); 4 - 预解析JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器在运行 JavaScript 代码的时候分为两步：预解析和代码执行。 预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提前声明或者定义，预解析也叫做变量、函数提升。 代码执行： 从上到下执行JS语句。 注意：预解析会把变量和函数的声明在代码执行之前执行完成。 1变量预解析 ​ 变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升。 12console.log(num); // 结果是多少？var num = 10; // ？ 结果：undefined★注意：变量提升只提升声明，不提升赋值 4.3 函数预解析 ​ 函数的声明会被提升到当前作用域的最上面，但是不会调用函数。 1234fn();function fn() &#123; console.log(&#x27;打印&#x27;);&#125; 结果：控制台打印字符串 — ”打印“ 注意：函数声明代表函数整体，所以函数提升后，函数名代表整个函数，但是函数并没有被调用！ 4.4 函数表达式声明函数问题 函数表达式创建函数，会执行变量提升 1234fn();var fn = function() &#123; console.log(&#x27;想不到吧&#x27;);&#125; 结果：报错提示 ”fn is not a function” 解释：该段代码执行之前，会做变量声明提升，fn在提升之后的值是undefined；而fn调用是在fn被赋值为函数体之前，此时fn的值是undefined，所以无法正确调用 5 - 对象对象：在 JavaScript 中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。 对象是由属性和方法组成的。 属性：事物的特征，在对象中用属性来表示（常用名词） 方法：事物的行为，在对象中用方法来表示（常用动词） 1var arr = [‘吴签’, ‘30&#x27;, &#x27;选妃&#x27;]; ​ 上述例子中用数组保存数据的缺点是：数据只能通过索引值访问，开发者需要清晰的清除所有的数据的排行才能准确地获取数据，而当数据量庞大时，不可能做到记忆所有数据的索引值。 ​ 为了让更好地存储一组数据，对象应运而生：对象中为每项数据设置了属性名称，可以访问数据更语义化，数据结构清晰，表意明显，方便开发者使用。 使用对象记录上组数据为： 12345var obj = &#123; name:&#x27;吴签&#x27;, age:30, works:&#x27;选妃&#x27;,&#125; JS中的对象表达结构更清晰，更强大。 创建对象的三种方式利用字面量创建对象 键：相当于属性名 值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等） 代码如下： 1234567891011var star = &#123; name : &#x27;张哲瀚&#x27;, age : 30, sex : &#x27;男&#x27;, sayLove : function()&#123; alert(&#x27;我很爱国&#x27;); &#125;&#125;;console.log(star.name) // 调用名字属性console.log(star[&#x27;name&#x27;]) // 调用名字属性star.sayLove(); // 调用 sayLove 方法,注意一定要带后面的括号 上述代码中 star即是创建的对象。 变量、属性、函数、方法总结 - 变量：单独声明赋值，单独存在 属性：对象里面的变量称为属性，不需要声明 函数：单独存在的，通过“函数名()”的方式就可以调用 方法：对象里面的函数称为方法，方法不需要声明，使用“对象.方法名()”的方式就可以调用 利用 new Object 创建对象12345678910var Star = new Object(); //创建空对象Star.name=&#x27;吴亦凡&#x27;; // 给空对象添加属性Star.age=30;Star.works=&#x27;选妃&#x27;;Star.sayHi=function()&#123; // 给空对象添加方法 console.log(&#x27;我的很大，你要忍一下~&#x27;);&#125;console.log(Star.name);console.log(Star[&#x27;age&#x27;]);Star.sayHi(); Object() ：第一个字母大写 使用的格式：对象.属性 = 值; 利用构造函数创建对象 构造函数 构造函数：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。 构造函数的封装格式： 123456function 构造函数名(形参1,形参2,形参3) &#123; this.属性名1 = 参数1; this.属性名2 = 参数2; this.属性名3 = 参数3; this.方法名 = 函数体;&#125; 构造函数的调用格式 1var obj = new 构造函数名(实参1，实参2，实参3) 示例 123456789101112131415161718// 封装function Star(name,age,works)&#123; this.name=name; this.age=age; this.works=works; this.result = function(result)&#123; //方法 console.log(result); &#125;&#125;// 调用var wyf = new Star(&#x27;吴亦凡&#x27;,30,&#x27;选妃&#x27;);var lzx = new Star(&#x27;罗志祥&#x27;,42,&#x27;时间管理&#x27;);var zzh = new Star(&#x27;张哲瀚&#x27;,30,&#x27;靖国神社&#x27;);wyf.result(&#x27;坐牢&#x27;);lzx.result(&#x27;退圈&#x27;);zzh.result(&#x27;封杀&#x27;);console.log(wyf.works);console.log(zzh[&#x27;works&#x27;]); 注意事项 构造函数约定首字母大写。 函数内的属性和方法前面需要添加 this ，表示当前对象的属性和方法。 构造函数中不需要 return 返回结果。 当我们创建对象的时候，必须用 new 来调用构造函数。 其他 构造函数，如 Stars()，抽象了对象的公共部分，封装到了函数里面，它泛指某一大类（class） 创建对象，如 new Stars()，特指某一个，通过 new 关键字创建对象的过程我们也称为对象实例化 new关键字的作用 在构造函数代码开始执行之前，创建一个空对象； 修改this的指向，把this指向创建出来的空对象； 执行函数的代码 在函数完成之后，返回this—即创建出来的对象 5.3 遍历对象​ for…in 语句用于对数组或者对象的属性进行循环操作。 ​ 其语法如下： 123for (变量 in 对象名字) &#123; // 在此执行代码&#125; ​ 语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 k 或者 key。 1234for (var k in obj) &#123; console.log(k); // 这里的 k 是属性名 console.log(obj[k]); // 这里的 obj[k] 是属性值&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://youngsay.cn/tags/JavaScript/"}]},{"title":"js基础Ⅱ：数组和函数","slug":"js2","date":"2021-08-15T03:26:54.000Z","updated":"2021-08-15T03:28:24.258Z","comments":true,"path":"2021/08/15/js2/","link":"","permalink":"https://youngsay.cn/2021/08/15/js2/","excerpt":"","text":"1-数组数组是指一组数据的集合，其中的每个数据被称作元素，在数组中可以存放任意类型的元素。 1-1创建数组JS 中创建数组有两种方式： 利用 new 创建数组12var 数组名 = new Array() ；var arr = new Array(); // 创建一个新的空数组 注意 Array () ，A 要大写 利用数组字面量创建数组1234//1. 使用数组字面量方式创建空的数组var 数组名 = []；//2. 使用数组字面量方式创建带初始值的数组var 数组名 = [&#x27;胖虎&#x27;,&#x27;panghutx&#x27;,&#x27;blog.wangyouwu.cn&#x27;]; 数组的字面量是方括号 [ ] 声明数组并赋值称为数组的初始化 数组元素的类型 数组中可以存放任意类型的数据，例如字符串，数字，布尔值等。 1var arrStus = [&#x27;小白&#x27;,12,true,28.9]; 1-2获取数组中的元素​ 索引 (下标) ：用来访问数组元素的序号（数组下标从 0 开始）。 1234// 定义数组var arrStus = [1,2,3];// 获取数组中的第2个元素alert(arrStus[1]); 注意：如果访问时数组没有和索引值对应的元素，则得到的值是undefined 1-3遍历数组数组遍历​ 把数组中的每个元素从头到尾都访问一次，可以通过 for 循环索引遍历数组中的每一项 1234var arr = [&#x27;red&#x27;,&#x27;green&#x27;, &#x27;blue&#x27;];for(var i = 0; i &lt; arr.length; i++)&#123; console.log(arrStus[i]);&#125; 数组的长度数组的长度：默认情况下表示数组中元素的个数 使用“数组名.length”可以访问数组元素的数量（数组长度）。 12var arrStus = [1,2,3];alert(arrStus.length); // 3 注意： 此处数组的长度是数组元素的个数 ，不要和数组的索引号混淆。 当数组元素个数发生变化， length 属性跟着一起变化 2-函数​ 函数：封装一段可被重复调用执行的代码块。通过此代码块可以实现大量代码的重复使用。 2-1函数的声明调用声明函数1234// 声明函数function 函数名() &#123; //函数体代码&#125; function 是声明函数的关键字,必须小写 由于函数一般是为了实现某个功能才定义的， 所以通常我们将函数名命名为动词，比如 getSum 调用函数12// 调用函数函数名(); // 通过调用函数名来执行函数体代码 调用的时候千万不要忘记添加小括号 口诀：函数不调用，自己不执行 注意：声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码。 例子：封装计算1-100累加和 12345678910111213/* 计算1-100之间值的函数*/// 声明函数function getSum()&#123; var sumNum = 0;// 准备一个变量，保存数字和 for (var i = 1; i &lt;= 100; i++) &#123; sumNum += i;// 把每个数值 都累加 到变量中 &#125; alert(sumNum);&#125;// 调用函数getSum(); 2-2函数的参数函数参数语法 形参：函数定义时设置接收调用时传入 实参：函数调用时传入小括号内的真实数据 函数参数的运用： 123456// 带参数的函数声明function 函数名(形参1, 形参2 , 形参3...) &#123; // 可以定义任意多的参数，用逗号分隔 // 函数体&#125;// 带参数的函数调用函数名(实参1, 实参2, 实参3...); 调用的时候实参值是传递给形参的 形参简单理解为：不用声明的变量 实参和形参的多个参数之间用逗号（,）分隔 函数形参和实参数量不匹配时 注意：在JavaScript中，形参的默认值是undefined。 小结： 函数可以带参数也可以不带参数 声明函数的时候，函数名括号里面的是形参，形参的默认值为 undefined 调用函数的时候，函数名括号里面的是实参 多个参数中间用逗号分隔 2-3函数的返回值return 语句返回值：函数调用整体代表的数据；函数执行完成后可以通过return语句将指定数据返回 。 1234567// 声明函数function 函数名（）&#123; ... return 需要返回的值；&#125;// 调用函数函数名(); // 此时调用函数就可以得到函数体内return 后面的值 在使用 return 语句时，函数会停止执行，并返回指定的值 如果函数没有 return ，返回的值是 undefined break ,continue ,return 的区别 break ：结束当前的循环体（如 for、while） continue ：跳出本次循环，继续执行下次循环（如 for、while） return ：不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码 2-4arguments的使用​ 当不确定有多少个参数传递的时候，可以用 arguments 来获取。JavaScript 中，arguments实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点： 具有 length 属性 按索引方式储存数据 不具有数组的 push , pop 等方法 注意：在函数内部使用该对象，用此对象获取函数调用时传的实参。 2-5函数案例 函数内部可以调用另一个函数，在同一作用域代码中，函数名即代表封装的操作，使用函数名加括号即可以将封装的操作执行。 1234567891011121314151617181920//用户输入年份，输出当前年份2月份的天数function backDay()&#123; var year = prompt(&#x27;请输入年份：&#x27;); if(isRunYear(year))&#123; alert(year+&#x27;是闰年，2月份有29天&#x27;); &#125;else &#123; alert(year+&#x27;是平年，2月份有28天&#x27;); &#125;&#125; backDay(); // 判断是否是闰年function isRunYear(year)&#123; //如果是闰年返回true，否则else var flag = false; if(year%4==0&amp;&amp;year%100!=0||year%400==0) &#123; //能被4整除且不能被100整除或者能被400整除 flag=true; &#125; return flag; &#125; 2-6函数的两种声明方式自定义函数方式(命名函数)利用函数关键字 function 自定义函数方式 1234// 声明定义方式function fn() &#123;...&#125;// 调用 fn(); 因为有名字，所以也被称为命名函数 调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面 函数表达式方式(匿名函数）利用函数表达式方式的写法如下： 1234// 这是函数表达式写法，匿名函数后面跟分号结束var fn = function()&#123;...&#125;；// 调用的方式，函数调用必须写到函数体下面fn(); 因为函数没有名字，所以也被称为匿名函数 这个fn 里面存储的是一个函数 函数表达式方式原理跟声明变量方式是一致的 函数调用的代码必须写到函数体后面","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://youngsay.cn/tags/JavaScript/"}]},{"title":"js练习Ⅰ：循环、数组、函数","slug":"js-exercise","date":"2021-08-14T13:45:54.000Z","updated":"2021-08-15T03:12:53.907Z","comments":true,"path":"2021/08/14/js-exercise/","link":"","permalink":"https://youngsay.cn/2021/08/14/js-exercise/","excerpt":"","text":"🙂循环 一行打印★★★★★ 12345var str = &#x27;&#x27;;for (var i = 1;i&lt;=5;i++) &#123; str = str + &#x27;★&#x27;; //追加字符串&#125; console.log(str); 倒序打印★ 第一行9个，第九行1个 12345678var str = &#x27;&#x27;;for (var i=1;i&lt;10; i++) &#123; // 控制行数 for (var j=i;j&lt;10;j++) &#123; // 控制每一行★个数 str = str + &#x27;★&#x27;; &#125; str = str + &#x27;\\n&#x27;; // 每行结尾换行&#125; console.log(str); 正序打印★ 第一行1个，第九行9个 12345678var str = &#x27;&#x27;;for (var i=1;i&lt;10;i++) &#123; for (var j =1 ;j&lt;=i;j++) &#123; str = str + &#x27;★&#x27;; &#125; str = str + &#x27;\\n&#x27;;&#125;console.log(str); 打印九九乘法表 12345678var str =&#x27;&#x27;;for (var i=1 ; i&lt;10;i++) &#123; for (var j=1;j&lt;=i;j++) &#123; str = str + j + &#x27;x&#x27; +i + &#x27;=&#x27; + j*i + &#x27;\\t&#x27;; &#125; str = str + &#x27;\\n&#x27;;&#125;console.log(str); 接收用户输入的用户名和密码，若用户名为 “admin” ,且密码为 “123456” ,则提示用户登录成功! 否则，让用户一直输入。 12345do &#123; var name = prompt(&#x27;请输入用户名&#x27;); var password = prompt(&#x27;请输入密码&#x27;);&#125;while (name != &#x27;admin&#x27; || password != &#x27;123456&#x27;); //两个有一个不满足就要进入循环，切忌写成&amp;&amp;alert(&#x27;登陆成功&#x27;); 求整数1～100的累加值，但要求跳过所有个位为3的数。 12345678var sum = 0;for (var i=1;i&lt;=100;i++) &#123; if(i%10==3) &#123; continue; &#125; sum = sum + i;&#125;console.log(sum); 1234567var sum = 0;for (var i=1;i&lt;=100;i++) &#123; if(i%10!=3) &#123; sum = sum + i; &#125; &#125;console.log(sum); ATM机 12345678910111213141516var sum =100;do&#123;var choice = prompt(&#x27;请输入你要的操作：\\n1.存钱 \\n2.取钱\\n3.显示余额\\n4.退出\\n &#x27;);if(choice==1)&#123; var num1 = prompt(&#x27;请输入存入金额：&#x27;) var sum = parseInt(sum) + parseInt(num1); alert(&#x27;你的余额是&#x27;+ sum +&#x27;元&#x27;)&#125;else if(choice == 2)&#123; var num2 = prompt(&#x27;请输入取出金额：&#x27;) var sum = parseInt(sum) - parseInt(num2); alert(&#x27;你的余额是&#x27;+ sum +&#x27;元&#x27;)&#125;else if(choice == 3)&#123; alert(&#x27;你的余额是&#x27;+ sum +&#x27;元&#x27;)&#125;&#125;while(choice!=4)alert(&#x27;退出成功&#x27;); 求从1开始第35个能被7和3整除的整数 1234567var count = 0;for(var i =1; count&lt;35;i++)&#123; if(i%3==0&amp;&amp;i%7==0)&#123; count++; console.log(i); &#125;&#125; 🙂数组 求出数组总和和平均数 12345678var arr = [2,6,1,7,4]; var sum = 0; var average = 0; for(var i =0; i &lt; arr.length ; i++)&#123; sum =sum +arr[i] // 求和是加数组元素arr[i]，不是数组下标i &#125; average = sum/arr.length; console.log(sum,average); // 输出多个变量，用，逗号隔开即可 求数组[2,6,1,77,52,25,7]中的最大值 12345678var arr = [2,6,1,77,52,25,7];var max =arr[0];for(i=0;i&lt;arr.length;i++)&#123; if(max&lt;arr[i])&#123; max=arr[i]; &#125;&#125;console.log(max); 将数组[‘red’,’green’,’blue’,’pink’]转换为字符串，并使用|分割 123456var arr = [&#x27;red&#x27;,&#x27;green&#x27;,&#x27;blue&#x27;,&#x27;pink&#x27;];var str = &#x27;&#x27;;for(var i=0;i&lt;arr.length;i++) &#123; str = str + arr[i] + &#x27;|&#x27;;&#125;console.log(str); 新建一个数组，里面存放10个整数（1-10） 123456ar arr = [];for(var i =0;i&lt;10;i++)&#123; // arr = 1 x 不要直接给数组名赋值 arr[i]=i+1;&#125;console.log(arr); 将数组[2,0,6,1,77,0,52,0,25,7]中大于等于10的元素选出来，放入新数组 12345678910var arr = [2,0,6,1,77,0,52,0,25,7];var arr1=[];var a=0;for(var i =0;i&lt;arr.length;i++)&#123; if(arr[i]&gt;=10)&#123; arr1[a]=arr[i] a++; &#125;&#125; console.log(arr1); 123456789var arr = [2,0,6,1,77,0,52,0,25,7];var arr1=[]; //arr1.length就是0var a=0;for(var i =0;i&lt;arr.length;i++)&#123; if(arr[i]&gt;=10)&#123; arr1[arr1.length]=arr[i] &#125;&#125; console.log(arr1); 将数组[2,0,6,1,77,0,52,0,25,7]中的0去掉，形成一个新数组 1234567var arr = [2,0,6,1,77,0,52,0,25,7];var arr1 = [];for(var i = 0; i&lt;arr.length;i++)&#123; if(arr[i]!=0 )&#123; arr1[arr1.length]=arr[i]; &#125;&#125; 将数组[1,2,3,4,5,6]内容反过来存放 1234567891011var arr = [1,2,3,4,5,6];var arr1 = [];var num = arr.length;for(var i = 0; i&lt;arr.length;i++)&#123; num--; arr1[arr1.length]=arr[num]; &#125;console.log(arr1); ★★★冒泡排序★★★ 将数组[2,1,3,5,4]元素由大到小排列 123456789101112var arr = [2,1,3,5,4];for(var i=0;i &lt;= arr.length-1;i++)&#123; // 趟数 for(var j=0;j&lt;=arr.length-1-i;j++) &#123; //每趟的次数w if(arr[j]&lt;arr[j+1])&#123; var temp =0; temp = arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125;&#125;console.log(arr); 🙂函数 利用函数求两个数的最大值 12345678910function Getmax (num1,num2) &#123; var max = num1; if(num1&gt;num2)&#123; max = num1; &#125;else &#123; max = num2; &#125; return max;&#125;console.log(Getmax(6,9)); 1234function Getmax (num1,num2) &#123; return num1&gt;num2 ? num1 : num2; //三元运算符&#125;console.log(Getmax(6,9)); 利用函数求数组中的最大值 1234567891011function Getmax (arr) &#123; //接收一个数组 var max = arr[0]; for(var i=0; i&lt;arr.length; i++) &#123; if(max&lt;arr[i])&#123; max=arr[i]; &#125; &#125; return max;&#125;var re = Getmax([5,2,99,101,67,77]); //实参是一个数组传过去console.log(re); 利用函数求任意个数中的最大值 1234567891011function getMax()&#123; var max = arguments[0]; for(var i=0;i&lt;arguments.length;i++)&#123; if(max&lt;arguments[i])&#123; max=arguments[i]; &#125; &#125; return max;&#125;var re=getMax(3,1,5,76,34);console.log(re); 利用函数,翻转任意一个数组 123456789function reverse(arr)&#123; var newArr=[]; for(var i=0;i&lt;arr.length;i++)&#123; newArr[newArr.length]=arr[arr.length-1-i]; &#125; return newArr;&#125;var arr1 = reverse([1,2,3,4,5]);console.log(arr1); 利用函数,对数组从小到大排序—冒泡排序 1234567891011121314function sort(arr)&#123; for(var i=0;i&lt;arr.length-1;i++)&#123; for(var j=0;j&lt;arr.length-1-i;j++) &#123; if(arr[j]&gt;arr[j+1])&#123; var temp = arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125; &#125; return arr;&#125;var arr1=sort([1,4,2,6,5]);console.log(arr1); 用户输入年份，输出当前年份2月份的天数 12345678910111213141516171819function backDay()&#123; var year = prompt(&#x27;请输入年份：&#x27;); if(isRunYear(year))&#123; alert(year+&#x27;是闰年，2月份有29天&#x27;); &#125;else &#123; alert(year+&#x27;是平年，2月份有28天&#x27;); &#125;&#125; backDay(); // 判断是否是闰年function isRunYear(year)&#123; //如果是闰年返回true，否则else var flag = false; if(year%4==0&amp;&amp;year%100!=0||year%400==0) &#123; //能被4整除且不能被100整除或者能被400整除 flag=true; &#125; return flag; &#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://youngsay.cn/tags/JavaScript/"}]},{"title":"js基础Ⅰ：变量和数据类型","slug":"js1","date":"2021-08-12T12:45:54.000Z","updated":"2021-08-15T03:28:15.724Z","comments":true,"path":"2021/08/12/js1/","link":"","permalink":"https://youngsay.cn/2021/08/12/js1/","excerpt":"","text":"JavaScript输入输出语句为了方便信息的输入输出，JS中提供了一些输入输出语句，其常用的语句如下： 方法 说明 归属 alert(msg) 浏览器弹出警示框 浏览器 console.log(msg) 浏览器控制台打印输出信息 浏览器 prompt(info) 浏览器弹出输入框，用户可以输入 浏览器 注意：alert() 主要用来显示消息给用户，console.log() 用来给程序员自己看运行时的消息。 变量什么是变量白话：变量就是一个装东西的盒子。 通俗：变量是用于存放数据的容器。 我们通过 变量名 获取数据，甚至数据可以修改。 变量的使用12345var age; // 声明一个 名称为age 的变量 age = 10; // 给 age 这个变量赋值为 10 var age = 18; // 声明变量同时赋值为 18// 声明一个变量并赋值， 我们称之为变量的初始化。var age = 10, name = &#x27;zs&#x27;, sex = 2; //同时声明多个变量 声明变量特殊情况 情况 说明 结果 var age ; console.log (age); 只声明 不赋值 undefined console.log(age) 不声明 不赋值 直接使用 报错 age = 10; console.log (age); 不声明 只赋值 10 数据类型数据类型简介 变量的数据类型 变量是用来存储值的所在处，它们有名字和数据类型。变量的数据类型决定了如何将代表这些值的位存储到计算机的内存中。JavaScript 是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定： 12var age = 10; // 这是一个数字型var areYouOk = &#x27;是的&#x27;; // 这是一个字符串 ​ 在代码运行时，变量的数据类型是由 JS引擎 根据 = 右边变量值的数据类型来判断 的，运行完毕之后， 变量就确定了数据类型。JavaScript 拥有动态类型，同时也意味着相同的变量可用作不同的类型： 12var x = 6; // x 为数字var x = &quot;Bill&quot;; // x 为字符串 数据类型的分类 JS 把数据类型分为两类： 简单数据类型 （Number,String,Boolean,Undefined,Null） 复杂数据类型 （object) 简单数据类型简单数据类型（基本数据类型） JavaScript 中的简单数据类型及其说明如下： 数字型 Number​ JavaScript 数字类型既可以保存整数，也可以保存小数(浮点数）。 12var age = 21; // 整数var Age = 21.3747; // 小数 数字型进制 最常见的进制有二进制、八进制、十进制、十六进制。 123456 // 1.八进制数字序列范围：0~7var num1 = 07; // 对应十进制的7var num2 = 019; // 对应十进制的19var num3 = 08; // 对应十进制的8 // 2.十六进制数字序列范围：0~9以及A~Fvar num = 0xA; 现阶段我们只需要记住，在JS中八进制前面加0，十六进制前面加 0x 数字型范围 JavaScript中数值的最大和最小值 最大值：Number.MAX_VALUE，这个值为： 1.7976931348623157e+308 最小值：Number.MIN_VALUE，这个值为：5e-32 数字型三个特殊值 Infinity ，代表无穷大，大于任何数值 -Infinity ，代表无穷小，小于任何数值 NaN ，Not a number，代表一个非数值 isNaN 用来判断一个变量是否为非数字的类型，返回 true 或者 false 12345 var usrAge = 21;var isOk = isNaN(userAge); console.log(isNum); // false ，21 不是一个非数字var usrName = &quot;andy&quot;; console.log(isNaN(userName));// true ，&quot;andy&quot;是一个非数字 字符串型 String​ 字符串型可以是引号中的任意文本，其语法为 双引号 “” 和 单引号’’ 1234var strMsg = &quot;胖虎同学panghutx&quot;; // 使用双引号表示字符串var strMsg2 = &#x27;胖虎同学panghutx&#x27;; // 使用单引号表示字符串// 常见错误var strMsg3 = 胖虎同学; // 报错，没使用引号，会被认为是js代码，但js没有这些语法 字符串转义符 ​ 类似HTML里面的特殊字符，字符串中也有特殊字符，我们称之为转义符。 ​ 转义符都是 \\ 开头的，常用的转义符及其说明如下： 转义符 解释说明 \\n 换行符，n 是 newline 的意思 \\ \\ 斜杠 \\ \\‘ ‘ 单引号 \\“ ”双引号 \\t tab 缩进 \\b 空格 ，b 是 blank 的意思 字符串长度 字符串是由若干字符组成的，这些字符的数量就是字符串的长度。通过字符串的 length 属性可以获取整个字符串的长度。 12var strMsg = &quot;我是胖虎同学！&quot;;alert(strMsg.length); // 显示 7 字符串拼接 多个字符串之间可以使用 + 进行拼接，其拼接方式为 字符串 + 任何类型 = 拼接之后的新字符串 拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串 123456//1.1 字符串 &quot;相加&quot;alert(&#x27;hello&#x27; + &#x27; &#x27; + &#x27;world&#x27;); // hello world//1.2 数值字符串 &quot;相加&quot;alert(&#x27;100&#x27; + &#x27;100&#x27;); // 100100//1.3 数值字符串 + 数值alert(&#x27;11&#x27; + 12); // 1112 + 号总结口诀：数值相加 ，字符相连 字符串拼接加强 12345console.log(&#x27;胖虎同学&#x27; + 20); // 只要有字符就会相连 var age = 20;console.log(&#x27;胖虎同学age岁&#x27;); // 这样不行哦console.log(&#x27;胖虎同学&#x27; + age); // 胖虎同学20console.log(&#x27;胖虎同学&#x27; + age + &#x27;岁啦&#x27;); // 胖虎同学20岁啦 经常会将字符串和变量来拼接，变量可以很方便地修改里面的值 变量是不能添加引号的，因为加引号的变量会变成字符串 如果变量两侧都有字符串拼接，口诀“引引加加 ”，删掉数字，变量写加中间 布尔型Boolean​ 布尔类型有两个值：true 和 false ，其中 true 表示真（对），而 false 表示假（错）。 ​ 布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0。 12console.log(true + 1); // 2console.log(false + 1); // 1 Undefined和 Null​ 一个声明后没有被赋值的变量会有一个默认值undefined ( 如果进行相连或者相加时，注意结果） 12345var variable;console.log(variable); // undefinedconsole.log(&#x27;你好&#x27; + variable); // 你好undefinedconsole.log(11 + variable); // NaNconsole.log(true + variable); // NaN ​ 一个声明变量给 null 值，里面存的值为空（学习对象时，我们继续研究null) 1234var vari = null;console.log(&#x27;你好&#x27; + vari); // 你好nullconsole.log(11 + vari); // 11console.log(true + vari); // 1 获取变量数据类型 获取检测变量的数据类型 ​ typeof 可用来获取检测变量的数据类型 12var num = 18;console.log(typeof num) // 结果 number ​ 不同类型的返回值 数据类型转换​ 什么是数据类型转换？ ​ 使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型。通俗来说，就是把一种数据类型的变量转换成另一种数据类型，通常会实现3种方式的转换： 123转换为字符串类型转换为数字型转换为布尔型 转换为字符串 转换为数字型 转换为布尔型 代表空、否定的值会被转换为 false ，如 ‘’、0、NaN、null、undefined 其余值都会被转换为 true 1234567console.log(Boolean(&#x27;&#x27;)); // falseconsole.log(Boolean(0)); // falseconsole.log(Boolean(NaN)); // falseconsole.log(Boolean(null)); // falseconsole.log(Boolean(undefined)); // falseconsole.log(Boolean(&#x27;小白&#x27;)); // trueconsole.log(Boolean(12)); // true","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://youngsay.cn/tags/JavaScript/"}]},{"title":"c语言：函数","slug":"c-function","date":"2021-08-10T02:31:01.000Z","updated":"2022-01-23T12:10:13.541Z","comments":true,"path":"2021/08/10/c-function/","link":"","permalink":"https://youngsay.cn/2021/08/10/c-function/","excerpt":"","text":"函数是一块代码，接收零个或多个参数，做一件事情，并返回零个或一个值。 调用函数函数名() ()起到了表示函数调用的作用，即使没有参数也需要()；如果有参数，则需要给出正确的数量和顺序，这些值会被按照顺序依次用来初始化函数中的参数。 123456789101112131415#include&lt;stdio.h&gt;void sum(int begain, int end)&#123; int i = 0; int sum = 0; for (i=begain; i &lt;= end; i++) &#123; sum += i; &#125; printf(&quot;%d到%d的和是%d&quot;, begain, end, sum);&#125;int main()&#123; sum(1, 10); return 0;&#125; 从函数中返回值return停止函数的执行，并返回一个值。 12345678910111213141516171819#include&lt;stdio.h&gt;int max(int a, int b)&#123; int ret = 0; if (a &gt; b) &#123; ret = a; &#125; else &#123; ret = b; &#125; printf(&quot;最大值是%d&quot;, ret); return ret;&#125;int main()&#123; max(11, 20); return 0;&#125; 函数原型函数头，以分号’;’结尾，构成了函数原型 函数原型目的是告诉编译器函数长什么样（名称、参数、返回类型） 1234567891011121314151617181920#include&lt;stdio.h&gt;int max(int a, int b); //声明【函数原型】int main()&#123; max(11, 20); return 0;&#125;int max(int a, int b) //定义 【实际的函数头】&#123; int ret = 0; if (a &gt; b) &#123; ret = a; &#125; else &#123; ret = b; &#125; printf(&quot;最大值是%d&quot;, ret); return ret;&#125; 传值传值：每个函数有自己的变量空间，参数也位于这个独立的空间中，和其他函数没有关系。 c语言在调用函数时，永远只能传值给函数 本地变量参数的每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量。 定义在函数内部的变量就是本地变量，参数也是本地变量 变量的生存期与作用域生存期：什么时候这个变量开始出现了，到什么时候它消亡了 作用域：在（代码的）什么范围内可以访问这个变量（这个变量可以起作用） 对于本地变量，这两个问题的答案是统一的：大括号内——块 本地变量的规则本地变量是定义在块内的，它可以定义在函数的块内，也可以定义在语句的块内。 程序进入块之前，其中的变量不存在，离开块，其中的变量消失。 块外面定义的变量在里面仍然有效，块内的同名变量会掩盖外面的变量","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"c","slug":"c","permalink":"https://youngsay.cn/tags/c/"}]},{"title":"c语言：数据类型","slug":"c-date-type","date":"2021-08-09T03:31:01.000Z","updated":"2022-01-23T12:07:49.537Z","comments":true,"path":"2021/08/09/c-date-type/","link":"","permalink":"https://youngsay.cn/2021/08/09/c-date-type/","excerpt":"","text":"整数 char：1字节（8比特） -128~127 short：2字节 -32768~32767 int：取决于编译器（CPU），通常意义是“1个字” long：取决于编译器（CPU），通常意义是“1个字” long long：8字节 整数的内部表达都是二进制 补码补码的意义就是拿补码和原码可以加出一个溢出的“零” 0-1=-1(1)00000000 - 00000001 –&gt; 1111111111111111被看作纯二进制看待时，是255，被当作补码看待时是-1同理，-a的补码是0-a，实际上是 (n是这种类型的位数)$$2^n-a$$ 8进制和16进制： 一个以0开始的数字字面量是8进制 一个以x开始的数字字面量是16进制 %0用于8进制，%x用于16进制 8进制和16进制只是如何把数字表达为字符串，与内部如何表达数字无关 浮点数 类型 字长 有效数字 scanf printf float 32 7 %f %f，%e double 64 15 %lf %f，%e 输出精度：在%和f之间加上.n可以指定输出小数点后几位，输出是4舍5入的 printf(“%.3f\\n”,-0.0056); —&gt; 输出结果为-0.006 float需要用f或F后缀来表明身份，带小数点的字面量默认是double 自动类型转换：当运算符两边出现不一致的类型时，会自动转换成较大（数的范围打）的类型 char–&gt;short–&gt;int–&gt;long–&gt;long long int–&gt;float–&gt;double 强制类型转换：(类型)值 如(int)6.66表示把float转换成int 逻辑运算 运算符 描述 示例 结果 ！ 逻辑非 !a a=1,!a=0 &amp;&amp; 逻辑与 a&amp;&amp;b 如果a和b都是true，结果才是true；否则就是false || 逻辑或 a||b 如果a和b有一个是true，结果就是true。 运算符优先级 优先级 运算符 结合性 1 () 从左到右 2 ! + - ++ – 从右到左（单目的+和-） 3 */% 从左到右 4 +- 从左到右 5 &lt; &lt;= &gt; &gt;= 从左到右 6 == != 从左到右 7 &amp;&amp; 从左到右 8 || 从左到右 9 = += -+ *= /= %= 从右到左 对于&amp;&amp;，左边是false时就不做右边了；对于||，左边是true时就不做右边了。 逗号表达式优先级别最低，它将两式联接起来，如：（3+5,6+8）称为逗号表达式，其求解过程先表达式1，后表达式2，整个表达式值是表达式2的值，如：（3+5，6+8）的值是14，（a=20/4,a*4）的值是20，原因在于赋值运算优先级高于逗号表达式。","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"c","slug":"c","permalink":"https://youngsay.cn/tags/c/"}]},{"title":"移动web开发——rem布局","slug":"rem","date":"2021-08-05T07:07:01.000Z","updated":"2021-08-05T07:36:48.298Z","comments":true,"path":"2021/08/05/rem/","link":"","permalink":"https://youngsay.cn/2021/08/05/rem/","excerpt":"","text":"rem基础rem (root em)是一个相对单位，类似于em，em是父元素字体大小。 不同的是rem的基准是相对于html元素的字体大小。 比如，根元素（html）设置font-size=12px; 非根元素设置width:2rem; 则换成px表示就是24px。 12345678/* 根html 为 12px */html &#123; font-size: 12px;&#125;/* 此时 div 的字体大小就是 24px */ div &#123; font-size: 2rem;&#125; rem的优势：父元素文字大小可能不一致， 但是整个页面只有一个html，可以很好来控制整个页面的元素大小。 媒体查询什么是媒体查询媒体查询（Media Query）是CSS3新语法。 使用 @media查询，可以针对不同的媒体类型定义不同的样式 @media 可以针对不同的屏幕尺寸设置不同的样式 当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面 目前针对很多苹果手机、Android手机，平板等设备都用得到多媒体查询 媒体查询语法规范 用 @media开头 注意@符号 mediatype 媒体类型 关键字 and not only media feature 媒体特性必须有小括号包含 123@media mediatype and|not|only (media feature) &#123; CSS-Code;&#125; mediatype 查询类型​ 将不同的终端设备划分成不同的类型，称为媒体类型 关键字​ 关键字将媒体类型或多个媒体特性连接到一起做为媒体查询的条件。 and：可以将多个媒体特性连接到一起，相当于“且”的意思。 not：排除某个媒体类型，相当于“非”的意思，可以省略。 only：指定某个特定的媒体类型，可以省略。 媒体特性 每种媒体类型都具有各自不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格。我们暂且了解三个。 注意他们要加小括号包含 媒体查询书写规则 注意： 为了防止混乱，媒体查询我们要按照从小到大或者从大到小的顺序来写,但是我们最喜欢的还是从小到大来写，这样代码更简洁 less 基础维护css弊端CSS 是一门非程序式语言，没有变量、函数、SCOPE（作用域）等概念。 CSS 需要书写大量看似没有逻辑的代码，CSS 冗余度是比较高的。 不方便维护及扩展，不利于复用。 CSS 没有很好的计算能力 非前端开发工程师来讲，往往会因为缺少 CSS 编写经验而很难写出组织良好且易于维护的 CSS 代码项目。 less 介绍Less（LeanerStyle Sheets 的缩写）是一门 CSS扩展语言，也成为CSS预处理器。它在CSS 的语法基础之上，引入了变量，Mixin（混入），运算以及函数等功能，大大简化了 CSS 的编写，并且降低了 CSS的维护成本，就像它的名称所说的那样，Less可以让我们用更少的代码做更多的事情。 Less中文网址：http://lesscss.cn/ 常见的CSS预处理器：Sass、Less、Stylus less安装①安装nodejs，可选择版本(8.0)，网址：http://nodejs.cn/download/ ②检查是否安装成功，使用cmd命令（win10是window+r 打开运行输入cmd） —输入“node –v”查看版本即可 ③基于nodejs在线安装Less，使用cmd命令“npm install -g less”即可 ④检查是否安装成功，使用cmd命令“ lessc -v ”查看版本即可 less使用less变量变量是指没有固定的值，可以改变的。因为我们CSS中的一些颜色和数值等经常使用。 1@变量名:值; 必须有@为前缀 不能包含特殊字符 不能以数字开头 大小写敏感 1@color: pink; less嵌套1234567891011// 将css改为less#header .logo &#123; width: 300px;&#125;#header &#123; .logo &#123; width: 300px; &#125;&#125; 如果遇见 （交集|伪类|伪元素选择器） ，利用&amp;进行连接 12345678a:hover&#123; color:red;&#125;a&#123; &amp;:hover&#123; color:red; &#125;&#125; less运算任何数字、颜色或者变量都可以参与运算。就是Less提供了加（+）、减（-）、乘（*）、除（/）算术运算。 123456789101112/*Less 里面写*/@witdh: 10px + 5;div &#123; border: @witdh solid red;&#125;/*生成的css*/div &#123; border: 15px solid red;&#125;/*Less 甚至还可以这样 */width: (@width + 5) * 2; 乘号（*）和除号（/）的写法 运算符中间左右有个空格隔开 1px + 5 对于两个不同的单位的值之间的运算，运算结果的值取第一个值的单位 如果两个值之间只有一个值有单位，则运算结果就取该单位","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"css","slug":"css","permalink":"https://youngsay.cn/tags/css/"}]},{"title":"【第一期】我爱记单词🙂","slug":"words","date":"2021-08-02T13:07:01.000Z","updated":"2021-09-06T08:38:07.792Z","comments":true,"path":"2021/08/02/words/","link":"","permalink":"https://youngsay.cn/2021/08/02/words/","excerpt":"","text":"7.29boastv.自夸、吹嘘 n.自吹自擂 boat 船 把气船吹炸了 cartn.手推车、运货马车 v.用车运送 clientn.委托人、客户 climb–&gt;攀爬、攀关系、巴结客户 climb client cruisen.航游 v.乘船游览 considerableadj.相当大的、相当多的、重大的considerate adj.考虑周到的 considerable things must considerate. capableadj.有能力的、有才能的 capital n.首都、资本、资金 adj.极好的 capable people are capital capacity n. 能力，才能；理解能力；身份，角色，职位；生产量，生产力；容量 capture vt.俘虏;俘获;捕获;用武力夺取;攻取;攻占;夺得;赢得;争得n.(被)捕获;(被)俘获 chiefadj.主要的、首席的n.主席、领导人 barelyadv.刚刚、才、仅仅、只不过、几乎不 restraintn.控制、限制 restrict vt.限制;束缚;妨碍;阻碍 attributev.把……归咎于contribute v.贡献 grantv.同意、承认n.拨款 student grant 助学金 take …for granted 想当然，理所当然 greatful adj.感激的 releasev.公布、发布（消息）、释放 n.释放、放松 loosen=lax=lease=lish=lang 松开、放松 release relax relish languish reliefn.救济、解脱、缓和 belief n.信念、信仰 investv.投资 investment n.投资 invite v.邀请 detectiven.侦探 dectect v.发现、查明 utteradj.完全的、彻底的 v.发出（声音）、说、讲 heritagen.贵重遗物、继承物、传统 her stage has gone. organicadj.有机的、器官的 inorganic 无机的 organ 器官 organization n.组织 7.30superioradj. 较高的；上级的；高质的；占优势的；高标准的；有优越感的，高傲的 n. 上级，上司，级别更高的人 cultivatev. 耕作，种植；培养；养成（某种素质或技能）； 与（某人）结交；试图赢得…的好感 cultivate culture 文化培养 breedn. 品种；类型 v. 培育（动、植物），育种；产生，惹起，酿成；使（动物）繁殖，（使）产仔 brand n.品牌 editv. 编辑，编选，选辑；校订；在电脑上编辑（文本） n. 编辑；校订；剪辑 maximumadj. 最高的，最大的；最大限度的 n. 最多，最大量 adv. 最多，至多 modificationn. 修改，更改；改型，改装；改变 modify v.更改 residentn. 常住居民，定居者； adj. 在某地居住的, 常驻的; reside: re(重新)sid(坐)e —&gt;重新坐下—&gt;安定下来—&gt;居住 resident：reside（居住）dent（的人）—&gt;居民 president：pre(向前)sid(坐)ent(人) 坐在前面的人–&gt;总统 frequencyn. 频度，频率；频繁；（电台广播或传输信号的）频带，波段；（波的）振动频率 frequent adj.频繁的 v.常去 more than one time 不止一次 conventionaladj. 传统的；习惯的，常规的 traditional adj.传统的 conversation n.交流 substancen. 物质，材料；实质；重要性；主旨 sub(下)stan(站、立)ce 立在下面的东西–&gt;本质 rawadj. （材料，物质）自然状态的；未加工的；（感情，品质）强烈的，坦诚的；（食物）生的；（信息）未经分析的；未经处理的；原始的，第一手的 in the raw处在自然状态的、裸体的 peakn. 山顶，山峰；顶点，顶峰；峰值，极值；帽舌 vi. 达到最大值，达到高峰 adj. 高峰时期的；巅峰状态的；高峰的 consumptionn. 吃；喝；摄取；消费；消耗量；消费量；（资源）耗尽；消耗；观看（或收听）的节目 consume v.消费 consumer n.消费者 assumption(n.假设)； presumption(n.假定，假设)； resumption(n.恢复，重新开始) nightmaren. 噩梦，梦魇；无法摆脱的恐惧；很难对付的人（或事、情况等） horror n.恐惧、厌恶🤢 horrible adj.恐怖的、十分讨厌的 restorev. 修复（建筑物、艺术品等）；使恢复原样；使复位；使复职；恢复（权利，做法，情况）；归还 swellv. 膨胀，肿胀；凸出，鼓出；增加，扩大；感情迸发 n. 海浪涌动；鼓出处，隆起处；增加，扩大 adj. 很愉快的；极有趣的 7.31infectv. 感染、传染 effect v.使发生、实现、引起 n.效应、影响、结果 effective adj. 能产生（预期）效果的，有效的 affect v.影响;侵袭;使感染;(感情上)深深打动;使悲伤(或怜悯等) furtheradv. （空间或时间上）更远地；进一步地，在更大程度上，在更大范围内；再往前地 adj. 另外的，更多的，进一步的；更远的 v. 促进；增进 hintn. 暗示，提示 v. 暗示，示意 give sb a hint 给某人一个暗示； take a/the hint 领会某人的暗示； exhibitv. 展览，展出；表现（某一品质，某种行为）；显示；显露；显出…的征兆（或症状） n. 展品；陈列品；展览 exhibition n.展览 whereasconj. 而，却；反之 investigatev. 调查；核查，检查（为发现某种情况）；深入研究（多指科学或学术领域） detect v.发现、查明 prescriptionn. 处方，药方；开处方，开药方；诀窍，秘诀；权威推荐 pre(前、预先)script(脚本)ion prescribe v. （医生）开（药）；为…开处方；规定，指定；推荐，推举 negotiatev. 谈判，洽谈，协商；通过洽谈达成，谈成；通过，越过（险要路段） investigate v.调查、核查 primitiveadj. 原始的，早期的；远古的；落后的；最基本的，极简单的，质朴的 n. 原始人；文艺复兴前的艺术家 primitive 原始的；primary 初期的 boundaryn. 【喻】（某些抽象事物的）界限 bladen. 刀刃，刀片；叶片 blame v.责备 engagementn. 保证; 约会; 参与; 订婚; 婚约; 受雇, 受聘; 交战, 战斗; 啮合 engage v.从事、雇佣、于…建立关系 strivev. 努力，奋斗，力争 struggle v/n.奋斗、努力✊ retreatv. 撤退，后退；（尤指因受到批评或遇到困难）退缩；让步 n. 撤退，退却；让步；隐居处；静居处 prevailvi. 流行, 盛行; 获胜; 占优势, 占上风; 成功; 奏效 mechanismn. 机械装置，机件；机制；机理 8.2principaln. （中学、学院等的）校长；院长；负责人; 主要演员；本金；委托人； 主犯 adj. 首要的，最主要的，最重要的 executiveadj. 行政的；执行的；实行的；管理的 n. 高级管理人员；经理；主管 execute v.执行 ex向外(s)ec第二【按顺序】ute CEO=chief executive officer 首席执行官 CFO=chief financial officer 财务主管 legendn.传说、传奇、传奇人物 amateuradj. 业余爱好者的 n. 业余爱好者；外行 excelv. 擅长，善于；出色，突出 underestimatev. 低估；不够重视；轻视 n. 低估；轻视 estimate v.评估 contemporaryadj. 当代的；生活在同时代（或时期）的；同时代（或时期）发生的 n. 同时代的人 relativeadj. 相对的; 比较的; [语法]关系的, 由关系词引导的; (级别等)相当的, 对应的 n. 亲戚, 亲属; 亲缘动物(或植物); [语法]关系词 confusionn. 不确定；疑惑；慌张，慌乱；紊乱，无秩序；混乱；杂乱；糊涂，迷茫 confuse v.混淆、使糊涂 refuse v.拒绝 speculatev. 推测，猜测；投机 estimate v.估计、估算 appraise v.评价;估价;估量;(对某人的工作)作出评价 evaluate v. 估…的值；定…的价；对…进行评价 specifyv. 明确说明；具体指定；详细说明 specific adj.明确的 precisionn. 准确度，精密度；准确性；确切性 adj. 精确的，精密的 cis, cid 【拉丁】=cut,kill,表示“切开，杀” 词根助记：precision : pre预先＋cis→预先切好→精确的 accuracy n.准确 accurate adj.准确的 intellectualadj. 要动脑的，脑力的；智力的，才智的 n. 知识分子 intellect n.智力、理解力、知识分子 intellective adj.智力的 capturev. 俘虏；俘获，捕获；（用文字、图片）准确记录；（用武力）占有；控制；引起（注意） n. 捕获；俘获 tendencyn. 趋势，趋向；倾向；习惯 quotev. 摘引；引用，引述；复述；援用（某人）的说法；指出（某人，某事）为出处，以…为证；报价 n. 引语 scatterv. 散布；分散；播撒 n. 散布，零星少量；零星散布的东西 mightyadj. 强大的；强有力的；巨大的；非凡的 adv. 非常；很；极其 catalogn. 目录；一系列 vt. 将（同类物品）编成目录；连续列举（类似情况、属性或事件） 8.3fictionn. 小说，虚构 function 功能 作用 batteryn. 电池；一系列，一批 a battery of 一系列 freightv. 货运；【喻】使充满；使担负 n. （用车、火车、船或飞机）运输（货物）；货物 gripv. 紧握; 紧抓; 咬住; 夹牢; 吸引住; 有吸引力 n. 紧握；紧抓；理解，掌握 grasp 抓住、抓牢 dominantadj. 首要的，主导的，占支配地位的，占优势的 invadev. （军队）入侵，侵略，侵占；侵犯，侵害；大量涌入 accusev. 指控，责备，控告 seeminglyadv. 表面上；显得；好像 apparently adv表面上地，显然地 artificialadj. 人工的，人造的；虚伪的 Artificial Intelligence(AI)人工智能 cablen. 缆绳，钢索；电缆；电报；有线传输系统 v. 发电报 distinguishv. 识别；区分；感觉到差别；指出差别；使区别于他物 plungev. 纵身投入，一头进入；骤降，（价值）猛跌 n. （价值或数量的）骤然下跌 plunge into 投入…中 paradev. 游行; 列队行进; 炫耀; 展示 n. 游行（尤指庆祝活动）；队列；阅兵行进；炫耀； 展示 preliminaryadj. 初步的；起始的；预备的 n. 准备工作；初步行动 quantitativeadj. （数）量的；用数量表示的；定量的；量化的 quantity 数量 proceduren. 程序，步骤，手续；外科手术 词根记忆：pro（向前）+ced（走，前进）+ ure → 一步步向前走的过程 → 程序，手续 guiltn. 内疚；不安；犯罪，罪行 guilty adj.有罪的 8.5objectiven. 目标；目的；物镜 adj. （人，判断）客观的；客观存在的；真实的 subjective adj.主观的 importn. 进口；进口品；进口品销售；进口品销售收入；含意 v. 进口; 引进; 含有…意思; 有关系, 具重要性 export v.出口 scalen. 规模；程度；范围；等级；级别；刻度；比例尺；天平，磅秤；（鱼等的）鳞 v. 依比例决定；攀登 on a large scale大规模地，大范围地；out of scale 不符合比例； scale down 缩减 realm n. 界，领域，范围；王国 shaden. 阴凉处，（树）荫；灯罩；阴影部分；差别；略微 v. 遮挡光线；渐变；（数量、速度或价格）略降 spotn. 斑点；污渍；一个特定的地方（或点）；排名 v. 现；注意到；认出；玷污 adj. 当场作出的; 现付的; 当即支付的; 抽样的; 从现场报道的; 插播的 on the spot 当场 identify 认出，辨别出 polishv. 擦亮，上光；改进，使完美，润色 n. 磨光，擦亮；擦亮剂；优雅，精良 qualifyvt. 使胜任；使有资格；（使）有资格被划为；承认（或确定）（某人）有执业资格；获得学历；使有权；修饰，限定 quality n.质量 quantify v. 表示（或测量）…的数量，量化 reputationn. 名声，美名，名誉 cluen. （揭露事件、解决问题的）线索，提示 stemn. （植物、灌木的）茎，干；词干；血统 v. 堵住；阻止；起源于，发生 8.7specializev. 专门研究，专门从事（某项活动）；专营 equivalentadj. （在价值、数量、功能、意义等方面）相等的，相同的，等同的 n. （在价值、数量、功能、意义等方面）对等的人（或事物），对应的人（或事物）；对应词 equal adj. 相等的；胜任的；平等的 vt. 等于；比得上 n. 同辈；对手；匹敌；相等的事物 enthusiasmn. 热情，热心，热忱；巨大兴趣 signaln. 信号；暗号；导火线；信号灯；动机 v. 用信号传递信息（或指示）；发信号；（用举动或声音）表示，表明 adj. 显著的，重要的 sign n. 符号；记号；迹象；手势 vi. 签名；签署 vt. 签署；示意 single adj. 单一的; 单个的; 未婚的, 独身的 n. 单程票；单打比赛 vt. 挑选 prescribev. （医生）开（药）；为…开处方；规定，指定；推荐，推举 extensionn. 扩大范围；（现有体系或活动范围的）延伸，延伸；延期；电话分机 reliefn. 救济；补助；（疼痛、不便之处、痛苦等）缓解，减轻；（忧虑或痛苦消除后感到的）宽慰，欣慰，放心 dominatev. 支配，统治，控制；俯视；占据优势 dominant adj. 首要的，主导的，占支配地位的，占优势的 nerven. 神经；勇敢，胆量 have the nerve to do 敢于做 regain one’s nerve 恢复勇气和自信, 恢复镇静 isolatev. 使隔离，使孤立；（化，生）使离析；使分离 desolate adj. 荒凉的；无人烟的 vt. 使荒凉；使孤寂 decentadj. 过得去的，合意的，舒适的，满意的；好的，出色的；合乎礼仪的，得体的 transferv. 转移；调动，改行；转让（财产，权利）；移交（责任）；转变（词义等） n. 迁移，转移，调动；财产转让（尤指股票过户） stuffv. 填满，塞满 n. 材料，原料；东西，物品；技巧；要素，基本的东西；特质，特征 staff 全体职员; 教职员 passiveadj. 被动的，消极的 positive dynamic negative constructv. 建筑；建造；建立；构筑（某物）；组成；构成；形成（观念，理论） n. （尤指主观的）观念，概念；构想 con 共同 + struct 建造，建立 → 共同建立 → 建筑 contractn.合同;合约;契约;(雇用杀人的)协议v.(使)收缩，缩小;感染(疾病);得(病);与…订立合同(或契约) shiftv. 转移；更替；转嫁；换挡，变速 n. 交换，变化；（位置的）转移；（方向的）改变；（趋势的）转变；（工作）轮班，当班时间 generallyadv. 广泛地，普遍地；大多数情况下；通常 intensiveadj. （尤指商业、经济中）集中使用的；密集使用的 intense a.强烈的，紧张的；认真的； extendv.延伸;延长;扩展;扩大;使伸长;使延期;扩大…的范围(或影响 contend v.争论、竞争 extension n.扩大、延长 8.8disastrousadj. 灾难性的，糟糕透顶的 innovationn. 革新，变革，改革；新方法；新观念；新产品 in注入nov(new)新的东西ation –&gt;注入新的东西：革新 staleadj. （食物）不新鲜的；走味的；变硬的；发霉的；干的；（空气）污浊的, （烟味）难闻的；（人）疲软的；失去创造力的；陈旧的，不再有趣的；不再有激情的 portionn. 一部分；（食物的）一（人）份 idealadj. 理想的，完美的，称心如意的，最佳的 n. 理想；模范，完美的典范 roastv. 烤，炙；烘（食物，尤指肉） adj. 烘烤的，烤过的 n. 烤肉，烘烤 inevitableadj. 必然发生的；不可避免的 evidence n.证据 vt.证明;表明;作为…的证据 evident adj.明显的 contendv. 声称；主张；辩论；争夺；竞争 con 共同 + tend 伸展 → 一起伸展〔个人观点〕→ 争论 candidaten. 待选人（或物）；考生；求职申请人；选举候选人 definiteadj. 明确的，确定无疑的 define n.定义 acceleratev. 加速，加快 decelerate v.减速 moderateadj. 中等的，普通的，一般的；平庸的；适度的；温和的 v. （使）变和缓；减轻，减弱；（使）变温和 medium adj.中等的 n.传媒、手段、工具 illusionn. 幻觉，错觉；错误的观念；错误的理解 reality n.现实 transmitv. 传送，输送，传递；传达，传递（思想，情感）；表达；发送信号；传导（声、电等） transplant v. 移植；移栽；移居，迁居 quantifyv. 表示（或测量）…的数量，量化 capacityn. 能力，才能；理解能力；身份，角色，职位；生产量，生产力；容量 8.9neglectv. 忽视，忽略；疏忽；疏漏 n. 忽视，疏忽，忽略 neg 否认，拒绝 + lect 选择 → 拒绝选择 → 忽视 ignore overlook v.忽视 gangn. （有轻微罪行或暴力行为的）一群年轻人 vi. 聚集，结成一伙伙伴👨‍👩‍👧‍👦 compensationn. 补偿物，赔偿物（尤指赔偿金）；薪水；工资；使坏的情况变好的事物💴 com（全部）+pens（花费）+ate（做）——补偿 reparation n.赔偿，补偿 commandern. 指挥官，司令员;（英国或美国）海军中校, （英国）伦敦高级警官 revealv. 透露，暴露，泄露，揭露（先前未知或秘密信息）；使显露，展现，显示 illustrationn. （书、报纸等的）插图；例证；说明，图解 illustrate v.举例说明, （为书）作插图, 图解 illusion n. 幻觉，错觉；错误的观念；错误的理解 realmn. 界，领域，范围；王国 gazev. 凝视，注视 n. 凝视 stare vi.盯着看;凝视;注视 daze n.迷惑;恍惚;迷乱;茫然 behavev. （机器）运转，（自然现象）起作用；待人接物；以某种态度对待；表现；守规矩，举止得体 behaviour n.行为、举止、态度 violatev. 违反，违背；侵犯；使人不得安宁；亵渎，污损；强奸 violence n.暴力 transplantv. 移植；移栽；移居，迁居 transplantation n.移民 immigrate v.移民 counseln. 劝告，忠告，建议；法律顾问；律师 v. 给（某人）专业的心理指导（或咨询）；劝告；建议 consulate领事；领事馆 consult vi. 请教；商议；当顾问 consultant n. 顾问；咨询者；会诊医生 hauntv. （尤指在脑际）萦绕；（鬼魂）出没；长期不断地缠扰（某人） n. 常去的场所，消磨时光的去处 fatiguen. 极度疲劳，疲乏，劳累；（肌肉或器官的）疲劳；劳损；（因接触过多导致的）反应迟钝，热情减退 driftv. 漂流；漂泊；进入（某种状态）；慢慢移动 n. 漂流，移动 tacklev. 处理，决心处理（问题，难题）；阻截；与某人交涉 n. 用具；阻截；阻截铲球 cope handle polln. （opinion poll的简称）民意测验，民意调查；投票数；得票 v. 做民意调查；记票 pull poll stacksn.一摞、一堆 v.使整齐地堆起，叠起F trackv.跟踪、追踪 n.小路、小径、踪迹 suspicionn.怀疑;嫌疑;感觉;看法;猜疑;不放心 removedadj.相异的、不同的 v.移走、去掉 distinct adj.不同的、明显的、确切的 distinction n.不同、差异、卓越 miserableadj.令人不快的、痛苦的 watch one’s back小心背后〈因可能有人暗算〉 existv.存在;实际上有;(尤指在困境或贫困中)生活，生存 contractn.合同;合约;契约;(雇用杀人的)协议v.(使)收缩，缩小;感染(疾病);得(病);与…订立合同(或契约) 8.10assumev. 认为; 假定, 假设; 承担(责任); 就职; 呈现 abuses v.谩骂、滥用 competev. 竞争，角逐；比赛 competitive adj.与竞争有关的、竞争性的 complete v.完成 completely adv.彻底地 expressionn. 表达；陈述；（艺术作品或乐曲演奏中的）感情传达；表情；词句，措词；表达方式；措辞 express v.表达 press v.压 recessionn. （经济的）衰退（期） cess 词根走 re往回cess走ion recess n.休会;休会期 v.休会;暂停; beneathprep. 在下方，在…之下 adv. 在下方 inflationn. 【经济】通货膨胀；膨胀；充气 flation n. 物价稳定；平稳时期；通货稳定时期 flat adj.平的;水平的;平滑的n.公寓;一套房间;单元房;(某物的)平面部分;(尤指水边的)平地;低洼地 spurn. 刺激物 vt. 促进；促使；刺激；激励；鼓励；鞭策 severeadj. （不好或可厌之物）非常的；严重的；（对人的处罚）严厉的，苛刻的；剧烈的 serious adj.严重的 service n.服务 v.维修 serve v.端上、服务 survival n.生存、存活 exist v.存在、生存 exit n.出口 v.退出 edit v、n.编辑 glancen. 一瞥；扫视 v. 一瞥；扫视 bumpn. （非正式，主北美） 增加；撞击，碰撞；隆起，凸块；肿块 v. 偶尔遇见，邂逅；碰撞，撞上；颠簸而行 lump n.块、隆起、笨重的人 declinev. 减弱，下降；恶化；谢绝，婉言拒绝；（尤指好的事物）变小，减少 n. 日渐衰弱，持续减少，不断下降 deadline n.截止日期 clingvi. 坚持，墨守；牢牢粘住；难以除去；黏着，缠着，紧紧握着 strive v. 努力，奋斗，力争 struggle v/n.奋斗、努力✊ responsibleadj. 对（行为）负道德责任的，有责任感的；负责…的；对…有责任的，有义务的；应受责备；可信任的；引起…的 response n.回答、答复 gluen. 胶；胶水 v. 用胶水粘合；粘牢，粘贴；【非正式】专注于（尤指电视机） gule to 盯着（电视机） 8.11flourn.(尤指小麦的)面粉;(谷物磨成的)粉vt.在…上撒(或覆以)面粉 food made from flour 面食 account for a large proportion of占有很大比例 dairyadj.乳品的;牛奶的;奶制的;乳品业的;生产乳品的n.牛奶场;乳品场;乳品公司;乳品店;(当地的)小商店 have a sweet tooth爱吃甜食 peculiaradj.特有的;奇怪的;怪异的;不寻常的;(某人、某地、某种情况等)特殊的;不适;不舒服 particularadj.专指的，特指的(与泛指相对);不寻常的;格外的;特别的;讲究;挑剔n.(正式记下的)细节;详情;详细资料;详细介绍材料 distinct adj.不同的 bargainn.减价品;便宜货;协议;交易vi.(与某人就某事)讨价还价，商讨条件 strategyn.策略;计策;行动计划;策划;规划;部署;统筹安排;战略;战略部署 trapn.陷阱;圈套;(捕捉动物的)罗网;夹;捕捉器;诡计;(难以逃脱的)困境;牢笼vt.使落入险境;使陷入困境;卡住;夹住;绊住;缠住;收集;吸收 leap 跳 address英 [əˈdres] 美 [əˈdres]n.住址;地址;通信处;(互联网等的)地址;演说;演讲vt.写(收信人)姓名地址;致函;演说;演讲;向…说话、忙于 conceptn.概念、观念 leapv.跳;跳跃;跳越;猛冲;突然做(某事);骤增;剧增;猛涨n.跳越;跳跃;跳高;骤变;剧增;激增 disordern.混乱;紊乱;疾病;失调;杂乱;凌乱;骚乱;动乱;不适 registerv. 登记，注册，记录 n. 登记本；注册簿；（官方）记录 resign v.辞职 designer n.设计师 adj.名牌的 persistencen. 坚持不懈；执意；维持，持续存在 persistent adj.持久的、坚持不懈的 persist v.坚持 per自始至终sist站立–&gt;坚持 exclusiveadj. 独有的；独享的；独家的；专用的；排斥性的；排他性的；奢华的；孤傲的 n. 独家新闻; 独家专访; 孤傲的人 exclude v.排除、防止…进入 include v.包括 inclusive adj.包含全部费用、范围广泛的 financen. 财源；（国家的）岁入；财务状况；（尤指政府或大公司的）财政；金融 v. 为（个人，企业）供给资金 countern. （商店，银行，餐厅的）柜台；计数器 v. 反驳；抵消 adv. 相反地；对立地 volumen. 量, 额; 体积; 容积, 容量; 音量; 卷, 册; 合订本; 大量, 许多 slidev. (使)滑行, (使)滑动; (使)悄悄移动; 下滑; 滑落; 逐渐陷入; 逐渐恶化或退步 n. 滑梯; 衰落, 降低; 山崩, 崩塌; 幻灯片 radicaladj. （尤指变化或行动）根本的；意义深远的，彻底的；反传统的；创新的，革新的；非正统的；过激的；激进的，激进派的 n. 激进分子；游离基，自由基 waren. 商品；用某材料制造的物品；作…用的器皿 refinev. 精炼，提炼；精制；改善；加工，深化（尤指理论或方法） abstractadj. 抽象的，理论上的；不切实际的 n. （文献等的） 摘要，概要 v. 提取，抽取；抽象化，从理论上（或孤立地）考虑 8.13categoryn. 种类，类别；【哲】范畴 catalog 目录、一系列 mechanicsn. 力学；结构；技巧；机械学；操作方法 satelliten. 人造卫星；卫星；（作定语）卫星传送的；使用卫星技术的；与卫星技术有关的 virtuallyadv. 几乎；差不多；实际上，事实上 indicatev. 表明；强烈暗示；简要陈述；指出，指示；象征 carriern. 通讯公司；运输工具 carriage n. 四轮马车,车厢 career n. 生涯, 职业 cancer 癌症 disposev. 丢掉；处理；应付，解决；使倾向于 rationaladj. 理性的，理智的；明事理的；基于理性的，合理的；基于逻辑的，合乎逻辑的；神智健全的；有理数的 decent adj.得体的;像样的;正派的;相当不错的;尚好的;公平的;合乎礼节的;合宜的;适当的 commitv. 犯（错，罪）；干（坏事）；献身；投入；把（某事物）移交（给…保管）；转化成（某一状态）；使（人，组织）作出保证；使承担义务；约束 be committed to致力于；委身于；以…为己任 splitvt. (过去式&amp;过去分词:split)劈开; 切开; 撕裂; 分担; 分得; 使分裂; 使不团结; [化]分解; [核]使产生核裂变 vi. 被劈开; 裂开; 被撕裂; 破裂; 分裂; 断绝关系; 打成平局 n. 劈开; 分割; 裂口; 裂缝; 分裂; 派系; 裂片; 薄片; 劈叉; 平局 split up 分手 liableadj. 有义务的，（应）负有法律责任的；可能遭受；有…倾向的 tend dispose multipleadj. 许多，多种多样的 n. 倍数 perceivev. 把（人，物）看作，认为；察觉，感觉，认知；认识到，意识到；理解 deceive欺骗 perceive知觉；发觉 receive接受；收到 vesseln. 脉管，血管；船，舰；容器，器皿 democraticadj. （与）民主（有关）的 democracy .n.民主，民主制，民主制国家 democrat . n. 民主主义者 flockn. 一群；软填料；短绒 v. （鸟）聚集成群，群集，聚集；成群结队前往，蜂拥而至 consentn. 同意，赞成，准许 v. 同意，允许 approve v.同意、认可 contend v.竞争、声称、主张 compete v.竞争 8.14steepadj. （斜面，楼梯，角度）陡的，陡峭的，陡直的；（某种程度的升降）急遽的，大起大落的；〈非正式〉（价格，需求）难以接受的；过高的 n. 峭壁 v. 浸泡，浸透；【喻】使沉浸，使沉湎 crushv. 压碎；压坏；压扁；镇压，征服 n. 迷恋，暗恋 crash 碰撞、撞击 reinforcev. 加强，加固；强化；（感情，看法，习惯）增进，加深 herdn. 人群；（尤指有蹄的哺乳动物）兽群，牧群 v. 放牧；【贬】（人或动物）成群移动 blendv. 融入…，（与…）融为一体；使混合，使交融 n. 混合 blind 瞎的、盲目的 receiptn. 发票；收据 operationaladj. 操作上的，运作中的；（企业）经营的；（机器）运转的 approvaln. 批准，认可，同意，赞同 idlev. 游手好闲；虚度，浪费 adj. 空闲的；懒散的；（人）无业的，失业的 territoryn. 领土，版图，领地；（知识）领域，范围 terrible 可怕的 恐惧的 terrorism 恐怖主义 territory 领土 范围 graven. 墓穴；坟墓 adj. 严峻的；重大的；严重的；严肃的 amidprep. 在…气氛中；在…背景下；在…之中 faren. 公共交通费；车费；船费；飞机票价；出租车乘客；（尤指某类型的）系列食物 vi. 吃，进食；过活，生活；（在某情况下或某时间内以某方式）做，干，进行，进展；成功 marginaladj. 次要的，不重要的；非主要的；（指税款）同收入增长有关的 margin 边缘 pedestriann. 行人，步行者 adj. 行人的；缺乏想象力的，平淡无奇的，乏味的 ped（脚，儿童，教育）+ str（street）+ ian（人） labeln. 标签，签条；标记，符号；（某人或物的）称号；绰号 vt. 给…贴标签；把…归类，把…列为 steerv. 驾驶（车辆、船舶或飞机）；指导，引导；控制, 操纵 n. 建议, 劝告, 忠告, 阉公牛 counsel n.劝告 shrinkv. （使）缩水；变小；减少；（尤指人的脸部或其他身体部位因衰老或疾病而）萎缩；起皱纹；皱缩；（使）退缩；（使）畏缩；（使）贬值；回避 n. 退缩, 畏缩；缩水, 皱缩；&lt;口&gt;精神病医生, 精神病学家","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"英语","slug":"英语","permalink":"https://youngsay.cn/tags/%E8%8B%B1%E8%AF%AD/"}]},{"title":"移动web开发——flex布局","slug":"flex","date":"2021-07-26T10:25:01.000Z","updated":"2021-07-26T10:44:47.549Z","comments":true,"path":"2021/07/26/flex/","link":"","permalink":"https://youngsay.cn/2021/07/26/flex/","excerpt":"","text":"flex 是 flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为 flex 布局。 当我们为父盒子设为 flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。 给父盒子添加flex属性，来控制子盒子的位置和排列方式 父项常见属性 flex-direction：设置主轴的方向 justify-content：设置主轴上的子元素排列方式 flex-wrap：设置子元素是否换行 align-content：设置侧轴上的子元素的排列方式（多行） align-items：设置侧轴上的子元素排列方式（单行） flex-flow：复合属性，相当于同时设置了 flex-direction 和 flex-wrap flex-direction设置主轴方向，在flex布局中分为主轴和侧轴（x、y轴），默认主轴是x轴，水平向右。 1234flex-direction: row; /*主轴为x轴，从左到右*/flex-direction: row-reverse; /*，主轴为x轴，从右到左*/flex-direction: column; /*主轴为y轴，从上到下*/flex-direction: column-reverse; /*，主轴为y轴，从下到上*/ justify-content设置主轴上子元素的排列方式，使用该属性前要先定好主轴。 12345justify-content: flex-start;/*从前开始*/justify-content: flex-end;/*从后开始*/justify-content: center;/*居中对齐*/justify-content: space-around;/*平分剩余空间*/justify-content: space-between;/*★两边贴边后再平分剩余空间*/ flex-wrapflex中项目默认都排列在一行，通过flex-wrap属性可换行 12flex-wrap: nowrap;/*默认值，不换行*/flex-wrap: wrap;/*换行*/ align-items设置侧轴上子元素的排列方式，在子项为单行时使用 12345align-items: flex-start;(flex-end/center/streth)/*flex-start 从头部开始flex-end 从尾部开始center 居中显示stretch 拉伸*/ align-content设置侧轴上子元素的排列方式，在子项为多行时使用 1align-content: flex-start; align-items 适用于单行情况下， 只有上对齐、下对齐、居中和 拉伸 align-content适应于换行（多行）的情况下（单行情况下无效）， 可以设置 上对齐、下对齐、居中、拉伸以及平均分配剩余空间等属性值。 总结:单行用align-items，多行用 align-content flex-flowflex-direction和flex-wrap的符合属性 1flex-flow: row wrap;/*主轴为x轴，换行*/ 子项常见属性 flex子项目占的份数 align-self控制子项自己在侧轴的排列方式 order属性定义子项的排列顺序（前后顺序） flexflex 属性定义子项目分配剩余空间，用flex来表示占多少份数。 123.item &#123; flex: &lt;number&gt;; /* 默认值 0 */&#125; align-selfalign-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。 默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。 123span:nth-child(2) &#123; align-self: flex-end;&#125; orderorder属性定义项目的排列顺序，数值越小，排列越靠前，默认为0。和 z-index 不同。 123.item &#123; order: &lt;number&gt;;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"css","slug":"css","permalink":"https://youngsay.cn/tags/css/"}]},{"title":"移动web开发","slug":"viewport","date":"2021-07-25T10:25:01.000Z","updated":"2021-07-25T10:25:36.638Z","comments":true,"path":"2021/07/25/viewport/","link":"","permalink":"https://youngsay.cn/2021/07/25/viewport/","excerpt":"","text":"meta标签为使网站在移动端有理想的阅读宽度，需添加meta标签。 meta标签的目的：使布局视口的宽度与理想视口的宽度一致，简单理解就是设备有多宽，我们布局的视口就多宽。 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no,maximum-scale=1.0,minimum-scale=1.0&quot;&gt; width - viewport的宽度，width=device-width页面适应设备宽度 initial-scale - 初始的缩放比 minimum-scale - 允许用户缩放到的最小比例 maximum-scale - 允许用户缩放到的最大比例 user-scalable - 用户是否可以手动缩放，yes or no（1或0） 二倍图物理像素&amp;物理像素比CSS 像素：又称为虚拟像素、设备独立像素或逻辑像素，也可以理解为直觉像素。CSS 像素是 Web 编程的概念，指的是 CSS 样式代码中使用的逻辑像素。 iPhone 6 的 CSS 像素数为 375 x 667px。 物理像素：指屏幕显示的最小颗粒从屏幕在工厂生产出的那天起，它上面设备像素点就固定不变了。 iPhone 6 的物理像素为 750 x 1334 物理像素比：物理像素 / CSS 像素，这里的 CSS 像素其实是理想视口。iPhone 6 物理像素为 750 x 1334，理想视口 375 x 667 ，DPR = 2 对于一张 50px * 50px 的图片,在手机或 Retina 屏中打开，按照刚才的物理像素比会放大倍数，会造成图片模糊。在标准的viewport设置中，使用倍图来提高图片质量，解决在高清设备中的模糊问题。 背景缩放background-sizebackground-size 属性规定背景图像的尺寸 1background-size: 背景图片宽度 背景图片高度; 单位可以是 长度、百分比、cover、contain; 移动端开发常见布局移动端单独制作 流式布局（百分比布局） flex 弹性布局 less+rem+媒体查询布局 混合布局 响应式 媒体查询 bootstarp css3盒子模型传统模式宽度计算：盒子的宽度 = CSS中设置的width + border + padding CSS3盒子模型：盒子的宽度= CSS中设置的宽度width 里面包含了 border 和 padding CSS3中的盒子模型， padding 和 border 不会撑大盒子 1234/*CSS3盒子模型*/box-sizing: border-box;/*传统盒子模型*/box-sizing: content-box; 特殊样式123456789/*CSS3盒子模型*/ box-sizing: border-box; -webkit-box-sizing: border-box; /*清除高亮,设置为transparent 完成透明*/ -webkit-tap-highlight-color: transparent; /*在移动端浏览器默认的外观在iOS上加上这个属性才能给按钮和输入框自定义样式*/ -webkit-appearance: none; /*禁用长按页面时的弹出菜单*/ img,a &#123; -webkit-touch-callout: none; &#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"css","slug":"css","permalink":"https://youngsay.cn/tags/css/"}]},{"title":"暑假，目的论，自卑情结","slug":"summer","date":"2021-07-21T05:45:01.000Z","updated":"2021-07-21T07:17:25.155Z","comments":true,"path":"2021/07/21/summer/","link":"","permalink":"https://youngsay.cn/2021/07/21/summer/","excerpt":"","text":"7月7日回到家，8.26号返校，不知不觉已经在家呆14天了，还有一个月就大二了…… 正如李宗盛《给自己的歌》中写道：“等你发现时间是贼了，它早已偷光你的选择”。想到第一次去学校的场景，现在还历历在目，一年的时间已经溜走，大学已完成了1/4，大学中能做的选择也已被偷走了1/4。 沉湎于过去毫无意义，过去已经不属于我了，我拥有的只有现在。我的人生就取决于当下。 《被讨厌的勇气》里有这样一段： 我有一位年轻朋友，虽然梦想着成为小说家，但却总是写不出作品。他说是因为工作太忙、写小说的时间非常有限，所以才写不出来作品，也从未参加过任何比赛。但真是如此吗？实际上，他是想通过不去比赛这一方式来保留一种“如果做的话我也可以”的可能性，即不愿出去被人评价，更不愿去面对因作品拙劣而落选的现实。他只想活在“只要有时间我也可以、只要环境具备我也能写、自己有这种才能”之类的可能性中。或许再过5年或者10年，他又会开始使用“已经不再年轻”或者“也已经有了家庭”之类的借口。 阿德勒心理学不同于弗洛伊德的“原因论”，ta主张的是“目的论”。一件事的结果不是由原因决定的，而是由目的决定的。上面的案例，那位梦想成为小说家的年轻人不能写出作品、没有参加过比赛并不是由时间太忙导致的，而是由他的目的决定的。他最直接的目的就是不想写小说、不想参加比赛。 我们做一件事也要以目的为导向，不能成为“原因论”的信徒。如果那位年轻人一直以“没有时间”为原因，他就永远写不出小说。如果一位有着心理创伤、恐惧出门的朋友一直以“受到过心理创伤”为原因就永远不能走出家门。 这就告诉我们过去怎样并不重要，决定我们人生的只有现在。所以做好手头的事、过好当下的每一天就够了。很流行的那句话“不念过去，不畏将来”不也是说的这个道理吗？ 书中还有一部分提到了自卑感和自卑情结，这对我很有启发。 阿德勒认为，自卑感不是一件坏事。人是作为一种无力的存在活在这个世界上。并且，人希望摆脱这种无力状态，继而就有了普遍欲求。阿德勒称其为“追求优越性”。 人都处于追求优越性这一“希望进步的状态”之中，树立某些理想或目标并努力为之奋斗。同时，对于无法达成理想的自己就会产生一种自卑感。例如，越是有远大志向的厨师也许就越会产生“还很不熟练”或者“必须做出更好的料理”之类的自卑感。 所以说我们要正视自卑，利用自卑感，使之成为努力和成长的催化剂。 你也许会说，自卑感越强，人就会变得越消极，最终肯定会认为自己一无是处。这不是自卑感，而是自卑情结。 这一点请注意。目前“自卑情结”这个词似乎在使用的时候与自卑感是一样的意思。就像“我为自己的单眼皮感到自卑”或者“他对自己的学历有自卑感”之类的描述中全都用“自卑情结”这个词来表示自卑感。其实，这完全是一种误用。自卑情结一词原本表示的是一种复杂而反常的心理状态，跟自卑感没有关系。例如，即使弗洛伊德提出的“俄狄浦斯情结”原本也是指一种对同性父母亲的反常对抗心理。 我理解的是自卑感不是坏事，而有了自卑情结是坏事。自卑情结是把自己的自卑当作一种借口。“因为我没有时间所以我写不出文章”“因为我小时候受过心理创伤所以不敢走出家门”，这都是在以自卑为借口，这是一种自卑情结。 虽然写不出作品和没有时间有一定关系，不出门与心理创伤有关，但这都不是必然联系。阿德勒用“外部因果律”来说明，就是说将原本没有任何因果关系的事情解释成似乎有重大因果关系一样。就像哲学中的主次矛盾，你一直以没有时间，以心理创伤为由，但这只是次要矛盾，甚至连矛盾都不算。如果抱着“因为我没有时间所以我写不出文章”之类的想法，那就不是“没时间写文章”而是“不想写文章”了。","categories":[{"name":"日常","slug":"日常","permalink":"https://youngsay.cn/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"元素显示与隐藏","slug":"visibility","date":"2021-06-16T14:00:01.000Z","updated":"2021-06-16T14:13:38.524Z","comments":true,"path":"2021/06/16/visibility/","link":"","permalink":"https://youngsay.cn/2021/06/16/visibility/","excerpt":"","text":"类似网站中的广告，点击关闭时消失，重新刷新页面再出现。 本质：让一个元素在页面中隐藏或者显示出来。 displaydisplay: none ；隐藏对象 display：block ；显示元素/转换为块元素 display 隐藏元素后，不再占有原来的位置。 visibilityvisibility：visible; 元素可视 visibility：hidden; 元素隐藏 visibility 隐藏元素后，仍占有原来的位置。 overflowoverflow 属性指定在元素的内容太大而无法放入指定区域时是剪裁内容还是添加滚动条。 overflow 属性可设置以下值： visible - 默认。溢出没有被剪裁。内容在元素框外渲染 hidden - 溢出被剪裁，其余内容将不可见 scroll - 溢出被剪裁，同时添加滚动条以查看其余内容 auto - 与 scroll 类似，但仅在必要时添加滚动条 注释：overflow属性仅适用于具有指定高度的块元素。","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"css","slug":"css","permalink":"https://youngsay.cn/tags/css/"}]},{"title":"css定位","slug":"position","date":"2021-06-12T05:49:01.000Z","updated":"2021-06-16T12:54:55.092Z","comments":true,"path":"2021/06/12/position/","link":"","permalink":"https://youngsay.cn/2021/06/12/position/","excerpt":"","text":"定位 浮动可以让多个块级盒子一行没有缝隙排列显示， 经常用于横向排列盒子。 定位则是可以让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置，并且可以压住其他盒子。 定位=定位模式+边偏移 定位模式用于指定一个元素在文档中的定位方式。边偏移则决定了该元素的最终位置。 定位模式1234position: static; /*静态定位*/position: relative; /*相对定位*/position: absolute; /*绝对定位*/position: fixed; /*固定定位*/ 边偏移1234top: 20px; /*顶级偏移量，定义元素相对于父元素上边距的距离*/bottom: 20px; /*底部偏移量，定义元素相对于父元素下边距的距离*/left: 20px; /*左侧偏移量，定义元素相对于父元素左边距的距离*/right: 20px; /*右侧偏移量，定义元素相对于父元素右边距的距离*/ static静态定位是元素的默认定位方式，无定位的意思。 1选择器 &#123; position: static; &#125; 静态定位按照标准流特性摆放位置，它没有边偏移 静态定位在布局时很少用到relative相对定位的偏移量相对于自身位置移动1选择器 &#123;position: relative&#125;; 原来在标准流的位置继续占有，后面盒子仍以标准流方式对待它。absolute绝对定位的偏移量相对于父级元素移动。1选择器 &#123; position: absolute; &#125; 当没有父级元素或父级元素没有定位时，以浏览器来偏移。 绝对定位不占有原先位置（脱标）子绝父相 子级绝对定位，不会占有位置，可以放到父盒子里面的任何一个地方，不会影响其他的兄弟盒子。 父盒子需要加定位限制子盒子在父盒子内显示。 父盒子布局时，需要占有位置，因此父亲只能是相对定位。fixed固定定位是元素固定于浏览器可视区的位置。在浏览器页面滚动时不改变元素位置。1选择器 &#123; position: fixed; &#125; 固定定位不占有原先位置（脱标） 小技巧：固定在版心右侧小算法： 让固定定位的盒子 left: 50%. 走到浏览器可视区（版心） 的一半位置。 让固定定位的盒子 margin-left: 版心宽度的一半距离。 多走版心宽度的一半位置就可以让固定定位的盒子贴着版心右侧对齐了。 总结 定位叠放次序 z-index在使用定位布局时，可能会出现盒子重叠的情况。此时，可以使用 z-index 来控制盒子的前后次序 (z轴)。 1z-index: auto; 数值可以是正整数、负整数或 0, 默认是 auto，数值越大，盒子越靠上。 如果属性值相同，则按照书写顺序，后来居上。 数字后面不能加单位。 只有定位的盒子才有 z-index 属性。 拓展绝对定位盒子居中加了绝对定位的盒子不能通过 margin:0 auto 水平居中 居中方法与【小技巧：固定在版心右侧】相似 ① left: 50%;：让盒子的左侧移动到父级元素的水平中心位置。 ② margin-left: -100px;：让盒子向左移动自身宽度的一半 定位特殊特性绝对定位和固定定位也和浮动类似。 行内元素添加绝对或者固定定位，可以直接设置高度和宽度。 块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小。 外边距塌陷脱标的盒子不会触发外边距塌陷。浮动元素、绝对定位(固定定位）元素的都不会触发外边距合并的问题。 绝对定位（固定定位）会完全压住盒子 浮动元素只会压住它下面标准流的盒子，但是不会压住下面标准流盒子里面的文字（图片）。 绝对定位（固定定位） 会压住下面标准流所有的内容。 浮动之所以不会压住文字，因为浮动产生的目的最初是为了做文字环绕效果的。 文字会围绕浮动元素。","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"css","slug":"css","permalink":"https://youngsay.cn/tags/css/"}]},{"title":"css浮动","slug":"float","date":"2021-06-05T15:31:01.000Z","updated":"2021-06-06T03:37:55.294Z","comments":true,"path":"2021/06/05/float/","link":"","permalink":"https://youngsay.cn/2021/06/05/float/","excerpt":"","text":"网页布局 标准流 块级元素：独占一行，从上向下顺序排列。常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table 行内元素：按照顺序从左到右顺序排列，碰到父元素边缘则自动换行。常用元素：span、a、i、em等以上都是标准流布局，标准流是最基本的布局方式。 浮动 定位 浮动float属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及包含块或另一个浮动框的边缘。 1float: left; /*right/none*/ 浮动和标准流的父盒子搭配。 先用标准流的父元素排列上下位置, 之后内部子元素采取浮动排列左右位置 一个元素浮动了，理论上其余的兄弟元素也要浮动。一个盒子里面有多个子盒子，如果其中一个盒子浮动了，那么其他兄弟也应该浮动，以防止引起问题。 浮动的盒子只会影响浮动盒子后面的标准流,不会影响前面的标准流。 清除浮动为什么要清除浮动由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为 0 时，就会影响下面的标准流盒子。 清除浮动本质 清除浮动的本质是清除浮动元素造成的影响 如果父盒子本身有高度，则不需要清除浮动 清除浮动之后，父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了 清除浮动额外标签法额外标签法也称为隔墙法，是 W3C 推荐的做法。 额外标签法会在浮动元素末尾添加一个空的标签。 1&lt;div style=&quot;clear: both&quot;&gt;&lt;/div&gt; 优点： 通俗易懂，书写方便 缺点： 添加许多无意义的标签，结构化较差 注意： 要求这个新的空标签必须是块级元素。 父级添加overflow给父级添加 overflow 属性，将其属性值设置为 hidden、 auto 或 scroll 优点：代码简洁 缺点：无法显示溢出的部分 :after伪元素法给父元素添加 12345678910.clearfix:after &#123; content: &quot;&quot;; display: block; height: 0; clear: both; visibility: hidden; &#125; .clearfix &#123; /* IE6、7 专有 */ *zoom: 1;&#125; 优点：没有增加标签，结构更简单 缺点：照顾低版本浏览器 代表网站： 百度、淘宝网、网易等 双伪元素法给父元素添加 12345678910.clearfix:before,.clearfix:after &#123; content:&quot;&quot;; display:table; &#125;.clearfix:after &#123; clear:both;&#125;.clearfix &#123; *zoom:1;&#125; 优点：代码更简洁 缺点：照顾低版本浏览器 代表网站：小米、腾讯等 总结","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"css","slug":"css","permalink":"https://youngsay.cn/tags/css/"}]},{"title":"盒子边框","slug":"box","date":"2021-06-03T05:25:01.000Z","updated":"2021-06-05T13:02:29.279Z","comments":true,"path":"2021/06/03/box/","link":"","permalink":"https://youngsay.cn/2021/06/03/box/","excerpt":"","text":"边框12345border-width/*定义边框粗细，单位px*/border-style /*边框样式 solid实先 dashed虚线 dotted点线 */border-color /*边框颜色*/border: 1px solid red; /*简写*/border-collapse:collapse; /*表示相邻边框合并*/ 内边距padding内边距，即边框和内容之间的距离 1234567padding:5px; /*上下左右都有5像素内边距*/padding:5px 10px; /*上下5px，左右10px*/padding:5px 10px 20px; /*上内边距5px，左右10px，下20px*/padding:5px 10px 20px 30px; /*上5，右10，下20，左30*/ 外边距margin 用于设置外边距，即控制盒子和盒子之间的距离。 块级盒子水平居中外边距可以让块级盒子水平居中，但是必须满足两个条件： ①盒子必须指定了宽度（width）。 ②盒子左右的外边距都设置为auto 。 123456789.header&#123; width:960px; margin:0 auto;&#125;/*常见写法：*/margin-left: auto;margin-right: auto;margin: auto;margin: 0 auto; 清除内外边距1234* &#123; padding:0;/*清除内边距*/ margin:0;/*清除外边距*/&#125; 圆角边框1border-radius: length; /*参数值可以为数值或百分比的形式*/ 盒子阴影1box-shadow: h-shadow v-shadow blur spread color inset;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"css","slug":"css","permalink":"https://youngsay.cn/tags/css/"}]},{"title":"typora+picgo+Gitee实现图片上传","slug":"picgo","date":"2021-05-12T07:42:01.000Z","updated":"2021-08-19T07:43:23.070Z","comments":true,"path":"2021/05/12/picgo/","link":"","permalink":"https://youngsay.cn/2021/05/12/picgo/","excerpt":"","text":"Typora 设置上传图片功能，图片可以自动提交到图床，大大提高了工作效率。如何将Typora编辑器中的图片上传到自己的图床，我们将用Typora+PicGo+Gitee实现图片上传。 Gitee1.注册、登录码云Gitee网址：https://gitee.com （注册登录操作不再介绍） 2.创建一个仓库当做图床 注意我标红的地方，然后选择创建就ok了。 3.创建私人令牌找到设置——安全设置——生成新令牌 描述私人令牌，选择projects，提交。**==复制令牌，可以记录在text等地方，稍后会用到。==** PicGo一款可以上传、管理图床的工具，支持腾讯图床、七牛图床等多种图床，可以自己探索。本篇用的是GItee图床。 1.下载、安装PicGo下载地址：https://github.com/Molunerfinn/picgo/releases 选择自己的版本，下载安装即可。 2.安装Gitee插件注：若没有 node.js ，无法安装Gitee插件。官网：https://nodejs.org/zh-cn 下载安装即可。 一切顺利，打开PicGO——插件设置——搜索gitee 有两个插件，任选其一安装即可。==当插件安装不了，一直显示安装中，请执行下面操作。安装成功的可以忽略。== 在搜索中输入cmd，以管理员身份运行命令行提示符（右键–&gt;以管理员身份运行）。 输入：cd &quot;C:\\Users\\用户名\\AppData\\Roaming\\picgo&quot;，进入picgo目录，输入：npm install picgo-plugin-插件名称安装插件。安装gitee插件可直接输入：npm install picgo-plugin-gitee-uploader。 3.配置Gitee插件在PicGo设置中选择Gitee图床 配置图床 后三个配置可以默认，之后点确定就大功告成了。可以手动上传图片了。 Typora1.下载、安装Typora官网地址：https://www.typora.io 2.配置Typora文件——偏好设置——图形 3.上传验证点击验证图片上传选项验证是否配置成功 常见错误1. Failed to fetchPicGo的端口设置错误，打开 PicGo设置 &gt; 设置Service，将端口设置为36677。 2. {“success”,false}文件名重复错误，PicGo设置``中开启时间戳重命名`","categories":[{"name":"分享","slug":"分享","permalink":"https://youngsay.cn/categories/%E5%88%86%E4%BA%AB/"}],"tags":[]},{"title":"每日一道c语言","slug":"c-100","date":"2021-05-08T11:31:01.000Z","updated":"2022-01-23T11:41:10.556Z","comments":true,"path":"2021/05/08/c-100/","link":"","permalink":"https://youngsay.cn/2021/05/08/c-100/","excerpt":"","text":"我又来给自己挖坑了，定个小目标。从今天起每天一道c语言，争取做够100道。 5.8题目：有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？ 程序分析：可填在百位、十位、个位的数字都是1、2、3、4。组成所有的排列后再去 掉不满足条件的排列。 123456789101112131415161718192021#include&lt;stdio.h&gt;int main()&#123; int i, j, k; for (i = 1; i &lt; 5; i++) // 以下为三重循环 &#123; for (j = 1; j &lt; 5; j++) &#123; for (k = 1; k &lt; 5; k++) // 确保i、j、k三位互不相同 &#123; if (i != k &amp;&amp; i != j &amp;&amp; j != k) &#123; printf(&quot;%d%d%d\\n&quot;, i, j, k); &#125; &#125; &#125; &#125; return 0;&#125; 百位有4种选择，为使十位与百位不重复，十位有3种选择，同理，个位有2中选择，总共有4x3x2=24种选择。 5.9题目：企业发放的奖金根据利润提成。 利润(I)低于或等于10万元时，奖金可提10%；利润高于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可提成7.5%；20万到40万之间时，高于20万元的部分，可提成5%；40万到60万之间时高于40万元的部分，可提成3%；60万到100万之间时，高于60万元的部分，可提成1.5%；高于100万元时，超过100万元的部分按1%提成。从键盘输入当月利润I，求应发放奖金总数？ 程序分析：请利用数轴来分界，定位。注意定义时需把奖金定义成长整型。 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;int main()&#123; double i=0; double a = 0; printf(&quot;输入你的利润&quot;); scanf(&quot;%lf&quot;, &amp;i); if (i &lt;= 100000) &#123; a = 0.1 * i; &#125; else if (i &lt;= 200000) &#123; a = 0.1 * 100000 + 0.075 * (i - 100000); &#125; else if (i &lt;= 400000) &#123; a = (i - 200000) * 0.05; &#125; else if (i &lt;= 600000) &#123; a = (i - 400000) * 0.03; &#125; else if (i &lt;= 1000000) &#123; a = (i - 600000) * 0.015; &#125; else if (i &gt; 1000000) &#123; a = (i - 1000000) * 0.01; &#125; printf(&quot;你的净利润为%lf\\n&quot;, i); printf(&quot;你的提成为%lf&quot;, a); return 0;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"c","slug":"c","permalink":"https://youngsay.cn/tags/c/"}]},{"title":"为hexo内的文章加密","slug":"password","date":"2021-05-07T01:58:37.000Z","updated":"2021-05-07T02:03:12.696Z","comments":true,"path":"2021/05/07/password/","link":"","permalink":"https://youngsay.cn/2021/05/07/password/","excerpt":"","text":"最近，我的博客地址被朋友知道了。这使我有些顾虑，写什么也变得不自在。每个人都有秘密，或许藏在心里，或许告诉亲密的人，或许分享给陌生人。 每个人都很难精神裸体，至少我很难。如果我写什么都要被朋友看到，那和发朋友圈有什么区别。于是决定给一些文章加密，密码统一为我全球最大的同性交友网站的用户名（你懂的，手动狗头）。 下面分享一下为hexo内文章加密的一种方法。 安装1npm install --save hexo-blog-encrypt 快速开始在 站点配置文件 中启用该插件: 12encrypt: enable: true 然后在文章头部添加上对应的字段，如 password, abstract, message 123456---keywords: 博客文章密码password: bugaosuniabstract: 这是一篇加密的文章message: 输入密码，查看文章--- password: 博客文章加密使用的密码abstract: 文章摘要，会显示在博客的列表页message: 博客查看时，密码输入框上面的描述性文字","categories":[{"name":"分享","slug":"分享","permalink":"https://youngsay.cn/categories/%E5%88%86%E4%BA%AB/"}],"tags":[]},{"title":"Linux磁盘管理","slug":"filesystem","date":"2021-05-01T04:25:01.000Z","updated":"2021-05-02T10:02:26.855Z","comments":true,"path":"2021/05/01/filesystem/","link":"","permalink":"https://youngsay.cn/2021/05/01/filesystem/","excerpt":"","text":"Linux磁盘管理好坏直接关系到整个系统的性能问题。 Linux磁盘管理常用命令为 df、du。 df ：列出文件系统的整体磁盘使用量 du：检查磁盘空间使用量 dfdf命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。 语法： 1df [-ahikHTm] [目录或文件名] 选项与参数： -a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统； -k ：以 KBytes 的容量显示各文件系统； -m ：以 MBytes 的容量显示各文件系统； -h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示； -H ：以 M=1000K 取代 M=1024K 的进位方式； -T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出； -i ：不用硬盘容量，而以 inode 的数量来显示 测试： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 将系统内所有的文件系统列出来！# 在 Linux 底下如果 df 没有加任何选项# 那么默认会将系统内所有的 (不含特殊内存内的文件系统与 swap) 都以 1 Kbytes 的容量来列出来！[root@kuangshen /]# dfFilesystem 1K-blocks Used Available Use% Mounted ondevtmpfs 889100 0 889100 0% /devtmpfs 899460 704 898756 1% /dev/shmtmpfs 899460 496 898964 1% /runtmpfs 899460 0 899460 0% /sys/fs/cgroup/dev/vda1 41152812 6586736 32662368 17% /tmpfs 179896 0 179896 0% /run/user/0# 将容量结果以易读的容量格式显示出来[root@kuangshen /]# df -hFilesystem Size Used Avail Use% Mounted ondevtmpfs 869M 0 869M 0% /devtmpfs 879M 708K 878M 1% /dev/shmtmpfs 879M 496K 878M 1% /runtmpfs 879M 0 879M 0% /sys/fs/cgroup/dev/vda1 40G 6.3G 32G 17% /tmpfs 176M 0 176M 0% /run/user/0# 将系统内的所有特殊文件格式及名称都列出来[root@kuangshen /]# df -aTFilesystem Type 1K-blocks Used Available Use% Mounted onsysfs sysfs 0 0 0 - /sysproc proc 0 0 0 - /procdevtmpfs devtmpfs 889100 0 889100 0% /devsecurityfs securityfs 0 0 0 - /sys/kernel/securitytmpfs tmpfs 899460 708 898752 1% /dev/shmdevpts devpts 0 0 0 - /dev/ptstmpfs tmpfs 899460 496 898964 1% /runtmpfs tmpfs 899460 0 899460 0% /sys/fs/cgroupcgroup cgroup 0 0 0 - /sys/fs/cgroup/systemdpstore pstore 0 0 0 - /sys/fs/pstorecgroup cgroup 0 0 0 - /sys/fs/cgroup/freezercgroup cgroup 0 0 0 - /sys/fs/cgroup/cpusetcgroup cgroup 0 0 0 - /sys/fs/cgroup/hugetlbcgroup cgroup 0 0 0 - /sys/fs/cgroup/blkiocgroup cgroup 0 0 0 - /sys/fs/cgroup/net_cls,net_priocgroup cgroup 0 0 0 - /sys/fs/cgroup/memorycgroup cgroup 0 0 0 - /sys/fs/cgroup/pidscgroup cgroup 0 0 0 - /sys/fs/cgroup/cpu,cpuacctcgroup cgroup 0 0 0 - /sys/fs/cgroup/devicescgroup cgroup 0 0 0 - /sys/fs/cgroup/perf_eventconfigfs configfs 0 0 0 - /sys/kernel/config/dev/vda1 ext4 41152812 6586748 32662356 17% /systemd-1 - - - - - /proc/sys/fs/binfmt_miscmqueue mqueue 0 0 0 - /dev/mqueuedebugfs debugfs 0 0 0 - /sys/kernel/debughugetlbfs hugetlbfs 0 0 0 - /dev/hugepagestmpfs tmpfs 179896 0 179896 0% /run/user/0binfmt_misc binfmt_misc 0 0 0 - /proc/sys/fs/binfmt_misc# 将 /etc 底下的可用的磁盘容量以易读的容量格式显示[root@kuangshen /]# df -h /etcFilesystem Size Used Avail Use% Mounted on/dev/vda1 40G 6.3G 32G 17% / duLinux du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的，这里介绍Linux du命令。 语法： 1du [-ahskm] 文件或目录名称 选项与参数： -a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。 -h ：以人们较易读的容量格式 (G/M) 显示； -s ：列出总量而已，而不列出每个各别的目录占用容量； -S ：不包括子目录下的总计，与 -s 有点差别。 -k ：以 KBytes 列出容量显示； -m ：以 MBytes 列出容量显示； 测试： 12345678910111213141516171819202122232425# 只列出当前目录下的所有文件夹容量（包括隐藏文件夹）:# 直接输入 du 没有加任何选项时，则 du 会分析当前所在目录的文件与目录所占用的硬盘空间。[root@kuangshen home]# du16 ./redis8 ./www/.oracle_jre_usage # 包括隐藏文件的目录24 ./www48 . # 这个目录(.)所占用的总量# 将文件的容量也列出来[root@kuangshen home]# du -a4 ./redis/.bash_profile4 ./redis/.bash_logout ....中间省略....4 ./kuangstudy.txt # 有文件的列表了48 .# 检查根目录底下每个目录所占用的容量[root@kuangshen home]# du -sm /*0 /bin146 /boot.....中间省略....0 /proc.....中间省略....1 /tmp3026 /usr # 系统初期最大就是他了啦！513 /var2666 /www 通配符 * 来代表每个目录。 与 df 不一样的是，du 这个命令其实会直接到文件系统内去搜寻所有的文件数据。 磁盘挂载与卸除根文件系统之外的其他文件要想能够被访问，都必须通过“关联”至根文件系统上的某个目录来实现，此关联操作即为“挂载”，此目录即为“挂载点”,解除此关联关系的过程称之为“卸载” Linux 的磁盘挂载使用mount命令，卸载使用umount命令。 磁盘挂载语法： 1mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点 测试： 123456# 将 /dev/hdc6 挂载到 /mnt/hdc6 上面！[root@www ~]# mkdir /mnt/hdc6[root@www ~]# mount /dev/hdc6 /mnt/hdc6[root@www ~]# dfFilesystem 1K-blocks Used Available Use% Mounted on/dev/hdc6 1976312 42072 1833836 3% /mnt/hdc6 磁盘卸载命令 umount 语法： 1umount [-fn] 装置文件名或挂载点 选项与参数： -f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下； -n ：不升级 /etc/mtab 情况下卸除。 卸载/dev/hdc6 1[root@www ~]# umount /dev/hdc6","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://youngsay.cn/tags/linux/"}]},{"title":"Linux用户和用户组的管理","slug":"useradd","date":"2021-04-30T13:23:01.000Z","updated":"2021-05-02T10:01:12.412Z","comments":true,"path":"2021/04/30/useradd/","link":"","permalink":"https://youngsay.cn/2021/04/30/useradd/","excerpt":"","text":"Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。 用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。 每个用户账号都拥有一个唯一的用户名和各自的口令。 用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。 实现用户账号的管理，要完成的工作主要有如下几个方面： 用户账号的添加、删除与修改。 用户口令的管理。 用户组的管理。 一、用户账号管理1、添加账户1useradd 选项 用户名 -c comment 指定一段注释性描述。 -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。 -g 用户组 指定用户所属的用户组。 -G 用户组，用户组 指定用户所属的附加组。 -s Shell文件 指定用户的登录Shell。 -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 1# useradd –d /home/sam -m sam 此命令创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录 /home/sam（/home为默认的用户主目录所在的父目录）。 2、删除帐号如果一个用户的账号不再使用，可以从系统中删除。删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。 删除一个已有的用户账号使用userdel命令，其格式如下： 1userdel 选项 用户名 常用的选项是 -r，它的作用是把用户的主目录一起删除。 例如： 1# userdel -r sam 此命令删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。 3、切换账号1su 用户名 $表示普通用户；#表示超级用户 4、修改帐号修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。 修改已有用户的信息使用usermod命令，其格式如下： 1usermod 选项 用户名 常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。 例如： 1# usermod -s /bin/ksh -d /home/z –g developer kuangshen 此命令将用户kuangshen的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。 5、用户口令的管理用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。 指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。 命令的格式为： 1passwd 选项 用户名 可使用的选项： -l 锁定口令，即禁用账号。 -u 口令解锁。 -d 使账号无口令。 -f 强迫用户下次登录时修改口令。 如果默认用户名，则修改当前用户的口令。 例如，假设当前用户是kuangshen，则下面的命令修改该用户自己的口令： 1234$ passwd Old password:******New password:*******Re-enter new password:******* 如果是超级用户，可以用下列形式指定任何用户的口令： 123# passwd kuangshenNew password:*******Re-enter new password:******* 普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。 为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。 为用户指定空口令时，执行下列形式的命令： 1# passwd -d kuangshen 此命令将用户 kuangshen的口令删除，这样用户 kuangshen下一次登录时，系统就不再允许该用户登录了。 passwd 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录，例如： 1# passwd -l kuangshen 二、用户组的管理每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。 用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。 1、增加用户组1groupadd 选项 用户组 可以使用的选项有： -g GID 指定新用户组的组标识号（GID）。 -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。 1# groupadd group1 此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。 1# groupadd -g 101 group2 此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。 2、删除用户组1groupdel 用户组 3、修改用户组1groupmod 选项 用户组 常用的选项有： -g GID 为用户组指定新的组标识号。 -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。 -n新用户组 将用户组的名字改为新名字 1# groupmod -g 102 group2 此命令将组group2的组标识号修改为102。 1# groupmod –g 10000 -n group3 group2 此命令将组group2的标识号改为10000，组名修改为group3。 4、切换用户组如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。 用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如： 1$ newgrp root 这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。 来源：https://www.runoob.com/linux/linux-user-manage.html","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://youngsay.cn/tags/linux/"}]},{"title":"vim的使用","slug":"vim","date":"2021-04-29T05:25:01.000Z","updated":"2021-05-02T10:00:03.220Z","comments":true,"path":"2021/04/29/vim/","link":"","permalink":"https://youngsay.cn/2021/04/29/vim/","excerpt":"","text":"什么是 vim？Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 vim 是一个程序开发工具而不是文字处理软件。 vim 键盘图： vi/vim 的使用基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。 这三种模式的作用分别是： 命令模式：用户刚刚启动 vi/vim，便进入了命令模式。 此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。 以下是常用的几个命令： i 切换到输入模式，以输入字符。 x 删除当前光标所在处的字符。 : 切换到底线命令模式，以在最底一行输入命令。 若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。 命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。 输入模式在命令模式下按下i就进入了输入模式。 在输入模式中，可以使用以下按键： 字符按键以及Shift组合，输入字符 ENTER，回车键，换行 BACK SPACE，退格键，删除光标前一个字符 DEL，删除键，删除光标后一个字符 方向键，在文本中移动光标 HOME/END，移动光标到行首/行尾 Page Up/Page Down，上/下翻页 Insert，切换光标为输入/替换模式，光标将变成竖线/下划线 ESC，退出输入模式，切换到命令模式 底线命令模式在命令模式下按下:（英文冒号）就进入了底线命令模式。 底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。 在底线命令模式中，基本的命令有（已经省略了冒号）： q 退出程序 w 保存文件 按ESC键可随时退出底线命令模式。 简单的说，我们可以将这三个模式想成底下的图标来表示： vi/vim 按键说明除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。 第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等 移动光标的方法 h 或 向左箭头键(←) 光标向左移动一个字符 j 或 向下箭头键(↓) 光标向下移动一个字符 k 或 向上箭头键(↑) 光标向上移动一个字符 l 或 向右箭头键(→) 光标向右移动一个字符 如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！ [Ctrl] + [f] 屏幕『向下』移动一页，相当于 [Page Down]按键 (常用) [Ctrl] + [b] 屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用) [Ctrl] + [d] 屏幕『向下』移动半页 [Ctrl] + [u] 屏幕『向上』移动半页 + 光标移动到非空格符的下一行 - 光标移动到非空格符的上一行 n 那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20 则光标会向后面移动 20 个字符距离。 0 或功能键[Home] 这是数字『 0 』：移动到这一行的最前面字符处 (常用) $ 或功能键[End] 移动到这一行的最后面字符处(常用) H 光标移动到这个屏幕的最上方那一行的第一个字符 M 光标移动到这个屏幕的中央那一行的第一个字符 L 光标移动到这个屏幕的最下方那一行的第一个字符 G 移动到这个档案的最后一行(常用) nG n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu) gg 移动到这个档案的第一行，相当于 1G 啊！ (常用) n n 为数字。光标向下移动 n 行(常用) 搜索替换 /word 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用) ?word 向光标之上寻找一个字符串名称为 word 的字符串。 n 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！ N 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。 使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！ :n1,n2s/word1/word2/g n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s/vbird/VBIRD/g』。(常用) :1,$s/word1/word2/g 或 :%s/word1/word2/g 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用) :1,$s/word1/word2/gc 或 :%s/word1/word2/gc 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用) 删除、复制与贴上 x, X 在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用) nx n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。 dd 删除游标所在的那一整行(常用) ndd n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用) d1G 删除光标所在到第一行的所有数据 dG 删除光标所在到最后一行的所有数据 d$ 删除游标所在处，到该行的最后一个字符 d0 那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符 yy 复制游标所在的那一行(常用) nyy n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用) y1G 复制游标所在行到第一行的所有数据 yG 复制游标所在行到最后一行的所有数据 y0 复制光标所在的那个字符到该行行首的所有数据 y$ 复制光标所在的那个字符到该行行尾的所有数据 p, P p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用) J 将光标所在行与下一行的数据结合成同一行 c 重复删除多个数据，例如向下删除 10 行，[ 10cj ] u 复原前一个动作。(常用) [Ctrl]+r 重做上一个动作。(常用) 这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！ . 不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用) 第二部分：一般模式切换到编辑模式的可用的按钮说明 进入输入或取代的编辑模式 i, I 进入输入模式(Insert mode)： i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用) a, A 进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用) o, O 进入输入模式(Insert mode)： 这是英文字母 o 的大小写。o 为在目前光标所在的下一行处输入新的一行； O 为在目前光标所在的上一行处输入新的一行！(常用) r, R 进入取代模式(Replace mode)： r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用) 上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！ [Esc] 退出编辑模式，回到一般模式中(常用) 第三部分：一般模式切换到指令行模式的可用的按钮说明 指令行的储存、离开等指令 :w 将编辑的数据写入硬盘档案中(常用) :w! 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！ :q 离开 vi (常用) :q! 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。 注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～ :wq 储存后离开，若为 :wq! 则为强制储存后离开 (常用) ZZ 这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出) ZQ 不保存，强制退出。效果等同于 **:q!**。 :w [filename] 将编辑的数据储存成另一个档案（类似另存新档） :r [filename] 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面 :n1,n2 w [filename] 将 n1 到 n2 的内容储存成 filename 这个档案。 :! command 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！ vim 环境的变更 :set nu 显示行号，设定之后，会在每一行的前缀显示该行的行号 :set nonu 与 set nu 相反，为取消行号！ 特别注意，在 vi/vim 中，数字是很有意义的！数字通常代表重复做几次的意思！ 也有可能是代表去到第几个什么什么的意思。 举例来说，要删除 50 行，则是用 『50dd』 对吧！ 数字加在动作之前，如我要向下移动 20 行呢？那就是『20j』或者是『20↓』即可。 来源：https://www.runoob.com/linux/linux-vim.html","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://youngsay.cn/tags/linux/"}]},{"title":"Linux基础命令(2)","slug":"linux2","date":"2021-04-22T13:07:01.000Z","updated":"2021-05-02T10:08:02.286Z","comments":true,"path":"2021/04/22/linux2/","link":"","permalink":"https://youngsay.cn/2021/04/22/linux2/","excerpt":"","text":"看懂文件属性Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。 在Linux中我们可以使用ll或者ls –l命令来显示一个文件的属性以及文件所属的用户和组，如： 实例中，boot文件的第一个属性用”d”表示。”d”在Linux中代表该文件是一个目录文件。 在Linux中第一个字符代表这个文件是目录、文件或链接文件等等： 当为[ d ]则是目录 当为[ - ]则是文件； 若是[ l ]则表示为链接文档 ( link file )； 若是[ b ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )； 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。 接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。 其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。 每个文件的属性由左边第一部分的10个字符来确定（如下图）： 从左至右用0-9这些数字来表示。 第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。 其中： 第1、4、7位表示读权限，如果用”r”字符表示，则有读权限，如果用”-“字符表示，则没有读权限； 第2、5、8位表示写权限，如果用”w”字符表示，则有写权限，如果用”-“字符表示没有写权限； 第3、6、9位表示可执行权限，如果用”x”字符表示，则有执行权限，如果用”-“字符表示，则没有执行权限。 对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。 同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。 文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。 因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。 在以上实例中，boot 文件是一个目录文件，属主和属组都为 root。 修改文件属性chgrp更改文件属组 1chgrp [-R] 属组名 文件名 -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。 chown更改文件属主，也可以同时更改文件属组 12chown [–R] 属主名 文件名chown [-R] 属主名：属组名 文件名 chmod更改文件9个属性 1chmod [-R] xyz 文件或目录 Linux文件属性有两种设置方法，一种是数字，一种是符号。 Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。 先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下： 1r:4 w:2 x:1 每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为：[-rwxrwx—] 分数则是： owner = rwx = 4+2+1 = 7 group = rwx = 4+2+1 = 7 others= — = 0+0+0 = 0 1chmod 770 filename 查看文件内容概述 Linux系统中使用以下命令来查看文件的内容： cat 由第一行开始显示文件内容 tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！ nl 显示的时候，顺道输出行号！ more 一页一页的显示文件内容 less 与 more 类似，但是比 more 更好的是，他可以往前翻页！ head 只看头几行 tail 只看尾巴几行 你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。 cat由第一行开始显示文件内容 语法： 1cat [-AbEnTv] 选项与参数： -A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已； -b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！ -E ：将结尾的断行字节 $ 显示出来； -n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同； -T ：将 [tab] 按键以 ^I 显示出来； -v ：列出一些看不出来的特殊字符 测试： 12345# 查看网络配置: 文件地址 /etc/sysconfig/network-scripts/[root@kuangshen ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0DEVICE=eth0BOOTPROTO=dhcpONBOOT=yes tactac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如： 1234[root@kuangshen ~]# tac /etc/sysconfig/network-scripts/ifcfg-eth0ONBOOT=yesBOOTPROTO=dhcpDEVICE=eth0 nl显示行号 语法： 1nl [-bnw] 文件 选项与参数： -b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)； -n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ； -w ：行号栏位的占用的位数。 测试： 1234[root@kuangshen ~]# nl /etc/sysconfig/network-scripts/ifcfg-eth01 DEVICE=eth02 BOOTPROTO=dhcp3 ONBOOT=yes more一页一页翻动 在 more 这个程序的运行过程中，你有几个按键可以按的： 空白键 (space)：代表向下翻一页； Enter ：代表向下翻『一行』； /字串 ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字； :f ：立刻显示出档名以及目前显示的行数； q ：代表立刻离开 more ，不再显示该文件内容。 b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。 123[root@kuangshen etc]# more /etc/csh.login....(中间省略)....--More--(28%) # 重点在这一行喔！你的光标也会在这里等待你的命令 less一页一页翻动 以下实例输出/etc/man.config文件的内容： less运行时可以输入的命令有： 空白键 ：向下翻动一页； [pagedown]：向下翻动一页； [pageup] ：向上翻动一页； /字串 ：向下搜寻『字串』的功能； ?字串 ：向上搜寻『字串』的功能； n ：重复前一个搜寻 (与 / 或 ? 有关！) N ：反向的重复前一个搜寻 (与 / 或 ? 有关！) q ：离开 less 这个程序； head取出文件前面几行 语法： 1head [-n number] 文件 选项与参数：**-n** 后面接数字，代表显示几行的意思！ 默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样： 1[root@kuangshen etc]# head -n 20 /etc/csh.login tail取出文件后面几行 语法： 1tail [-n number] 文件 选项与参数： -n ：后面接数字，代表显示几行的意思 默认的情况中，显示最后 10 行！若要显示最后 20 行，就得要这样： 1[root@kuangshen etc]# tail -n 20 /etc/csh.login 拓展：Linux 链接概念Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。 情况下，ln 命令产生硬链接。 硬连接硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。 硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。 软连接另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。 测试： 12345678910[root@kuangshen /]# cd /home[root@kuangshen home]# touch f1 # 创建一个测试文件f1[root@kuangshen home]# lsf1[root@kuangshen home]# ln f1 f2 # 创建f1的一个硬连接文件f2[root@kuangshen home]# ln -s f1 f3 # 创建f1的一个符号连接文件f3[root@kuangshen home]# ls -li # -i参数显示文件的inode节点信息397247 -rw-r--r-- 2 root root 0 Mar 13 00:50 f1397247 -rw-r--r-- 2 root root 0 Mar 13 00:50 f2397248 lrwxrwxrwx 1 root root 2 Mar 13 00:50 f3 -&gt; f1 从上面的结果中可以看出，硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 397247，然而符号连接文件的 inode 节点不同。 12345678910111213# echo 字符串输出 &gt;&gt; f1 输出到 f1文件[root@kuangshen home]# echo &quot;I am f1 file&quot; &gt;&gt;f1[root@kuangshen home]# cat f1I am f1 file[root@kuangshen home]# cat f2I am f1 file[root@kuangshen home]# cat f3I am f1 file[root@kuangshen home]# rm -f f1[root@kuangshen home]# cat f2I am f1 file[root@kuangshen home]# cat f3cat: f3: No such file or directory 通过上面的测试可以看出：当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f1 文件无效； 依此您可以做一些相关的测试，可以得到以下全部结论： 删除符号连接f3,对f1,f2无影响； 删除硬连接f2，对f1,f3也无影响； 删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效； 同时删除原文件f1,硬连接f2，整个文件会真正的被删除。 作者：狂神说","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://youngsay.cn/tags/linux/"}]},{"title":"Linux基础命令(1)","slug":"linux1","date":"2021-04-21T14:57:01.000Z","updated":"2021-05-02T10:07:46.840Z","comments":true,"path":"2021/04/21/linux1/","link":"","permalink":"https://youngsay.cn/2021/04/21/linux1/","excerpt":"","text":"ls列出目录 12[root@VM-16-9-centos /]# ls [-aAdfFhilnrRSt]目录文件 -a：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来 -l ：长数据串列出，包含文件的属性与权限等等数据 1[root@VM-16-9-centos www]# ls -al 将目录下的所有文件列出来(含属性与隐藏档) cd切换目录 Change Directory 1cd [相对路径或绝对路径] 123456#回到自己的家目录，即/root[root@VM-16-9-centos /]# cd ~#回到根目录[root@VM-16-9-centos ~]# cd /#回到上一级[root@VM-16-9-centos /]# cd .. pwd显示目前所在目录 Print Working Directory 12[root@VM-16-9-centos ~]# pwd/root -P：显示出确实的路径，而非使用连接(link) 路径 123456# 单纯显示出目前的工作目录[root@VM-16-9-centos bin]# pwd/bin# 如果是链接，要显示真实地址，可以使用 -P参数[root@VM-16-9-centos bin]# pwd -P/usr/bin mkdir创建新目录 make directory 1mkdir [-mp] 目录名称 -m ：配置文件的权限。直接配置，不需要看默认权限 (umask) 的脸色 -p ：直接将所需要的目录(包含上一级目录)递归创建起来！ 123456# 创建多层目录[root@VM-16-9-centos /]# mkdir -p zhang/zhang/zhang# 创建权限为 rwx--x--x目录[root@VM-16-9-centos home]# mkdir -m 711 test2[root@VM-16-9-centos home]# ls -ldrwx--x--x 2 root root 4096 Mar 12 21:58 test2 rmdir删除空目录 1rmdir [-p] 目录名称 -p：连同上一级空目录一起删除 cp复制文件或目录 12[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)[root@www ~]# cp [options] source1 source2 source3 .... directory -i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用) rm移除文件或目录 1rm [-fir] 文件或目录 -f ：force，忽略不存在的文件，不会出现警告信息； -i ：互动模式，在删除前会询问使用者是否动作 -r ：递归删除,非常危险 12345# 将刚刚在 cp 的实例中创建的 install.sh删除掉！[root@kuangshen home]# rm -i install.shrm: remove regular file ‘install.sh’? y# 如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！# 尽量不要在服务器上使用 rm -rf / mv移动文件或目录，或修改名称 12[root@www ~]# mv [-fiu] source destination[root@www ~]# mv [options] source1 source2 source3 .... directory -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖； -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！ -u ：若目标文件已经存在，且 source 比较新，才会升级 (update) 12345678910111213141516171819# 复制一个文件到当前目录[root@kuangshen home]# cp /root/install.sh /home# 创建一个文件夹 test[root@kuangshen home]# mkdir test# 将复制过来的文件移动到我们创建的目录，并查看[root@kuangshen home]# mv install.sh test[root@kuangshen home]# lstest[root@kuangshen home]# cd test[root@kuangshen test]# lsinstall.sh# 将文件夹重命名，然后再次查看！[root@kuangshen test]# cd ..[root@kuangshen home]# mv test mvtest[root@kuangshen home]# lsmvtest","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://youngsay.cn/tags/linux/"}]},{"title":"css三大特性：层叠性、继承性、优先级","slug":"css-inherit","date":"2021-04-12T10:25:01.000Z","updated":"2021-04-12T12:05:54.488Z","comments":true,"path":"2021/04/12/css-inherit/","link":"","permalink":"https://youngsay.cn/2021/04/12/css-inherit/","excerpt":"","text":"层叠性层叠性指当标签被设置了多个重复的样式时，一个属性会被覆盖。 不考虑优先级，层叠性遵循“就近原则”。如下，最终颜色为绿色。 123456div&#123; color:red;&#125;div&#123; color:green;&#125; 继承性继承性是指子标签没有设置样式时，继承父标签样式。 继承性只适用于字体的颜色，大小、行间距等文本类属性，边框、外边距、内边距、定位、元素高度等与块级相关属性不能继承。 1234567891011121314&lt;html&gt;&lt;head&gt; &lt;style&gt; div&#123;color:green;font-size:20px;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;span&gt; 我是绿色的 &lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 优先级!important &gt; 行内样式 &gt; ID 选择器 &gt; 类(伪元素、伪类、属性)选择器 &gt; 元素选择器 权重相同时，遵循“就近原则”；权重不同时，权重大的生效。 注意：继承的权重为0 权重叠加：div ul li —-&gt; 0,0,0,3.nav ul li —-&gt; 0,0,1,2a:hover —-&gt; 0,0,1,1#first .nav —-&gt; 0,1,1,0","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"css","slug":"css","permalink":"https://youngsay.cn/tags/css/"}]},{"title":"css背景","slug":"background","date":"2021-04-10T05:25:01.000Z","updated":"2021-04-11T03:06:11.464Z","comments":true,"path":"2021/04/10/background/","link":"","permalink":"https://youngsay.cn/2021/04/10/background/","excerpt":"","text":"通过CSS 背景属性，可以给页面元素添加背景样式。背景属性可以设置背景颜色、背景图片、背景平铺、背景图片位置、背景图像固定等。 123456background-color: 颜色值; /*背景颜色*/background-image: url(); /*背景图片*/background-repeat: repeat |no-repeat |repeat-x |repeat-y ; /*背景平铺*/background-position: x y; /*背景位置*/background-attachment: fixed|scroll; /*背景附着*/background: rgba(0,0,0,0.3) /*背景色半透明*/ 背景图片位置 参数是方位名词 如果指定的两个值都是方位名词，则两个值前后顺序无关，比如left top和top left效果一致 如果只指定了一个方位名词，另一个值省略，则第二个值默认居中对齐 参数是精确单位 如果参数值是精确坐标，那么第一个肯定是x 坐标，第二个一定是y坐标 如果只指定一个数值，那该数值一定是x坐标，另一个默认垂直居中 参数是混合单位 如果指定的两个值是精确单位和方位名词混合使用，则第一个值是x坐标，第二个值是y坐标 背景复合写法1background: transparent url(image.jpg) repeat-y fixed top ; 为了简化背景属性的代码，我们可以将这些属性合并简写在同一个属性background 中。从而节约代码量.当使用简写属性时，没有特定的书写顺序,一般习惯约定顺序为：background: 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"css","slug":"css","permalink":"https://youngsay.cn/tags/css/"}]},{"title":"元素显示模式及转换","slug":"display","date":"2021-04-09T05:00:01.000Z","updated":"2021-04-09T05:04:04.596Z","comments":true,"path":"2021/04/09/display/","link":"","permalink":"https://youngsay.cn/2021/04/09/display/","excerpt":"","text":"元素显示模式就是元素（标签）以什么方式进行显示。比如&lt;div&gt;自己占一行，比如一行可以放多个&lt;span&gt;。HTML元素一般分为块元素和行内元素两种类型 块元素常见的块元素有&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;等，其中&lt;div&gt;标签是最典型的块元素。 特点： 自己独占一行。 高度，宽度、外边距以及内边距都可以控制。 宽度默认是容器（父级宽度）的100%。 是一个容器及盒子，里面可以放行内或者块级元素。 注意： 文字类的元素内不能使用块级元素 &lt;p&gt;标签主要用于存放文字，因此&lt;p&gt;里面不能放块级元素，特别是不能放&lt;div&gt; &lt;h1&gt;~&lt;h6&gt;等都是文字类块级标签，里面也不能放其他块级元素 行内元素常见的行内元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt;等，其中&lt;span&gt; 标签是最典型的行内元素。有的地方也将行内元素称为内联元素。 特点： 相邻行内元素在一行上，一行可以显示多个。 高、宽直接设置是无效的。 默认宽度就是它本身内容的宽度。 行内元素只能容纳文本或其他行内元素。 注意： 链接里面不能再放链接 特殊情况链接&lt;a&gt; 里面可以放块级元素，但是给&lt;a&gt;转换一下块级模式最安全 行内块元素在行内元素中有几个特殊的标签——&lt;img /&gt;、&lt;input /&gt;、&lt;td&gt;，它们同时具有块元素和行内元素的特点。有些资料称它们为行内块元素。 特点： 和相邻行内元素（行内块）在一行上，但是他们之间会有空白缝隙。一行可以显示多个（行内元素特点）。 默认宽度就是它本身内容的宽度（行内元素特点）。 高度，行高、外边距以及内边距都可以控制（块级元素特点） 元素转换123display: block; /*转换为块元素*/display: inline; /*转换为行内元素*/display: inline-block; /*转换为行内块*/ 实例123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; a &#123; display: block; width: 230px; height: 40px; background-color: #55585a; font-size: 14px; color: #fff; text-decoration: none; text-indent: 2em; line-height: 40px; &#125; a:hover &#123; background-color: #ff6700;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;&quot;&gt;手机 电话卡&lt;/a&gt; &lt;a href=&quot;&quot;&gt;电视&lt;/a&gt; &lt;a href=&quot;&quot;&gt;笔记本&lt;/a&gt; &lt;a href=&quot;&quot;&gt;穿戴&lt;/a&gt; &lt;a href=&quot;&quot;&gt;其他&lt;/a&gt;&lt;/html&gt;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"css","slug":"css","permalink":"https://youngsay.cn/tags/css/"}]},{"title":"css伪类选择器","slug":"css-hover","date":"2021-04-08T13:25:01.000Z","updated":"2021-04-09T05:04:46.473Z","comments":true,"path":"2021/04/08/css-hover/","link":"","permalink":"https://youngsay.cn/2021/04/08/css-hover/","excerpt":"","text":"伪类选择器用于向某些选择器添加特殊的效果，伪类选择器有链接伪类、结构伪类等。 链接伪类1234a: link /*未访问的链接*/a: visited /*已访问的链接*/a: hover /*鼠标悬停的链接*/a: active /*已选择的链接*/ 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;/* unvisited link */a:link &#123; color: red;&#125;/* visited link */a:visited &#123; color: green;&#125;/* mouse over link */a:hover &#123; color: hotpink;&#125;/* selected link */a:active &#123; color: blue;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;CSS 链接&lt;/h1&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;/index.html&quot; target=&quot;_blank&quot;&gt;这是一个链接&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;在 CSS 定义中，a:hover 必须位于 a:link 和 a:visited 之后才能生效。&lt;/p&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;在 CSS 定义中，a:active 必须位于 a:hover 之后才能生效。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; focus伪类:focus伪类选择器用于选取获得焦点的表单元素。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; input:focus &#123; background-color: aqua; color: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot;&gt; &lt;input type=&quot;text&quot;&gt; &lt;input type=&quot;text&quot;&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"css","slug":"css","permalink":"https://youngsay.cn/tags/css/"}]},{"title":"emmet语法","slug":"emmet","date":"2021-04-07T04:49:01.000Z","updated":"2021-04-07T07:12:47.610Z","comments":true,"path":"2021/04/07/emmet/","link":"","permalink":"https://youngsay.cn/2021/04/07/emmet/","excerpt":"","text":"Emmet语法的前身是Zen coding,它使用缩写,来提高html/css的编写速度, Vscode内部已经集成该语法。 快速生成HTML结构语法标签div 然后tab 键 1&lt;div&gt;&lt;/div&gt; 多个相同标签div*3 123&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt; 父子级标签可以用 &gt; ，比如 ul &gt; li 123&lt;ul&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 兄弟标签用 + ,比如 div+p 12&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt; 有类名或者id名字 直接写 .demo 或者 #two, tab 键 12&lt;div class=&quot;demo&quot;&gt;&lt;/div&gt;&lt;div id=&quot;demo&quot;&gt;&lt;/div&gt; 有顺序的div类名 自增符号 $ div$*5 12345&lt;div1&gt;&lt;/div1&gt;&lt;div2&gt;&lt;/div2&gt;&lt;div3&gt;&lt;/div3&gt;&lt;div4&gt;&lt;/div4&gt;&lt;div5&gt;&lt;/div5&gt; 标签内部写内容{ }div{胖虎同学} 1&lt;div&gt;胖虎同学&lt;/div&gt; 快速生成CSS样式语法w200 按tab 可以 生成 width: 200px;lh26px 按tab 可以生成 line-height: 26px; 参考资料： emmet语法,","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"css","slug":"css","permalink":"https://youngsay.cn/tags/css/"},{"name":"html","slug":"html","permalink":"https://youngsay.cn/tags/html/"}]},{"title":"html表单元素","slug":"html-form","date":"2021-04-06T14:32:01.000Z","updated":"2021-04-06T14:56:08.338Z","comments":true,"path":"2021/04/06/html-form/","link":"","permalink":"https://youngsay.cn/2021/04/06/html-form/","excerpt":"","text":"HTML 表单用于搜集不同类型的用户输入。 input元素&lt;input type=&quot; &quot;&gt; radio 单选按钮text 单行文本输入submit 提交按钮checkbox 多选按钮password 定义密码字段 select元素下拉列表， option 元素定义待选择的选项,selected 属性定义预定义选项。 12345&lt;select name=&quot;language&quot;&gt;&lt;option value=&quot;Chinese&quot; selected&gt;Chinese&lt;/option&gt;&lt;option value=&quot;English&quot;&gt;Saab&lt;/option&gt;&lt;option value=&quot;Japanese&quot;&gt;Fiat&lt;/option&gt;&lt;/select&gt; textarea元素多行文本输入 综合实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;title&gt;html表单练习&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;!-- 第一行 --&gt; &lt;tr&gt; &lt;td&gt;性别：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;nan&quot;&gt; &lt;label for=&quot;nan&quot;&gt;&lt;img height=&quot;20px&quot; src=&quot;img/man.png&quot;&gt;男&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;nv&quot;&gt;&lt;label for=&quot;nv&quot;&gt;&lt;img height=&quot;20px&quot; src=&quot;img/woman.png&quot;&gt;女&lt;/label&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第二行 --&gt; &lt;tr&gt; &lt;td&gt;月薪&lt;/td&gt; &lt;td&gt; &lt;select&gt; &lt;option &gt;请选择月薪范围&lt;/option&gt; &lt;option &gt;低于5k&lt;/option&gt; &lt;option &gt;5k-1w&lt;/option&gt; &lt;option &gt;1w-1.5w&lt;/option&gt; &lt;option &gt;1.5w-2w&lt;/option&gt; &lt;option &gt;2w+&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第三行 --&gt; &lt;tr&gt; &lt;td&gt;地区：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; value=&quot;输入工作地区&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第四行 --&gt; &lt;tr&gt; &lt;td&gt;婚姻状况：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;radio&quot; name=&quot;marry&quot; checked=&quot;checked&quot; id=&quot;marry&quot;&gt;&lt;label for=&quot;marry&quot;&gt;已婚&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;marry&quot;&gt;已婚&lt;/td&gt; &lt;/tr&gt; &lt;!-- 第五行 --&gt; &lt;tr&gt; &lt;td&gt;学历：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;输入学历&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!-- 第六行 --&gt; &lt;tr&gt; &lt;td&gt;性格：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;xingge&quot;&gt;活泼开朗 &lt;input type=&quot;checkbox&quot; name=&quot;xingge&quot;&gt;沉闷呆板 &lt;input type=&quot;checkbox&quot; name=&quot;xingge&quot;&gt;严肃稳重 &lt;/tr&gt; &lt;!-- 第七行 --&gt; &lt;tr&gt; &lt;td&gt;个人介绍：&lt;/td&gt; &lt;td&gt; &lt;textarea&gt; 个人简介 &lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第八行 --&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;确认&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!-- 第九行 --&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; value=&quot;确认&quot; checked=&quot;checked&quot;&gt;我承诺信息准确&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"html","slug":"html","permalink":"https://youngsay.cn/tags/html/"}]},{"title":"css基础选择器和组合选择器","slug":"css","date":"2021-04-02T09:30:01.000Z","updated":"2021-04-02T09:30:45.186Z","comments":true,"path":"2021/04/02/css/","link":"","permalink":"https://youngsay.cn/2021/04/02/css/","excerpt":"","text":"css选择器用于选取要设置样式的HTML元素。 基础选择器id选择器12345678910111213141516&lt;html&gt;&lt;head&gt;&lt;style&gt;#para1 &#123; text-align: center; color: blue;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p id=&quot;para1&quot;&gt;胖虎同学&lt;/p&gt;&lt;p&gt;www.wangyouwu.cn&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 表现： 元素选择器1234567891011121314&lt;html&gt;&lt;head&gt;&lt;style&gt;h1 &#123; text-align: center; color: red;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;胖虎同学&lt;/h1&gt;&lt;p&gt;只有h1才会变红&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 表现： 类选择器12345678910111213&lt;html&gt;&lt;head&gt;&lt;style&gt;.center &#123; background: green;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 class=&quot;center&quot;&gt;我被绿了&lt;/h1&gt;&lt;p&gt;你被绿了。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 表现： tips 组合器选择器后代选择器（空格）123456789101112131415161718192021222324&lt;html&gt;&lt;head&gt;&lt;style&gt;div p &#123; background-color: yellow;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;后代选择器&lt;/h1&gt;&lt;p&gt;后代选择器匹配作为指定元素后代的所有元素。&lt;/p&gt;&lt;div&gt; &lt;p&gt;div 中的段落 1。&lt;/p&gt; &lt;p&gt;div 中的段落 2。&lt;/p&gt; &lt;section&gt;&lt;p&gt;div 中的段落 3。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;p&gt;段落 4。不在 div 中。&lt;/p&gt;&lt;p&gt;段落 5。不在 div 中。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 表现： 子选择器（&gt;)12345678910111213141516171819202122232425&lt;html&gt;&lt;head&gt;&lt;style&gt;div &gt; p &#123; background-color: yellow;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;子选择器&lt;/h1&gt;&lt;p&gt;子选择器 (&gt;) 选择属于指定元素子元素的所有元素。&lt;/p&gt;&lt;div&gt; &lt;p&gt;div 中的段落 1。&lt;/p&gt; &lt;p&gt;div 中的段落 2。&lt;/p&gt; &lt;section&gt;&lt;p&gt;div 中的段落 3。&lt;/p&gt;&lt;/section&gt; &lt;!-- 非子但属后代 --&gt; &lt;p&gt;div 中的段落 4。&lt;/p&gt;&lt;/div&gt;&lt;p&gt;段落 5。不在 div 中。&lt;/p&gt;&lt;p&gt;段落 6。不在 div 中。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 表现： 相邻兄弟选择器（+）1234567891011121314151617181920212223&lt;html&gt;&lt;head&gt;&lt;style&gt;div + p &#123; background-color: yellow;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;相邻兄弟选择器&lt;/h1&gt;&lt;p&gt;相邻的同胞选择器（+）选择所有作为指定元素的相邻的同级元素。&lt;/p&gt;&lt;div&gt; &lt;p&gt;div 中的段落 1。&lt;/p&gt; &lt;p&gt;div 中的段落 2。&lt;/p&gt;&lt;/div&gt;&lt;p&gt;段落 3。不在 div 中。&lt;/p&gt;&lt;p&gt;段落 4。不在 div 中。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 表现： 通用兄弟选择器（~）12345678910111213141516171819202122232425&lt;html&gt;&lt;head&gt;&lt;style&gt;div ~ p &#123; background-color: yellow;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;通用兄弟选择器&lt;/h1&gt;&lt;p&gt;通用的兄弟选择器（~）选择指定元素的所有同级元素。&lt;/p&gt;&lt;p&gt;段落 1。&lt;/p&gt;&lt;div&gt; &lt;p&gt;段落 2。&lt;/p&gt;&lt;/div&gt;&lt;p&gt;段落 3。&lt;/p&gt;&lt;code&gt;一些代码。&lt;/code&gt;&lt;p&gt;段落 4。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 表现： Tips 除此之外，还有伪类选择器（根据特定状态选取元素）、伪元素选择器（根据元素的一部分并设置其样式）、属性选择器（根据属性或属性值来选取元素）。随着以后遇到再深入学习。 css选择器,","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"css","slug":"css","permalink":"https://youngsay.cn/tags/css/"}]},{"title":"罗翔老师打动人心的句子","slug":"luoxiang","date":"2021-04-02T00:36:01.000Z","updated":"2021-08-19T07:43:03.862Z","comments":true,"path":"2021/04/02/luoxiang/","link":"","permalink":"https://youngsay.cn/2021/04/02/luoxiang/","excerpt":"","text":"一直很喜欢张三（不是），张三的塑造者，罗翔老师，罗翔老师风趣幽默又严肃谦逊，不卖弄学识，不好为人师，学识渊博却无时不在强调自己的无知。 在罗祥老师身上总能看到两代人：年轻一代的理想与正义，老去一代慈祥与释怀。引用B站的一个评论： 听罗老师的课，总能感受到一种年少才有的那种激进正义感，和年长了才会有的那种温暖的慈悲 下面是转自B站的视频，与君共勉。 所有的天资聪颖都需要艰苦的训练。 我们登上并非我们所选择的舞台，演出并非我们所选择的剧本。 你的剧本不是你选择的，你只有努力的吧你的剧本给演好。只要努力演好你的剧本，痛苦中也有精彩。 越能体现人性尊严的快乐，越是更高级的快乐。 当你觉得这个世界有大量的不正义，说明世上存在正义。如果这个世界上没有正义，那么不正义就毫无意义。 一个开放的社会就像一张张开的口，合下来的时候一定要咬住某种坚实的东西。天变地变，道义不变。 一次犯罪不过是污染了水源，而一次不公正的司法却是污染了水源。","categories":[{"name":"分享","slug":"分享","permalink":"https://youngsay.cn/categories/%E5%88%86%E4%BA%AB/"}],"tags":[]},{"title":"HTML速查手册","slug":"html","date":"2021-03-31T11:59:01.000Z","updated":"2022-01-09T22:37:06.256Z","comments":true,"path":"2021/03/31/html/","link":"","permalink":"https://youngsay.cn/2021/03/31/html/","excerpt":"","text":"HTML Basic Document12345678&lt;html&gt;&lt;head&gt;&lt;title&gt;Document name goes here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Visible text goes here&lt;/body&gt;&lt;/html&gt; Text Elements1234&lt;p&gt;This is a paragraph&lt;/p&gt;&lt;br&gt; (line break)&lt;hr&gt; (horizontal rule)&lt;pre&gt;This text is preformatted&lt;/pre&gt; Logical Styles123&lt;em&gt;This text is emphasized&lt;/em&gt;&lt;strong&gt;This text is strong&lt;/strong&gt;&lt;code&gt;This is some computer code&lt;/code&gt; Physical Styles12&lt;b&gt;This text is bold&lt;/b&gt;&lt;i&gt;This text is italic&lt;/i&gt; Links, Anchors, and Image Elements12345&lt;a href=&quot;http://www.example.com/&quot;&gt;This is a Link&lt;/a&gt;&lt;a href=&quot;http://www.example.com/&quot;&gt;&lt;img src=&quot;URL&quot; alt=&quot;Alternate Text&quot;&gt;&lt;/a&gt;&lt;a href=&quot;mailto:webmaster@example.com&quot;&gt;Send e-mail&lt;/a&gt;A named anchor:&lt;a name=&quot;tips&quot;&gt;Useful Tips Section&lt;/a&gt;&lt;a href=&quot;#tips&quot;&gt;Jump to the Useful Tips Section&lt;/a&gt; Unordered list1234&lt;ul&gt;&lt;li&gt;First item&lt;/li&gt;&lt;li&gt;Next item&lt;/li&gt;&lt;/ul&gt; Ordered list1234&lt;ol&gt;&lt;li&gt;First item&lt;/li&gt;&lt;li&gt;Next item&lt;/li&gt;&lt;/ol&gt; Definition list123456&lt;dl&gt;&lt;dt&gt;First term&lt;/dt&gt;&lt;dd&gt;Definition&lt;/dd&gt;&lt;dt&gt;Next term&lt;/dt&gt;&lt;dd&gt;Definition&lt;/dd&gt;&lt;/dl&gt; Tables12345678910&lt;table border=&quot;1&quot;&gt;&lt;tr&gt; &lt;th&gt;someheader&lt;/th&gt; &lt;th&gt;someheader&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;sometext&lt;/td&gt; &lt;td&gt;sometext&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; Frames1234&lt;frameset cols=&quot;25%,75%&quot;&gt; &lt;frame src=&quot;page1.htm&quot;&gt; &lt;frame src=&quot;page2.htm&quot;&gt;&lt;/frameset&gt; Forms1234567891011121314151617&lt;form action=&quot;http://www.example.com/test.asp&quot; method=&quot;post/get&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;lastname&quot;value=&quot;Nixon&quot; size=&quot;30&quot; maxlength=&quot;50&quot;&gt;&lt;input type=&quot;password&quot;&gt;&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;&gt;&lt;input type=&quot;radio&quot; checked=&quot;checked&quot;&gt;&lt;input type=&quot;submit&quot;&gt;&lt;input type=&quot;reset&quot;&gt;&lt;input type=&quot;hidden&quot;&gt;&lt;select&gt;&lt;option&gt;Apples&lt;option selected&gt;Bananas&lt;option&gt;Cherries&lt;/select&gt;&lt;textarea name=&quot;Comment&quot; rows=&quot;60&quot;cols=&quot;20&quot;&gt;&lt;/textarea&gt;&lt;/form&gt; Entities123&amp;lt; is the same as &lt;&amp;gt; is the same as &gt;&amp;#169; is the same as © Other Elements123456789&lt;!-- This is a comment --&gt;&lt;blockquote&gt;Text quoted from some source.&lt;/blockquote&gt;&lt;address&gt;Address 1&lt;br&gt;Address 2&lt;br&gt;City&lt;br&gt;&lt;/address&gt;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"html","slug":"html","permalink":"https://youngsay.cn/tags/html/"}]},{"title":"yaml基础语法","slug":"yaml","date":"2021-03-29T12:45:54.000Z","updated":"2021-03-29T13:39:47.287Z","comments":true,"path":"2021/03/29/yaml/","link":"","permalink":"https://youngsay.cn/2021/03/29/yaml/","excerpt":"","text":"yaml简介YAML 是 “YAML Ain’t a Markup Language”（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）。yaml是能够被电脑识别的数据序列化格式。 基本语法 大小写敏感 使用缩进表示层级关系 缩进禁止用Tab，只允许用空格 空格数不重要，只要相同层级元素左对齐即可 用#表示注释 数据类型 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary） 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list） 纯量（scalars）：单个的、不可再分的值 对象对象键值对用冒号表示，冒号后加一个空格key: value，也可以使用key: &#123;key1: value1, key2: value2, ...&#125; 数组以 - 开头的行表示构成一个数组： 123- A- B- C 多维数组的行内表示： 1key: [value1, value2, ...] 纯量 字符串 布尔值 整数 浮点数 Null 时间 日期 123456789101112131415161718192021boolean: - TRUE #true,True都可以 - FALSE #false，False都可以float: - 3.14 - 6.8523015e+5 #可以使用科学计数法int: - 123 - 0b1010_0111_0100_1010_1110 #二进制表示null: nodeName: &#x27;node&#x27; parent: ~ #使用~表示nullstring: - 哈哈 - &#x27;Hello world&#x27; #可以使用双引号或者单引号包裹特殊字符 - newline newline2 #字符串可以拆成多行，每一行会被转化成一个空格date: - 2018-02-17 #日期必须使用ISO 8601格式，即yyyy-MM-dddatetime: - 2018-02-17T15:02:31+08:00 #时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区 引用&amp; 锚点和 * 别名，可以用来引用: 1234567891011defaults: &amp;defaults adapter: postgres host: localhostdevelopment: database: myapp_development &lt;&lt;: *defaultstest: database: myapp_test &lt;&lt;: *defaults 相当于 12345678910111213defaults: adapter: postgres host: localhostdevelopment: database: myapp_development adapter: postgres host: localhosttest: database: myapp_test adapter: postgres host: localhost 参考资料：YAML入门教程yaml教程YML简介YAML语言教程","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"yaml","slug":"yaml","permalink":"https://youngsay.cn/tags/yaml/"}]},{"title":"新学期，新博客，新开始！","slug":"go-school","date":"2021-03-29T05:58:37.000Z","updated":"2021-06-17T14:16:18.451Z","comments":true,"path":"2021/03/29/go-school/","link":"","permalink":"https://youngsay.cn/2021/03/29/go-school/","excerpt":"","text":"前言新学期要开始了，把旧站关了，建个新站。本站用Hexo搭建，部署在github和vercel。 改用Hexo缘起幼稚园园长的博客，陷进去了（沈腾语气）。搭建博客出了些问题，感谢小茗同学的教程和小T同学的帮助。 博客内容博客主要记录我的学习笔记、日常生活和想要分享的内容。 一直对编程感兴趣，尤其是前端。我想学的是计算机相关专业，憧憬的职业是程序员👨‍💻，无奈被调剂到了应用物理学。没关系，兴趣在，希望就在。我建该站的目的之一是记录自己的学习编程之路，所以博客的大部分内容是我的学习笔记。 时光稍纵即逝，记忆也会随时间冲淡。记录想要留存的记忆，1个月后，1年后，10年后回看，会有不同的感受。多年之后，我是否变成了自己讨厌的样子，曾经的豪言壮志是否都已实现，曾经的百思不解是否有的答案。年长的自己能够坐着时光机重识年轻的自己，这是件有趣的事。 万物皆有圈，生物圈、朋友圈、电竞圈……博客也有圈，博客圈的博主们遍布世界各地，从事各种领域，有着相同或不同的兴趣，认真地运营着自己的博客。世上的人遍地都是，说的着的千里难寻。浏览不同的博客，发现不同的世界，结交不同的朋友。 博客事件2021.03.29 旧站关闭，新博客建成。起名“胖虎同学”，博客域名为blog.wangyouwu.cn。2021.04.02 博客的第一条评论：来自琛苏设计2021.04.18 博客的第一个友链：幼稚园园长","categories":[{"name":"日常","slug":"日常","permalink":"https://youngsay.cn/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]}],"categories":[{"name":"分享","slug":"分享","permalink":"https://youngsay.cn/categories/%E5%88%86%E4%BA%AB/"},{"name":"日常","slug":"日常","permalink":"https://youngsay.cn/categories/%E6%97%A5%E5%B8%B8/"},{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"c","slug":"c","permalink":"https://youngsay.cn/tags/c/"},{"name":"JavaSE","slug":"JavaSE","permalink":"https://youngsay.cn/tags/JavaSE/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://youngsay.cn/tags/Vue-js/"},{"name":"Python","slug":"Python","permalink":"https://youngsay.cn/tags/Python/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://youngsay.cn/tags/JavaScript/"},{"name":"阅读","slug":"阅读","permalink":"https://youngsay.cn/tags/%E9%98%85%E8%AF%BB/"},{"name":"英语","slug":"英语","permalink":"https://youngsay.cn/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"css","slug":"css","permalink":"https://youngsay.cn/tags/css/"},{"name":"linux","slug":"linux","permalink":"https://youngsay.cn/tags/linux/"},{"name":"html","slug":"html","permalink":"https://youngsay.cn/tags/html/"},{"name":"yaml","slug":"yaml","permalink":"https://youngsay.cn/tags/yaml/"}]}