<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>胖虎同学</title>
  
  <subtitle>生活学习类个人博客</subtitle>
  <link href="https://youngsay.cn/atom.xml" rel="self"/>
  
  <link href="https://youngsay.cn/"/>
  <updated>2022-11-28T13:18:47.781Z</updated>
  <id>https://youngsay.cn/</id>
  
  <author>
    <name>胖虎同学</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL数据库：索引</title>
    <link href="https://youngsay.cn/2022/11/28/MySQL-index/"/>
    <id>https://youngsay.cn/2022/11/28/MySQL-index/</id>
    <published>2022-11-28T13:04:41.000Z</published>
    <updated>2022-11-28T13:18:47.781Z</updated>
    
    <content type="html"><![CDATA[<p>索引是一种用于快速查找和检索数据的数据结构，类似于图书的目录，通过索引可以更快地找到对应的数据。</p><h3 id="索引的优缺点">索引的优缺点</h3><p>优点：</p><ul><li>提高了查找的效率</li><li>通过创建唯一性索引，确保了每一行数据的唯一性。</li></ul><p>缺点：</p><ul><li>索引使用物理文件存储，带来了空间的消耗。</li><li>创建和维护索引需要耗费时间。当数据发生更改时，索引也会动态修改，降低SQL执行效率。</li></ul><h3 id="索引SQL">索引SQL</h3><h4 id="查看索引">查看索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> 索引名 <span class="keyword">from</span> 表名(列名);</span><br></pre></td></tr></table></figure><p><img src="https://cos.youngsay.cn/blog/202211282118307.png" alt="image-20221128161811672"></p><h4 id="创建索引">创建索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index 索引名 <span class="keyword">on</span> 表名(列名);</span><br></pre></td></tr></table></figure><p><img src="https://cos.youngsay.cn/blog/202211282118347.png" alt="image-20221128162120786"></p><h4 id="删除索引">删除索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> index 索引名 <span class="keyword">on</span> 表名</span><br></pre></td></tr></table></figure><p><img src="https://cos.youngsay.cn/blog/202211282118794.png" alt="image-20221128162440340"></p><h3 id="索引底层的数据结构">索引底层的数据结构</h3><p>索引是一种查找更快的数据结果。</p><p>数组和链表的查找都需要遍历，最先淘汰。</p><p>二叉搜索树最坏情况下会变成单支树，查找的时间复杂度变为O(N)，淘汰。</p><p>AVL树和红黑树使得左右子树高度相对平衡，但数据量太大时，树的高度过高，比较次数过多，即磁盘IO过多，淘汰。</p><p>哈希表查找的时间复杂度是O(1)，是不是可以作为索引的数据结构了呢？NO！哈希表不支持顺序和范围查找，而SQL要经常进行排序和</p><p>范围查询，淘汰。</p><p><strong>目前大多数数据库采用B树或B+树作为索引结构</strong>，在MySQL中，MyISAM 引擎和 InnoDB 引擎都是使用 B+树 作为索引结构。</p><p>B树称为多路平衡查找树，B+树是在B树基础上的变现，二者都是多叉平衡树。</p><h4 id="B树">B树</h4><p><img src="https://cos.youngsay.cn/blog/202211282118366.png" alt="image-20221128203706890"></p><h4 id="B-树">B+树</h4><p><img src="https://cos.youngsay.cn/blog/202211282118609.png" alt="image-20221128203611266"></p><h4 id="区别和联系">区别和联系</h4><ul><li><p>B树N个值，划分为N+1个结点；B+树N个值，划分为N个结点。</p></li><li><p>B树叶子结点相互独立;B+树叶子结点是链式结构，指向相邻结点。</p></li><li><p>B树每个结点既存放key，又存放data；B+树只有叶子结点既存放key，又存放data，其他结点只存key。</p></li><li><p>B树的查找过程是对每个关键字二分查找，可能没有到叶子结点就检索到了；B+树更加稳定，每次查找都是从根节点开始，到叶子结点结束。</p></li></ul><h4 id="索引为什么要用B-树">索引为什么要用B+树</h4><ul><li>每次都是从根节点到叶子结点，IO次数都差不多，查询效率稳定。</li><li>磁盘IO请求数少，查询速度快。</li><li>叶子结点采用链式存储结构，方便数据范围查询。</li><li>非叶子结点只存储key，占用空间小，甚至可以缓存到内存中。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;索引是一种用于快速查找和检索数据的数据结构，类似于图书的目录，通过索引可以更快地找到对应的数据。&lt;/p&gt;
&lt;h3 id=&quot;索引的优缺点&quot;&gt;索引的优缺点&lt;/h3&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提高了查找的效率&lt;/li&gt;
&lt;li&gt;通过创建唯一性索引，确保了每一行数据</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="索引" scheme="https://youngsay.cn/tags/%E7%B4%A2%E5%BC%95/"/>
    
    <category term="MySQL" scheme="https://youngsay.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>socket套接字网络编程</title>
    <link href="https://youngsay.cn/2022/11/22/Java-Socket/"/>
    <id>https://youngsay.cn/2022/11/22/Java-Socket/</id>
    <published>2022-11-22T06:14:41.000Z</published>
    <updated>2022-11-22T06:49:57.565Z</updated>
    
    <content type="html"><![CDATA[<p>网络编程使计算机不再是一个孤立的个体，而是一个互联的整体，通过网络编程，可实现主机各进程间的数据传输。网络编程的核心就是套接字socket。socket是由系统提供用于网络通信的技术，是基于TCP/IP协议的网络通信的基本操作单元。</p><p>socket主要分为三类：流套接字、数据报套接字、原始套接字。我们这里主要介绍前两种：</p><p><strong>流套接字</strong>：使用传输层TCP协议，提供面向连接、可靠的数据传输，面向字节流，有接收缓冲区和发送缓冲区，传输数据大小无限制。</p><p><strong>数据报套接字</strong>：使用传输层UDP协议，提供无连接、不可靠传输，面向数据报，只有接收缓冲区，传输大小受限，一次最多传输64K。</p><p>下面我们来看下Java中是如何使用socket来进行网络编程的。</p><h3 id="数据报套接字">数据报套接字</h3><p>Java数据报套接字编程有两个核心的类，<code>DatagramSocket</code>和<code>DatagramPacket</code>。</p><h4 id="两个核心类">两个核心类</h4><p><code>DatagramSocket</code>用于创建一个数据报套接字，用于发送和接收数据报。主要的构造方法如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>DatagramSocket()</td><td>创建一个UDP数据报套接字的Socket，绑定到本机任意一个随机端口 （一般用于客户端）</td></tr><tr><td>DatagramSocket(int port)</td><td>创建一个UDP数据报套接字的Socket，绑定到本机指定的端口（一般用 于服务端）</td></tr></tbody></table><p>常用方法如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void receive(DatagramPacket p)</td><td>从此套接字接收数据报（如果没有接收到数据报，会阻塞等待）</td></tr><tr><td>void send(DatagramPacket p)</td><td>从此套接字发送数据报包（不会阻塞等待，直接发送）</td></tr><tr><td>void close()</td><td>关闭此数据报套接字</td></tr></tbody></table><p>方法内的参数类型，就是我们要介绍的另一个核心类：<code>DatagramPacket</code>，该类表示数据报包，用于进程间的发送和接收。主要构造方法如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>DatagramPacket(byte[] buf, int length)</td><td>构造一个数据报包，<strong>用来接收</strong>，接收的数据保存在字节数组buf中，接收指定长度length</td></tr><tr><td>DatagramPacket(byte[] buf, int offset, int length, SocketAddress address)</td><td>构造一个数据报包，<strong>用来发送</strong>，发送的数据为字节数组buf，从offset到长度length，指明目标主机地址address，即IP和端口号</td></tr></tbody></table><p>常用方法如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>InetAddress getAddress()</td><td>获取该数据报发送或接收数据报的计算机的IP地址。</td></tr><tr><td>getSocketAddress()</td><td>获取该数据包发送到或正在从其发送的远程主机的SocketAddress（通常为IP地址+端口号）。</td></tr><tr><td>int getPort()</td><td>获取该数据报发送或接收数据报的端口号</td></tr><tr><td>byte[] getData()</td><td>获取数据报中的数据</td></tr><tr><td>int getLength()</td><td>返回要发送的数据的长度或接收到的数据的长度。</td></tr></tbody></table><h4 id="服务器端">服务器端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdpServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DatagramSocket socket = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UdpServer</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个服务器端的数据报套接字，通常指明端口</span></span><br><span class="line">        socket = <span class="keyword">new</span> DatagramSocket(port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;服务器已连接&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">//1.接收请求</span></span><br><span class="line">                <span class="comment">//创建数据报包，用来接收客户端发来的请求</span></span><br><span class="line">                DatagramPacket reqPacket = <span class="keyword">new</span> DatagramPacket(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>],<span class="number">1024</span>);</span><br><span class="line">                <span class="comment">//接收数据报，没有数据传来时会阻塞等待</span></span><br><span class="line">                socket.receive(reqPacket);</span><br><span class="line">                <span class="comment">//★从接收的数据报中解析数据，构造成请求字符串</span></span><br><span class="line">                String req = <span class="keyword">new</span> String(reqPacket.getData(),<span class="number">0</span>,reqPacket.getLength(),<span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">                <span class="comment">//2.构造响应</span></span><br><span class="line">                <span class="comment">//这里没有做处理，发来什么就返回什么。</span></span><br><span class="line">                String resp = process(req);</span><br><span class="line">                <span class="comment">//创建数据报包，用来发送响应</span></span><br><span class="line">                <span class="comment">//将响应字符串转换成字节数组，指明目的主机地址</span></span><br><span class="line">                DatagramPacket respPacket = <span class="keyword">new</span> DatagramPacket(resp.getBytes(),resp.getBytes().length,reqPacket.getSocketAddress());</span><br><span class="line">                <span class="comment">//3.发送响应</span></span><br><span class="line">                socket.send(respPacket);</span><br><span class="line">                <span class="comment">//4.打印日志</span></span><br><span class="line">                System.out.printf(<span class="string">&quot;[%s:%d] req: %s, resp: %s\n&quot;</span>,</span><br><span class="line">                        reqPacket.getAddress().toString(), reqPacket.getPort(), req, resp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造响应</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">process</span><span class="params">(String req)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> req;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">        UdpServer server = <span class="keyword">new</span> UdpServer(<span class="number">9090</span>);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中★处要尤为注意：</p><p>构造请求字符串的第三个参数：请求字符串长度，是接收到的数据报的长度，reqPacket.getLength()。一定不要写成reqPacket.getData().length()，这个是字节数组的长度，该代码为1024。</p><h4 id="客户端">客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdpClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port; <span class="comment">//服务器端口号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String ip; <span class="comment">//服务器ip地址</span></span><br><span class="line">    <span class="keyword">private</span> DatagramSocket socket = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UdpClient</span><span class="params">(String ip,<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个客户端的数据报套接字，通常不指明端口</span></span><br><span class="line">        <span class="keyword">this</span>.socket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">        <span class="keyword">this</span>.ip = ip;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">//0.输入请求</span></span><br><span class="line">                System.out.println(<span class="string">&quot;请输入请求：&quot;</span>);</span><br><span class="line">                Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">                String req = scanner.nextLine();</span><br><span class="line">                <span class="comment">//1.构造请求</span></span><br><span class="line">                <span class="comment">//创建一个数据报包，用来发送请求★</span></span><br><span class="line">                DatagramPacket reqPacket = <span class="keyword">new</span> DatagramPacket(req.getBytes(),req.getBytes().length,InetAddress.getByName(ip),port);</span><br><span class="line">                <span class="comment">//2.发送请求</span></span><br><span class="line">                socket.send(reqPacket);</span><br><span class="line">                <span class="comment">//创建接收数据包，用来接收服务器发来的响应</span></span><br><span class="line">                DatagramPacket respPacket = <span class="keyword">new</span> DatagramPacket(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>],<span class="number">1024</span>);</span><br><span class="line">                <span class="comment">//3.接收响应</span></span><br><span class="line">                socket.receive(respPacket);</span><br><span class="line">                String resp = <span class="keyword">new</span> String(respPacket.getData(),<span class="number">0</span>,respPacket.getLength());</span><br><span class="line">                System.out.println(<span class="string">&quot;resp：&quot;</span>+resp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">        <span class="comment">//参数内为服务器的ip和端口号</span></span><br><span class="line">        UdpClient client = <span class="keyword">new</span> UdpClient(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">9090</span>);</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码中★处：</p><p>构造发送数据包时要传入目的主机的地址，InetAddress.getByName(ip),port分别为主机的ip地址和端口号，除了这样，还可以通过创建socketAddress类来指定主机地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SocketAddress socketAddress = <span class="keyword">new</span> InetSocketAddress(ip,port);</span><br><span class="line">DatagramPacket reqPacket = <span class="keyword">new</span> DatagramPacket(req.getBytes(),req.getBytes().length,socketAddress);</span><br></pre></td></tr></table></figure><h3 id="流套接字">流套接字</h3><p>Java流套接字编程也有两个核心的类，<code>ServerSocket</code>和<code>Socket</code>。</p><h4 id="两个核心类-2">两个核心类</h4><p>ServerSockert通常用于创建一个服务器端的流套接字，常用构造方法如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>ServerSocket(int port)</td><td>创建一个服务端流套接字Socket，并绑定到指定端口</td></tr></tbody></table><p>常用方法如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Socket accept()</td><td>监听要连接此客户端的套接字，有客户端连接后，返回一个服务端Socket对象，并基于该Socket建立与客户端的连接，否则阻塞等待</td></tr><tr><td>void close()</td><td>关闭此套接字</td></tr></tbody></table><p>Socket通常用于常见一个客户端的流套接字，常用构造方法如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Socket(String host, int port)</td><td>创建一个客户端流套接字Socket，并与对应IP的主机上，对应端口的进程建立连接</td></tr></tbody></table><p>常用方法如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>InetAddress getInetAddress()</td><td>返回套接字所连接的地址</td></tr><tr><td>InputStream getInputStream()</td><td>返回此套接字的输入流</td></tr><tr><td>OutputStream getOutputStream()</td><td>返回此套接字的输出流</td></tr></tbody></table><h4 id="服务器端-2">服务器端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpServer</span> </span>&#123;</span><br><span class="line">    ServerSocket server = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TcpServer</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个服务器套接字，指定服务器端口号</span></span><br><span class="line">        server = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//监听客户端并建立连接</span></span><br><span class="line">            Socket client = server.accept();</span><br><span class="line">            processConnection(client);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConnection</span><span class="params">(Socket client)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;[%s,%d]客户端建立连接\n&quot;</span>,client.getInetAddress(),client.getPort());</span><br><span class="line">        <span class="comment">//创建输入输出流，输入流用来接收客户端传来的数据，输出流用来将数据发给客户端</span></span><br><span class="line">        <span class="keyword">try</span>(InputStream inputStream = client.getInputStream())&#123;</span><br><span class="line">            <span class="keyword">try</span>(OutputStream outputStream = client.getOutputStream())&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    Scanner scanner = <span class="keyword">new</span> Scanner(inputStream);</span><br><span class="line">                    <span class="keyword">if</span>(!scanner.hasNext())&#123;</span><br><span class="line">                        System.out.printf(<span class="string">&quot;[%s,%d]客户端断开连接&quot;</span>,client.getInetAddress(),client.getPort());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//1.接收请求</span></span><br><span class="line">                    String req = scanner.nextLine();</span><br><span class="line">                    <span class="comment">//2.构造响应</span></span><br><span class="line">                    String resp = process(req);</span><br><span class="line">                    <span class="comment">//3.返回响应</span></span><br><span class="line">                    PrintWriter printWriter = <span class="keyword">new</span> PrintWriter(outputStream);</span><br><span class="line">                    <span class="comment">//★调用println方法，不能是print和write</span></span><br><span class="line">                    printWriter.println(resp);</span><br><span class="line">                    printWriter.flush();</span><br><span class="line">                    System.out.printf(<span class="string">&quot;req:%s,resp:%s\n&quot;</span>,req,resp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//★关闭连接</span></span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">process</span><span class="params">(String req)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> req;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        TcpServer server = <span class="keyword">new</span> TcpServer(<span class="number">9090</span>);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>★处要尤为注意：</p><ol><li><p>调用的是println方法，不是print也不是write。println方法会为写入的数据后面添加上换行符，而print和write不会。客户端接收数据时是以换行符为结束来获取数据。如果找不到换行符，将一直不能接收响应，造成阻塞。同理，客户端发送请求时也要使用println方法，否则服务器也会接收不到请求而一直阻塞。</p></li><li><p>大家可能会想，为什么这里的client要关闭连接，而server和之前的数据报套接字都不需要关闭连接。关闭连接的前提是不再使用了，对于UDP和ServerSocket，它们是贯穿程序始终的，而这里的client，也就是Socket，每个连接都有一个Socket，断开连接也就不再需要这个Socket了，需要进行释放。</p></li></ol><h4 id="客户端-2">客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line">    Socket client = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TcpClient</span><span class="params">(String ip,<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.ip = ip;</span><br><span class="line">        <span class="comment">//★创建客户端套接字，并将其连接到指定IP地址的指定端口号。</span></span><br><span class="line">        <span class="keyword">this</span>.client = <span class="keyword">new</span> Socket(ip,port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>(InputStream inputStream = client.getInputStream()) &#123;</span><br><span class="line">            <span class="keyword">try</span>(OutputStream outputStream = client.getOutputStream())&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="comment">//1.构造请求</span></span><br><span class="line">                    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">                    String req = scanner.next();</span><br><span class="line">                    <span class="comment">//2.发送请求</span></span><br><span class="line">                    PrintWriter printWriter = <span class="keyword">new</span> PrintWriter(outputStream);</span><br><span class="line">                    <span class="comment">//★调用println方法，不能是print和write</span></span><br><span class="line">                    printWriter.println(req);</span><br><span class="line">                    printWriter.flush();</span><br><span class="line">                    <span class="comment">//3.接收响应</span></span><br><span class="line">                    Scanner respScan = <span class="keyword">new</span> Scanner(inputStream);</span><br><span class="line">                    String resp = respScan.next();</span><br><span class="line">                    System.out.println(<span class="string">&quot;resp:&quot;</span>+resp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        TcpClient client = <span class="keyword">new</span> TcpClient(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">9090</span>);</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题">问题</h4><p>流套接字的客户端服务器通信还存在一个问题，只能满足一个客户端的通信。其他客户端尝试与服务器连接时，会发生阻塞。观察服务器代码中下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="comment">//监听客户端并建立连接</span></span><br><span class="line">        Socket client = server.accept();</span><br><span class="line">        processConnection(client);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端1与服务器建立连接后，服务器线程执行processConnection代码中的操作，代码中存在while循环，不断地接收客户端1发来的请求，构造响应，返回响应……此时客户端2想要与服务器通信，而服务器线程正在processConnection的while循环中等待客户端1的请求，导致服务器不能与客户端2建立连接。</p><p>TCP每次都需要建立连接，只能支持一对一，也就是端到端的通信。就像打电话一样，同一时间只能接听一个电话，当正在通话时，别的电话是打不进来的。而UDP是无连接的，因此支持一对一、一对多、多对多交互通信。所以我们在数据报套接字时没有出现该问题。</p><p>解决办法也很简单，因为processConnection中的循环未结束导致服务器不能执行accept操作，所以单独创建一个新的线程来完成processConnection操作即可。我们可以用多线程或线程池来解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="comment">//建立连接</span></span><br><span class="line">        Socket client = server.accept();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                processConnection(client);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其他代码不变，只需改动start方法内的代码，为processConnection操作创建新的线程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网络编程使计算机不再是一个孤立的个体，而是一个互联的整体，通过网络编程，可实现主机各进程间的数据传输。网络编程的核心就是套接字socket。socket是由系统提供用于网络通信的技术，是基于TCP/IP协议的网络通信的基本操作单元。&lt;/p&gt;
&lt;p&gt;socket主要分为三类：</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="socket" scheme="https://youngsay.cn/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>Java文件和IO流</title>
    <link href="https://youngsay.cn/2022/11/17/Java-IO/"/>
    <id>https://youngsay.cn/2022/11/17/Java-IO/</id>
    <published>2022-11-17T12:14:41.000Z</published>
    <updated>2022-11-17T12:21:05.099Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文件基础操作">文件基础操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个hello的目录</span></span><br><span class="line">    File dir = <span class="keyword">new</span> File(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!dir.exists())&#123;</span><br><span class="line">        dir.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在hello目录下创建一个hello.txt文件</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(dir+<span class="string">&quot;/hello.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">        file.createNewFile();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到文件名</span></span><br><span class="line">    System.out.println(file.getName());</span><br><span class="line">    <span class="comment">//得到文件的绝对路径</span></span><br><span class="line">    System.out.println(file.getAbsolutePath());</span><br><span class="line">    <span class="comment">//得到文件的规范路径，当路径不规范时，会进行优化(去掉.)</span></span><br><span class="line">    System.out.println(file.getCanonicalPath());</span><br><span class="line">    <span class="comment">//得到父目录名</span></span><br><span class="line">    System.out.println(file.getParent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体详见：<a href="https://docs.oracle.com/javase/8/docs/api/">File (Java Platform SE 8 ) (oracle.com)</a></p><h3 id="IO流">IO流</h3><p>IO即输入和输出（Input、Output），输入就是将数据读入到内存，输出就是将数据输出到外部存储（如文件、数据库）。数据的输入输出就像水流一样，因此成为IO流。</p><p>IO流的处理方式可分为两种：字节流和字符流。Java中针对IO流的处理有很多类，但最基本的只有4个抽象类。<code>InputStream</code>、<code>OutputStream</code>、<code>Reader</code>、<code>Writer</code>，前两个是对字节流的输入输出，后两个是对字符流的输入输出。下面我们拿普通文件的读写举例，介绍它们的基本操作。</p><h4 id="字节流">字节流</h4><h5 id="InputStream">InputStream</h5><p>用于对文件进行读操作，构造方法内可以是一个文件类型的参数，也可以是一个文件路径(字符串)的参数。</p><p>常用方法：</p><p><code>read()</code> ：一次读取一字节，返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。返回 <code>-1</code> ，表示读到文件的末尾，读取结束。</p><p><code>read(byte b[ ])</code> : 一次读取多个字节，将输入流字节存储到数组b，返回结果为读取字节长度。返回-1，表示读到文件的末尾，读取结束。</p><p><code>read(byte b[], int off, int len)</code> ：在<code>read(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</p><p><code>close()</code> ：关闭输入流释放相关的系统资源。</p><ul><li>一次读取一字节</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readOne</span><span class="params">(File file,FileInputStream fileInputStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fileInputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> read = fileInputStream.read();</span><br><span class="line">            <span class="keyword">if</span>(read==-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一次读取多个字节</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readByte</span><span class="params">(File file,FileInputStream inputStream)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> read = inputStream.read(bytes);</span><br><span class="line">            <span class="keyword">if</span>(read==-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; read; i++) &#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>)bytes[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="OutputStream">OutputStream</h5><p>用于对文件进行写操作，构造方法内可以是一个文件类型的参数，也可以是一个文件路径(字符串)的参数，同时可以指定第二个参数表示是否追加写入(是否清空之前的内容)，true表示追加写入，默认为false。</p><p>在写操作时数据暂时放在缓存区，只有缓存区满后才会真正写入到设备，所以别忘了调用<code>fulsh()</code>，防止数据没有写入设备。</p><p>常用方法：</p><p><code>write(int b)</code> ：将特定字节写入输出流。</p><p><code>write(byte b[ ])</code> : 将数组<code>b</code> 写入到输出流，等价于 <code>write(b, 0, b.length)</code> 。</p><p><code>write(byte[] b, int off, int len)</code> : 在<code>write(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</p><p><code>flush()</code> ：刷新此输出流并强制写出所有缓冲的输出字节。</p><p><code>close()</code> ：关闭输出流释放相关的系统资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeOne</span><span class="params">(File file, FileOutputStream outputStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        outputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        outputStream.write(<span class="number">103</span>);</span><br><span class="line">        outputStream.write(<span class="number">104</span>);</span><br><span class="line">        outputStream.flush();</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符流">字符流</h4><p>字节是电脑中存储信息的基本单位，那为什么还需要字符流呢？</p><p>当存储信息中有中文时，以字节流来读取会出现乱码。字节流更适用于音频、图片等类型文件，当文件中涉及字符类型时，使用字符流更好。字符流默认编码是<code>unicode</code>。</p><p>常见的字符编码：<code>utf8</code> :英文占 1 字节，中文占 3 字节，<code>unicode</code>：任何字符都占 2 个字节，<code>gbk</code>：英文占 1 字节，中文占 2 字节。</p><h5 id="Reader">Reader</h5><p>常用方法：</p><p><code>read()</code> : 从输入流读取一个字符。</p><p><code>read(char[] cbuf)</code> : 从输入流中读取一些字符，并将它们存储到字符数组 <code>cbuf</code>中，等价于 <code>read(cbuf, 0, cbuf.length)</code> 。</p><p><code>read(char[] cbuf, int off, int len)</code> ：在<code>read(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</p><p><code>close()</code> : 关闭输入流并释放相关的系统资源。</p><ul><li>一次读取一个字符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readOne</span><span class="params">(File file,Reader reader)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        reader = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> read = reader.read();</span><br><span class="line">            <span class="keyword">if</span>(read==-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一次读取多个字符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readCharacter</span><span class="params">(File file,Reader reader)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        reader = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">        <span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> read = reader.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (read==-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String s = <span class="keyword">new</span> String(buffer,<span class="number">0</span>,read);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Writer">Writer</h5><p>常用方法：</p><p><code>write(int c)</code> : 写入单个字符。</p><p><code>write(char[] cbuf)</code> ：写入字符数组 <code>cbuf</code>，等价于<code>write(cbuf, 0, cbuf.length)</code>。</p><p><code>write(char[] cbuf, int off, int len)</code> ：在<code>write(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</p><p><code>write(String str)</code> ：写入字符串，等价于 <code>write(str, 0, str.length())</code> 。</p><p><code>write(String str, int off, int len)</code> ：在<code>write(String str)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</p><p><code>append(CharSequence csq)</code> ：将指定的字符序列附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</p><p><code>append(char c)</code> ：将指定的字符附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</p><p><code>flush()</code> ：刷新此输出流并强制写出所有缓冲的输出字符。</p><p><code>close()</code>:关闭输出流释放相关的系统资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeOne</span><span class="params">(File file,Writer writer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        writer = <span class="keyword">new</span> FileWriter(file);</span><br><span class="line">        writer.write(<span class="string">&quot;我是panghutx&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;文件基础操作&quot;&gt;文件基础操作&lt;/h3&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="IO" scheme="https://youngsay.cn/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>多线程实例：线程池</title>
    <link href="https://youngsay.cn/2022/11/14/Java-ThreadPool/"/>
    <id>https://youngsay.cn/2022/11/14/Java-ThreadPool/</id>
    <published>2022-11-14T09:04:41.000Z</published>
    <updated>2022-11-14T10:43:43.259Z</updated>
    
    <content type="html"><![CDATA[<p>顾名思义，线程池就是存放线程的池子。直接用线程不就好了吗，为什么还需要线程池呢？</p><p>相比进程，线程已经轻量很多了，创建和销毁线程消耗的资源会少很多，但终究还是有消耗的。为了进一步降低消耗，我们需要用到线程池。需要用到线程时不用申请，直接从线程池中取，用完之后也不用销毁，再放进线程池。</p><p>标准库中的线程池（简化版本)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService pool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    pool.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟实现一个简化版本的线程池：</p><ol><li>描述任务：直接用Runnable接口即可</li><li>组织任务：用到阻塞队列</li><li>描述工作线程：创建Worker类继承Thread，重写run方法，从阻塞队列中取任务，然后执行任务</li><li>组织工作线程：实例化工作线程，加入到线程池，启动线程</li><li>提交任务：往线程池中添加任务（具体是将任务添加到阻塞队列）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreatPool</span> </span>&#123;</span><br><span class="line">    <span class="comment">//描述一个任务</span></span><br><span class="line">    <span class="comment">//组织一个任务</span></span><br><span class="line">    BlockingDeque&lt;Runnable&gt; queue = <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;();</span><br><span class="line">    <span class="comment">//描述一个线程</span></span><br><span class="line">    <span class="comment">//线程是用来执行任务的，而任务都存放在队列中</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="comment">//通过构造方法能够拿到外面的queue</span></span><br><span class="line">        <span class="keyword">private</span> BlockingDeque&lt;Runnable&gt; queue = <span class="keyword">null</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(BlockingDeque&lt;Runnable&gt; queue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.queue = queue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//从queue中取任务，然后执行任务</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Runnable runnable = queue.take();</span><br><span class="line">                    runnable.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//组织线程,创建线程</span></span><br><span class="line">    List&lt;Worker&gt; workers = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreatPool</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//创建线程，存放到线程池,执行线程</span></span><br><span class="line">            Worker worker = <span class="keyword">new</span> Worker(queue);</span><br><span class="line">            workers.add(worker);</span><br><span class="line">            worker.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提交任务到线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sumbit</span><span class="params">(Runnable runnable)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        queue.put(runnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreatPool pool = <span class="keyword">new</span> ThreatPool(<span class="number">10</span>);<span class="comment">//线程数10</span></span><br><span class="line">        <span class="comment">//执行1000个任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> workId = i;</span><br><span class="line">            pool.sumbit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;任务:&quot;</span>+workId+Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;顾名思义，线程池就是存放线程的池子。直接用线程不就好了吗，为什么还需要线程池呢？&lt;/p&gt;
&lt;p&gt;相比进程，线程已经轻量很多了，创建和销毁线程消耗的资源会少很多，但终究还是有消耗的。为了进一步降低消耗，我们需要用到线程池。需要用到线程时不用申请，直接从线程池中取，用完之后也不</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="多线程" scheme="https://youngsay.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程实例：定时器</title>
    <link href="https://youngsay.cn/2022/11/14/Java-Timer/"/>
    <id>https://youngsay.cn/2022/11/14/Java-Timer/</id>
    <published>2022-11-14T07:04:41.000Z</published>
    <updated>2022-11-14T07:18:08.606Z</updated>
    
    <content type="html"><![CDATA[<p>定时器是实际开发中常用的组件，例如文章的定时发布，双11的准点抢购活动等。</p><p>下面我们来看一下Java标准库中的定时器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">    timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该定时器会在3秒之后输出“hello”。创建一个定时器需要用到Timer类中的核心方法schedule，该方法内有两个参数，一个表示要执行的任务，一个表示任务在多长时间后执行。</p><p>认识了标准库中的定时器后，我们可以自己来模拟实现一个定时器。</p><p>首先，描述一个任务。创建一个MyTask类，类中有两个属性：一个是执行的任务，一个是任务执行时间。这两个属性类似于标准库schedule方法内的两个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">MyTask</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//具体要干啥</span></span><br><span class="line">    <span class="keyword">private</span> Runnable runnable;</span><br><span class="line">    <span class="comment">//啥时候开始干</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(Runnable runnable,<span class="keyword">long</span> dalay)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.runnable = runnable;</span><br><span class="line">        <span class="keyword">this</span>.time=System.currentTimeMillis()+dalay;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        runnable.run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(MyTask o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//时间小的排在前面</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (<span class="keyword">this</span>.time-o.time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，组织一个任务类。如何组织任务类呢，我们这里用到<strong>优先级阻塞队列</strong>。每个任务的执行时间（指的是在多长时间后执行）不同，根据时间大小来排序，进而优先执行队头任务，因此需要优先级队列。</p><p>最后，我们还需要一个线程不断的去扫描到了时间的任务，然后执行这个任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTimer</span></span>&#123;</span><br><span class="line">    <span class="comment">//组织一个任务</span></span><br><span class="line">    <span class="keyword">private</span> PriorityBlockingQueue&lt;MyTask&gt; queue = <span class="keyword">new</span> PriorityBlockingQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Object locker = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(Runnable runnable,<span class="keyword">long</span> delay)</span></span>&#123;</span><br><span class="line">        MyTask myTask = <span class="keyword">new</span> MyTask(runnable,delay);</span><br><span class="line">        queue.put(myTask);</span><br><span class="line">        <span class="keyword">synchronized</span> (locker)&#123;</span><br><span class="line">            locker.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行到时间的任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTimer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//取队首元素</span></span><br><span class="line">                    MyTask task = queue.take();</span><br><span class="line">                    <span class="keyword">long</span> time=System.currentTimeMillis();</span><br><span class="line">                    <span class="keyword">if</span>(time&lt;task.getTime())&#123;</span><br><span class="line">                        <span class="comment">//时间还没到</span></span><br><span class="line">                        queue.put(task);</span><br><span class="line">                        <span class="keyword">synchronized</span> (locker)&#123;</span><br><span class="line">                            locker.wait(task.getTime()-time);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//到时间了，执行这个任务</span></span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟一个定时器，总共分三步。第一步，<s>把冰箱打开</s>描述一个任务，即要执行的任务和任务多长时间后开始执行。第二步，组织一个任务，这里用到了优先级阻塞队列。第三步，利用一个线程扫描任务，执行到时间的任务。</p><p>下面有两个问题需要注意。</p><ol><li>任务类要放进优先级阻塞队列中，优先级阻塞队列根据时间先后进行排序。因此我们的任务类要实现<code>Comparable&lt;MyTask&gt;</code>接口，然后重写比较规则。</li><li>线程扫描任务，会从队头取元素，判断是否到时间了，如果没到，再放回队列。接着继续取元素……如果不加限制，它一直不停的扫描队首元素, 看看是否能执行这个任务，这样会大量消耗CPU。因此我们利用wait来使这个线程等待，时间到后再唤醒。此外当新加入一个任务后我们也需要用notify来唤醒扫描线程，因为可能该任务的时间更小，优先级更高，所以需要重新扫描任务队列。（这也就决定了必须用wait，而不能用sleep，因为sleep不能中途唤醒）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;定时器是实际开发中常用的组件，例如文章的定时发布，双11的准点抢购活动等。&lt;/p&gt;
&lt;p&gt;下面我们来看一下Java标准库中的定时器。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="多线程" scheme="https://youngsay.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程实例：阻塞队列</title>
    <link href="https://youngsay.cn/2022/11/14/Java-BlockingQueue/"/>
    <id>https://youngsay.cn/2022/11/14/Java-BlockingQueue/</id>
    <published>2022-11-14T04:04:41.000Z</published>
    <updated>2022-11-14T04:21:36.271Z</updated>
    
    <content type="html"><![CDATA[<p>阻塞队列是一种具有阻塞功能的队列，满足队列“先进先出”的特点，是一种线性安全的数据结构。当队列为空时，执行出队操作会进行阻塞，直到队列中有元素为止；当队列已经满了，执行入堆操作会进行阻塞，知道队列有空间为止。</p><p>阻塞队列的一个典型应用常见就是“生产者消费者”模型。毫无疑问，该模型有两个主体：生产者和消费者。生产者线程负责生产产品，将生产好的产品放进阻塞队列。消费者线程负责消费产品，直接从阻塞队列取产品。</p><p>生产者消费者模型具有解耦、平衡速度差异的特点。</p><p>解耦：生产者无需关注是谁在消费产品，消费了多少产品，只需关注生产操作即可；消费者无需关注是谁在生产产品，生产了多少产品，只需关注消费操作即可。</p><p>平衡速度差异：设想11.11，大量用户向服务器发送了大量的支付请求，一次性将这些请求交给服务器处理，服务器可能会hole不住，因此将这些请求都放进阻塞队列，消费者线程从阻塞队列一个一个地来处理请求就好了。这样就起到了“削峰填谷”的作用，平衡了生产者和消费者之间的速度差异。</p><h3 id="标准库中的阻塞队列：">标准库中的阻塞队列：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    BlockingDeque&lt;String&gt; queue = <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;();</span><br><span class="line">    queue.put(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    String s = queue.take();</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>BlockingQueue 是一个接口. 真正实现的类是 LinkedBlockingQueue.</li><li>put 方法用于阻塞式的入队列, take 用于阻塞式的出队列.</li><li>BlockingQueue 也有 offer, poll, peek 等方法, 但是这些方法不带有阻塞特性</li></ul><h3 id="模拟实现阻塞队列：">模拟实现阻塞队列：</h3><ul><li>循环队列+阻塞等待</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] elem = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object locker = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> val)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (locker)&#123;</span><br><span class="line">            <span class="comment">//队列满了，阻塞等待</span></span><br><span class="line">            <span class="keyword">if</span>(size==elem.length)&#123;</span><br><span class="line">                locker.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//一轮循环，让尾指针指向数组下标为0的位置</span></span><br><span class="line">            <span class="keyword">if</span>(tail==elem.length)&#123;</span><br><span class="line">                tail=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            elem[tail++]=val;</span><br><span class="line">            size++;</span><br><span class="line">            <span class="comment">//唤醒消费者线程的堵塞等待</span></span><br><span class="line">            locker.notify();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (locker)&#123;</span><br><span class="line">            <span class="comment">//队列空了，阻塞等待</span></span><br><span class="line">            <span class="keyword">if</span>(size==<span class="number">0</span>)&#123;</span><br><span class="line">                locker.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(head==elem.length)&#123;</span><br><span class="line">                head=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> ret = elem[head];</span><br><span class="line">            head++;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="comment">//唤醒生产者线程的堵塞等待</span></span><br><span class="line">            locker.notify();</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyQueue queue = <span class="keyword">new</span> MyQueue();</span><br><span class="line">        <span class="comment">//生产者线程</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.put(i);</span><br><span class="line">                    System.out.println(<span class="string">&quot;生产了：&quot;</span>+i);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//消费者线程</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> take = queue.take();</span><br><span class="line">                    System.out.println(<span class="string">&quot;消费了：&quot;</span>+take);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;阻塞队列是一种具有阻塞功能的队列，满足队列“先进先出”的特点，是一种线性安全的数据结构。当队列为空时，执行出队操作会进行阻塞，直到队列中有元素为止；当队列已经满了，执行入堆操作会进行阻塞，知道队列有空间为止。&lt;/p&gt;
&lt;p&gt;阻塞队列的一个典型应用常见就是“生产者消费者”模型</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="多线程" scheme="https://youngsay.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java线程的创建及状态</title>
    <link href="https://youngsay.cn/2022/10/12/Java-Thread/"/>
    <id>https://youngsay.cn/2022/10/12/Java-Thread/</id>
    <published>2022-10-12T13:04:41.000Z</published>
    <updated>2022-11-14T10:47:20.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是线程">什么是线程</h2><p>在计算机中，一个任务就是一个进程。打开任务管理器，我们可以看见多个进程。如浏览器，QQ。线程是进程的再划分，是进程的一部分。一个进程可以只有一个线程（主线程），也可以有多个线程。拿浏览器举例，打开浏览器的多个网页，一个网页在播放音乐，一个网页在播放视频，一个网页在浏览博客。每个网页有不同的分工，这些浏览器的每个子任务就是一个线程。</p><p>线程是更轻量的进程，创建一个线程的消耗要低于创建一个进程，且同一进程的不同线程之间可以共享资源，效率更高。通过多线程可以更好地实现并发编程。</p><p><strong>进程vs线程</strong></p><ul><li>进程包含线程，进程是线程的一部分，一个进程中至少包含一个线程。</li><li>进程与进程之间不能共享资源，同一个进程的线程之间可以共享资源。</li><li>进程是系统分配资源的最小单位，线程是系统调度执行的最小单位。</li><li>多进程稳定性高于多线程，一个进程的崩溃不会影响其他线程；多线程下一个线程的崩溃可能影响该进程。</li></ul><h2 id="创建线程">创建线程</h2><p>一个线程至少包含一个进程，<code>main()</code>就是一个线程，我们还可以在里面创建多个线程。</p><p><strong>1.继承<code>Thread</code>类,重写<code>run()</code>方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.创建<code>Thread</code>实例，实现<code>Runnable</code>接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.其他变形</strong></p><ul><li>匿名内部类创建Thread子类对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;使用匿名类创建 Thread 子类对象&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>匿名内部类创建Runnable子类对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;使用匿名类创建 Runnable 子类对象&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>lambda表达式创建Thread子类对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread t4 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;使用匿名类创建 Thread 子类对象&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Thread方法"><code>Thread</code>方法</h2><p><strong>常见构造方法</strong></p><table><thead><tr><th>构造方法</th></tr></thead><tbody><tr><td><code>Thread()</code>  分配一个新的 <code>Thread</code>对象。</td></tr><tr><td><code>Thread(Runnable target)</code>  分配一个新的 <code>Thread</code>对象。</td></tr><tr><td><code>Thread(Runnable target, String name)</code>  分配一个新的 <code>Thread</code>对象，name为新线程的名字。</td></tr><tr><td><code>Thread(String name)</code>  分配一个新的 <code>Thread</code>对象，name为新线程的名字。</td></tr></tbody></table><p><strong>启动一个线程.start()</strong></p><p>Thread对象对创建后，并没有启动线程，执行该指令后才会真正创建一个线程。即内核中创建了一个内存控制块PCB。</p><p><strong>中断一个线程</strong></p><p>方法1：自定义变量作为标志位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义变量flag作为标志位</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程正在运行&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>); <span class="comment">//使线程进入休眠状态</span></span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：<code>interrupted()</code>方法中断线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程运行中&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Thread.currentThread().isInterrupted()</code>获取当前线程是否被中断；<code>interrupted()</code>向线程发出中断请求。</p><p>Thread收到通知方式有两种：①当线程因wait/sleep/join等方法处于堵塞状态时，以 <code>InterruptedException </code>异常的形式通知。②<code>isInterrupted()</code>标志位置为true.</p><p><strong>等待一个线程.join()</strong></p><p>执行该指令，会使该线程执行结束后再执行下一线程，即将并发编程变成了串行。比如用某软件下载一部电影，可以边下载边观看，当执行该指令后，就要等下载完后再看了~</p><p><strong>休眠一个线程sleep()</strong></p><p>让线程进入休眠状态，进入休眠状态的指令，他的属性<code>isAlive()</code>为Timed Waiting。线程状态会稍后介绍到。</p><h2 id="线程状态">线程状态</h2><p>注意，这里我们说的是java线程的六种状态。利用<code>isAlive</code>属性可以观察线程的状态，线程有以下6种状态：</p><ul><li>New：新创建的线程，但未执行<code>start()</code>，线程没有存活；</li><li>Runnable：运行中的线程，正在执行<code>run()</code>方法的Java代码；</li><li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li><li>Waiting：运行中的线程，因为某些操作在等待中，如执行<code>wait()</code>方法；</li><li>Timed Waiting：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待；</li><li>Terminated：线程结束，线程没有存活。</li></ul><h2 id="线程状态转换">线程状态转换</h2><p>线程被创建出来，处于New状态。调用start方法后，处于Runnable状态。当线程获取不到锁时，处于Blocked状态，直到获取到锁后进入Runnable状态。运行的线程调用wait或join方法后会进入Waiting状态，直到唤醒通知后进入Runnable状态。调用带有超时参数的方法后会进入Timed Waiting状态，直到时间到后进入Runnable状态。运行的线程执行完run方法或出现异常后进入Terminated状态。</p><p>与操作系统中的进程状态不同，java没有就绪态。操作系统中，一个进程调用start后并没有直接运行，而是进入就绪态，当获取到cpu时间片后进入运行态。我们可以认为在java中，就绪态和运行态同属于Runnable。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是线程&quot;&gt;什么是线程&lt;/h2&gt;
&lt;p&gt;在计算机中，一个任务就是一个进程。打开任务管理器，我们可以看见多个进程。如浏览器，QQ。线程是进程的再划分，是进程的一部分。一个进程可以只有一个线程（主线程），也可以有多个线程。拿浏览器举例，打开浏览器的多个网页，一个网页</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="多线程" scheme="https://youngsay.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程安全及解决方案</title>
    <link href="https://youngsay.cn/2022/09/26/Thread-safe/"/>
    <id>https://youngsay.cn/2022/09/26/Thread-safe/</id>
    <published>2022-09-26T09:40:41.000Z</published>
    <updated>2022-11-14T04:22:10.251Z</updated>
    
    <content type="html"><![CDATA[<p>安全，已经成为非常重要的社会话题。所谓“安全第一”，“安全无小事”（手动滑稽），同样，多线程中，线程安全也是非常重要的话题。那么是什么原因造成了线程不安全，又如何解决线程不安全呢？</p><h3 id="造成线程不安全的原因">造成线程不安全的原因</h3><ol><li><p>线程的调度</p><p>各线程之间是抢占式执行的，线程的执行顺序是随机的，因此可能会产生各种问题。现在最流行什么？做核酸！如果做核酸是抢占式的，做核酸没有一个顺序，做核酸顺序完全靠运气，这能安全吗！</p></li><li><p>多线程同时修改同一变量</p><p>如果是多线程同时读取同一变量，不涉及修改的操作，是线程安全的。但如果多线程同时修改同一变量，这能不乱吗？想当年家里买了一台电脑，我姐姐要用电脑玩QQ炫舞，我要用电脑玩穿越火线，你争我抢，打的是不可开交。</p></li><li><p>操作指令不是原子的</p><p>例如一条加法指令，其实要执行三条指令，load、add、save，先将内存中的变量加载到寄存器，在寄存器中完成加法操作，再将结果写会内存中。假设线程1完成了load、add操作，线程2完成了load、add、save操作，当线程1再去执行save操作，便将线程2的操作覆盖了，线程2说：线程1真是一个猪队友。</p></li><li><p>内存可见性</p><p>线程1循环进行读操作，线程2看心情进行修改操作。我们知道，读操作是将内存变量加载到寄存器，然后读取寄存器。而线程1循环加载内存中的值到寄存器，线程2又迟迟不修改，线程1说：你当我傻吗？于是线程1干脆去读取寄存器了，这就是编译器的优化。拿做核酸举例，最初是刮嗓子，但日复一日，现在有些已经是刮舌头了，这难道是疫情的优化？大部分情况下是安全的，但也可能会翻车。线程1循环读操作，线程2突然心情不好，很快啊，修改了内存中的值。而线程1却绕过了内存，从寄存器读值，这能安全吗！</p></li></ol><h3 id="解决方案">解决方案</h3><p>针对原因1，线程的调度就是抢占式执行的，我们无能为力。针对原因2，我们可以通过调整代码结构，使不同线程操作不同变量，但我这菜鸡技术，既然能写出一个bug，就能写出无数个bug，一顿调整猛如虎，结果bug乘以5.</p><p>所以我们解决方案寄托在原因3、4上。</p><p>Java中提供了<code>synchronized</code>关键字来对操作上锁。拿上面的加法操作举例，为加法这一方法加上synchronized后，就为该操作上锁了。想象要在卫生间完成加法操作，（不敢想象），小县城来的孩子线程1来执行加法操作，发现卫生间没人，他进来后把门锁上，进行加法操作。又一个小县城的孩子线程2来到卫生间前，也想要做加法操作，发现门锁了，只好等到线程1出来后才能进去，他是等也得等，不等也得等，这样就保证了操作的原子性。</p><p>Java还提供了<code>volatile</code>关键字来解决内存可见性问题，synchronized也可以解决该问题，只不过开销更大。为代码加上volatile后，就能禁止编译器进行优化，线程1无论做多少次循环读操作，都要耐心地从内存中读值，不能直接去读取寄存器中的值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;安全，已经成为非常重要的社会话题。所谓“安全第一”，“安全无小事”（手动滑稽），同样，多线程中，线程安全也是非常重要的话题。那么是什么原因造成了线程不安全，又如何解决线程不安全呢？&lt;/p&gt;
&lt;h3 id=&quot;造成线程不安全的原因&quot;&gt;造成线程不安全的原因&lt;/h3&gt;
&lt;ol&gt;
&lt;</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="多线程" scheme="https://youngsay.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java单例模式：懒汉模式和饿汉模式</title>
    <link href="https://youngsay.cn/2022/09/21/Java-Singleton/"/>
    <id>https://youngsay.cn/2022/09/21/Java-Singleton/</id>
    <published>2022-09-21T13:04:41.000Z</published>
    <updated>2022-11-14T04:21:23.114Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式，就是一个类中只有一个实例。主要有懒汉模式和饿汉模式。</p><p>饿汉模式是在类加载的同时就创建实例，而懒汉模式是使用时才创建实例。</p><h3 id="饿汉模式">饿汉模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.使用static创建一个实例，并且立即实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">//2.为了防止在其他地方不小心new这个Singleton，把方法构造为private</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//3.提供一个方法，让外面能够拿到唯一实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在多线程中，多个线程对同一数据进行读操作，线程安全。</p><h3 id="懒汉模式">懒汉模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.不立即初始化实例，使用时再初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//2.将构造方法设为private</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//3.提供方法获取实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多线程中，多个线程对同一对象进行读、写操作，线程不安全。线程不安全出现在首次创建实例时，多个线程同时调用getInstance方法，可能创造出多个实例。</p><p>改进1：</p><p>对getInstance方法加锁，保证操作的原子性，实现线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.不立即初始化实例，使用时再初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//2.将构造方法设为private</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//3.提供方法获取实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这种方法性能较差，毕竟线程不安全只出现在首次创建实例时，为getInstance方法加锁后每次都要加锁解锁，所以做如下改进。</p><p>改进2：</p><p>进入getInstance方法后首先判断instance是否为空，即是否为第一次创建实例，是才需要加锁，否则不需要加锁。同时为了避免 “内存可见性” 导致读取的 instance 出现偏差, 因此为instance加上volatile。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.不立即初始化实例，使用时再初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton1 instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//2.将构造方法设为private</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//3.提供方法获取实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;单例模式，就是一个类中只有一个实例。主要有懒汉模式和饿汉模式。&lt;/p&gt;
&lt;p&gt;饿汉模式是在类加载的同时就创建实例，而懒汉模式是使用时才创建实例。&lt;/p&gt;
&lt;h3 id=&quot;饿汉模式&quot;&gt;饿汉模式&lt;/h3&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;tabl</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="多线程" scheme="https://youngsay.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【JavaWeb】Thymeleaf模板引擎</title>
    <link href="https://youngsay.cn/2022/06/09/Java-Thymeleaf/"/>
    <id>https://youngsay.cn/2022/06/09/Java-Thymeleaf/</id>
    <published>2022-06-09T11:40:41.000Z</published>
    <updated>2022-10-20T11:58:10.263Z</updated>
    
    <content type="html"><![CDATA[<p>上篇博客中，我们了解了服务器渲染，并用Thymeleaf模板引擎写了一个简单的猜数字小游戏。</p><p>下面我们简单了解一下Thymeleaf的语法。</p><h4 id="Thymeleaf常见命令">Thymeleaf常见命令</h4><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>th:text</td><td>在标签体中展示表达式求值结果的文本内容</td></tr><tr><td>th:[HTML标签属性]</td><td>设置任意的 HTML 标签属性的值</td></tr><tr><td>th:if</td><td>当表达式的结果为真时则显示内容，否则不显示</td></tr><tr><td>th:each</td><td>循环访问元素</td></tr></tbody></table><p>Thymeleaf语法有很多，我们这里先简单介绍这四个。th:text和th:if在猜数字小游戏案例已经使用过，这里不再介绍。</p><h5 id="th-属性">th:[属性]</h5><ul><li>HTML模板代码：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;$&#123;url1&#125;&quot;</span>&gt;</span>胖虎同学<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;$&#123;url2&#125;&quot;</span>&gt;</span>胖虎同学1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Servlet代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/thymeleafUrl.html&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThymeleafUrlServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.创建核心类,用于完成页面渲染</span></span><br><span class="line">    <span class="keyword">public</span> TemplateEngine engine = <span class="keyword">new</span> TemplateEngine();</span><br><span class="line">    <span class="comment">//2.初始化模板引擎,创建解析器，加载文件，关联</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ServletContext context = getServletContext();</span><br><span class="line">        ServletContextTemplateResolver resolver = <span class="keyword">new</span> ServletContextTemplateResolver(context);</span><br><span class="line">        resolver.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        resolver.setPrefix(<span class="string">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class="line">        resolver.setSuffix(<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">        engine.setTemplateResolver(resolver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        ServletContext context = getServletContext();</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//3.实例化WebContext，关联变量</span></span><br><span class="line">        WebContext webContext = <span class="keyword">new</span> WebContext(req,resp,context);</span><br><span class="line">        webContext.setVariable(<span class="string">&quot;url1&quot;</span>,<span class="string">&quot;https://youngsay.cn&quot;</span>);</span><br><span class="line">        webContext.setVariable(<span class="string">&quot;url2&quot;</span>,<span class="string">&quot;http://blog.youngsay.cn&quot;</span>);</span><br><span class="line">        <span class="comment">//4.渲染</span></span><br><span class="line">        engine.process(<span class="string">&quot;thymeleafUrl&quot;</span>,webContext,resp.getWriter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="th-each">th:each</h5><p>列举游戏战绩：昵称、击杀、死亡、得分</p><ul><li>HTML模板代码：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">th:each</span>=<span class="string">&quot;person : $&#123;persons&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;person.name&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;person.kill&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;person.dead&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;person.score&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Servlet代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> kill;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> dead;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> kill, <span class="keyword">int</span> dead, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.kill = kill;</span><br><span class="line">        <span class="keyword">this</span>.dead = dead;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/thymeleafEach&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThymeleafEach</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建TemplateEngine对象</span></span><br><span class="line">    <span class="keyword">public</span> TemplateEngine engine = <span class="keyword">new</span> TemplateEngine();</span><br><span class="line">    <span class="comment">//初始化模板引擎</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServletContext context = getServletContext();</span><br><span class="line">        ServletContextTemplateResolver resolver = <span class="keyword">new</span> ServletContextTemplateResolver(context);</span><br><span class="line">        resolver.setPrefix(<span class="string">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class="line">        resolver.setSuffix(<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">        resolver.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        engine.setTemplateResolver(resolver);</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        List&lt;Person&gt; persons = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">        persons.add(<span class="keyword">new</span> Person(<span class="string">&quot;損友比过狗友i&quot;</span>,<span class="number">12</span>,<span class="number">2</span>,<span class="number">80</span>));</span><br><span class="line">        persons.add(<span class="keyword">new</span> Person(<span class="string">&quot;马棚管理员&quot;</span>,<span class="number">21</span>,<span class="number">8</span>,<span class="number">130</span>));</span><br><span class="line">        persons.add(<span class="keyword">new</span> Person(<span class="string">&quot;吃枣药丸&quot;</span>,<span class="number">16</span>,<span class="number">5</span>,<span class="number">110</span>));</span><br><span class="line">        ServletContext context = getServletContext();</span><br><span class="line">        WebContext webContext = <span class="keyword">new</span> WebContext(req,resp,context);</span><br><span class="line">        webContext.setVariable(<span class="string">&quot;persons&quot;</span>,persons);</span><br><span class="line"></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        engine.process(<span class="string">&quot;thymeleafEach&quot;</span>,webContext, resp.getWriter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ServletContext">ServletContext</h4><p>观察上篇博客猜数字游戏代码和上面的两段代码，我们发现，每个Servlet都创建了一个TemplateEngine对象并进行初始化，其实这完全没必要，一个webapp中，只创建一个TemplateEngine对象即可。</p><p>这就需要用到ServletContext，它是Servlet程序全局存储信息的空间，每个webapp中只有一个ServlectContext，多个Servlet之间共享一个ServlectContext。通过 HttpServlet.getServletContext() 方法获取到当前webapp 的ServletContext对象。</p><p>下面是ServletContext常见方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>void setAttribute(String name, Object obj)</td><td>设置属性(键值对)</td></tr><tr><td>Object getAttribute(String name)</td><td>根据属性名获取属性值, 如果 name 不存在, 返 回 null</td></tr><tr><td>void removeAttribute(String name)</td><td>删除对应的属性</td></tr></tbody></table><p>我们用代码来证明多个一个webapp中多个Servlet类共用一个ServletContext。</p><ul><li>创建一个WriterServlet类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/writer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取message参数</span></span><br><span class="line">        String message = req.getParameter(<span class="string">&quot;message&quot;</span>);</span><br><span class="line">        ServletContext context = getServletContext();</span><br><span class="line">        <span class="comment">//2.将message设置到ServletContext</span></span><br><span class="line">        context.setAttribute(<span class="string">&quot;message&quot;</span>,message);</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//3.返回结果</span></span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;设置成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建一个ReaderServlet类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/reader&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.读取ServletContext中的message值</span></span><br><span class="line">        ServletContext context = getServletContext();</span><br><span class="line">        String message = (String) context.getAttribute(<span class="string">&quot;message&quot;</span>);</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//2.返回读到的值</span></span><br><span class="line">        resp.getWriter().write(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cos.youngsay.cn/blog/202206101502724.gif" alt="展示结果"></p><h4 id="监听器">监听器</h4><p>要想做到一个webapp中只创建一个TemplateEngine对象，除了认识ServletContext，还需要了解监听器。</p><p>使用监听器监听ServletContext的创建，创建好后在ServletContext完成初始化操作，后续的 Servlet 直接从 ServletContext 中获取到engine实例即可，不必每创建一个Servlet都初始化一次。</p><p>首先创建一个监听器类Mylistener，实现ServletContextListener接口，重写contextInitialized方法。在contextInitialized方法内完成初始化等一系列操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.通过方法的参数可以获取到ServletContext</span></span><br><span class="line">        ServletContext context = sce.getServletContext();</span><br><span class="line">        <span class="comment">//2.创建TemplateEngine类对象engine</span></span><br><span class="line">        TemplateEngine engine = <span class="keyword">new</span> TemplateEngine();</span><br><span class="line">        <span class="comment">//3.创建解析器</span></span><br><span class="line">        ServletContextTemplateResolver resolver = <span class="keyword">new</span> ServletContextTemplateResolver(context);</span><br><span class="line">        <span class="comment">//4.加载文件</span></span><br><span class="line">        resolver.setPrefix(<span class="string">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class="line">        resolver.setSuffix(<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">        resolver.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//5.关联engine和解析器</span></span><br><span class="line">        engine.setTemplateResolver(resolver);</span><br><span class="line">        <span class="comment">//6.将engine放到ServletContext中,后续直接调用getAttribute获取engine</span></span><br><span class="line">        context.setAttribute(<span class="string">&quot;engine&quot;</span>,engine);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了MyListener类，之前代码中engine对象的创建和init方法内的初始化操作都可以删掉了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上篇博客中，我们了解了服务器渲染，并用Thymeleaf模板引擎写了一个简单的猜数字小游戏。&lt;/p&gt;
&lt;p&gt;下面我们简单了解一下Thymeleaf的语法。&lt;/p&gt;
&lt;h4 id=&quot;Thymeleaf常见命令&quot;&gt;Thymeleaf常见命令&lt;/h4&gt;
&lt;table&gt;
&lt;thea</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="JavaWeb" scheme="https://youngsay.cn/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>【JavaWeb】服务器渲染</title>
    <link href="https://youngsay.cn/2022/06/09/Java-templateEngine/"/>
    <id>https://youngsay.cn/2022/06/09/Java-templateEngine/</id>
    <published>2022-06-09T08:40:41.000Z</published>
    <updated>2022-06-09T08:44:44.970Z</updated>
    
    <content type="html"><![CDATA[<p>页面渲染，所谓渲染就是将数据和页面相结合，根据用户传送的数据不同，页面渲染后的内容也不同。页面渲染可以在服务器端完成，也可以在客户端完成。<strong>服务器渲染</strong>是将用户传来的数据在服务器端拼接成HTML后传给客户端，而<strong>客户端渲染</strong>是在客户端将服务器传来的数据拼接成HTML。</p><p><img src="https://cos.youngsay.cn/blog/202206091642034.png" alt="页面渲染"></p><h4 id="服务器渲染">服务器渲染</h4><p>这篇博客主要介绍一下服务器渲染。</p><p>我们可以用字符串拼接的方式，将数据拼接成HTML页面。下面我们用字符串拼接的方式完成一个猜数字web版的小游戏。</p><p>首先约定好交互方式。</p><ul><li>GET /guess</li></ul><p>通过get请求，从服务器得到一个页面响应，同时在服务器生成一个1-100的随机数。</p><ul><li>POST /guess</li></ul><p>通过post请求，将用户输入的数提交到服务器，在服务器比较用户输入的数和随机数的大小，将比较结果和次数返回。</p><p>约定好交互方式后，我们创建一个GuessNumServlet类，关联到/guess路径，用doGet方法实现第一个交互接口，doPost方法实现第二个交互接口。代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/guess&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuessNumServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//生成一个随机数</span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//随机数范围在[1,100]</span></span><br><span class="line">        num = random.nextInt(<span class="number">100</span>)+<span class="number">1</span>; <span class="comment">//得到一个1-100之间的随机数</span></span><br><span class="line">        <span class="comment">//设置响应的类型格式</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//字符串拼接响应页面</span></span><br><span class="line">        StringBuilder html = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        html.append(<span class="string">&quot;&lt;form action=\&quot;guess\&quot; method=\&quot;post\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        &lt;input type=\&quot;text\&quot; name=\&quot;guessNum\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        &lt;input type=\&quot;submit\&quot; value=\&quot;确认输入\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    &lt;/form&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">//返回响应</span></span><br><span class="line">        resp.getWriter().write(html.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//设置响应格式</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//得到用户猜的数字</span></span><br><span class="line">        <span class="keyword">int</span> guessNum = Integer.parseInt(req.getParameter(<span class="string">&quot;guessNum&quot;</span>));</span><br><span class="line">        String result =<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//比较用户输入的数字和生成的随机数</span></span><br><span class="line">        <span class="keyword">if</span>(guessNum&lt;num)&#123;</span><br><span class="line">            result=<span class="string">&quot;猜小了&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(guessNum&gt;num)&#123;</span><br><span class="line">            result=<span class="string">&quot;猜大了&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result=<span class="string">&quot;猜对了&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">//字符串拼接响应界面</span></span><br><span class="line">        StringBuilder html = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        html.append(<span class="string">&quot;&lt;form action=\&quot;guess\&quot; method=\&quot;post\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        &lt;input type=\&quot;text\&quot; name=\&quot;guessNum\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        &lt;input type=\&quot;submit\&quot; value=\&quot;确认输入\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    &lt;/form&gt;&quot;</span>);</span><br><span class="line">        html.append(<span class="string">&quot;&lt;div&gt;&quot;</span>+result+<span class="string">&quot;&lt;/div&gt;&quot;</span>);</span><br><span class="line">        html.append(<span class="string">&quot;&lt;div&gt;&quot;</span>+<span class="string">&quot;猜的次数：&quot;</span>+count+<span class="string">&quot;&lt;/div&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">//返回响应界面</span></span><br><span class="line">        resp.getWriter().write(html.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上段代码，我们发现十分简单的页面拼接起来却如此复杂，代码可读性不高。其实我们有一种更好的方式来完成服务器渲染，那就是<strong>模板引擎</strong>。</p><h4 id="模板引擎">模板引擎</h4><p>上面的代码Java和HTML代码都混在了一起，模板引擎可以将JAVA和HTML代码分离，将HTML放到单独的文件。HTML中需要变动的部分用占位符占位，当服务器计算响应完毕后，将HTML模板中的占位符替换成计算后的内容，返回给客户端。</p><p>Java中有很多模板引擎，这里用的是Thymeleaf 。</p><p>如何使用Thymeleaf，我们上面的猜数字小游戏为例，将上段代码改成模板引擎版本。</p><p><strong>首先需要引入依赖。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.thymeleaf/thymeleaf --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;thymeleaf&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">3.0</span><span class="number">.12</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>接着创建一个HTML模板</strong>，创建路径是<code>webapps/WEB-INF/templates  </code>,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;GuessNum&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;guessNum&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;确认输入&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;div th:<span class="keyword">if</span>=<span class="string">&quot;$&#123;!first&#125;&quot;</span>&gt;</span><br><span class="line">    &lt;div th:text=<span class="string">&quot;$&#123;result&#125;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div th:text=<span class="string">&quot;$&#123;count&#125;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>有$符号的地方就是一个占位符，最终会被替换成计算好的结果。</p><p><strong>最后创建Servlet类</strong>：<code>GuessNumTemplateEngine</code>。</p><ul><li>创建一个TemplateEngine的类，这个类是服务器渲染的核心类。</li><li>初始化模板引擎：创建一个ServletContextTemplateResolver类的解析器，结合ServletContext使用，用来加载要渲染的文件，然后与TemplateEngine相关联。</li><li>通过WebContext类将模板文件的变量与Java中的变量相关联。</li><li>通过TemplateEngine的process方法完成渲染。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/GuessNum&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuessNumTemplateEngine</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">//核心，用于完成页面的渲染</span></span><br><span class="line">    <span class="keyword">public</span> TemplateEngine engine = <span class="keyword">new</span> TemplateEngine();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> randomNum;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对模板引擎初始化</span></span><br><span class="line">        ServletContextTemplateResolver resolver = <span class="keyword">new</span> ServletContextTemplateResolver(<span class="keyword">this</span>.getServletContext());</span><br><span class="line">        resolver.setPrefix(<span class="string">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class="line">        resolver.setSuffix(<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">        resolver.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        engine.setTemplateResolver(resolver);</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        randomNum = random.nextInt(<span class="number">100</span>)+<span class="number">1</span>;</span><br><span class="line">        WebContext webContext = <span class="keyword">new</span> WebContext(req,resp,getServletContext());</span><br><span class="line">        webContext.setVariable(<span class="string">&quot;first&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        engine.process(<span class="string">&quot;guessNum&quot;</span>,webContext,resp.getWriter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html; charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//1.获取用户输入的数字</span></span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(req.getParameter(<span class="string">&quot;guessNum&quot;</span>));</span><br><span class="line">        String result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">// 2. 和 随机数 进行比较</span></span><br><span class="line">        <span class="keyword">if</span> (num &lt; randomNum) &#123;</span><br><span class="line">            result = <span class="string">&quot;猜低了&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; randomNum) &#123;</span><br><span class="line">            result = <span class="string">&quot;猜高了&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="string">&quot;猜对了&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 自增猜的次数</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">//4.返回响应界面</span></span><br><span class="line">        WebContext context = <span class="keyword">new</span> WebContext(req,resp,getServletContext());</span><br><span class="line">        context.setVariable(<span class="string">&quot;first&quot;</span>,<span class="keyword">false</span>);</span><br><span class="line">        context.setVariable(<span class="string">&quot;result&quot;</span>,result);</span><br><span class="line">        context.setVariable(<span class="string">&quot;count&quot;</span>,count);</span><br><span class="line">        engine.process(<span class="string">&quot;guessNum&quot;</span>,context,resp.getWriter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;页面渲染，所谓渲染就是将数据和页面相结合，根据用户传送的数据不同，页面渲染后的内容也不同。页面渲染可以在服务器端完成，也可以在客户端完成。&lt;strong&gt;服务器渲染&lt;/strong&gt;是将用户传来的数据在服务器端拼接成HTML后传给客户端，而&lt;strong&gt;客户端渲染&lt;/st</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="JavaWeb" scheme="https://youngsay.cn/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>【JavaWeb】Servlet上传文件</title>
    <link href="https://youngsay.cn/2022/06/08/Java-uploadFile/"/>
    <id>https://youngsay.cn/2022/06/08/Java-uploadFile/</id>
    <published>2022-06-08T13:40:41.000Z</published>
    <updated>2022-06-08T13:46:44.727Z</updated>
    
    <content type="html"><![CDATA[<p>Servlet支持上传文件操作，在HttpServletRequest类中，通过Part对象的getPart方法便可以获取请求中指定name的文件。</p><p>上传文件分为两个部分，前端部分和后端部分，关于文件操作，这两个部分都很简单，代码量很少。</p><p>各文件路径如下：</p><p><img src="https://cos.youngsay.cn/blog/202206082140961.png" alt="maven各文件路径"></p><p><strong>前端页面</strong>：创建一个html文件，通过form表单的action属性，与后端Servlet相关联，method属性指定方法，上传文件通常为post，通过enctype属性指定编码方式，上传文件为multipart/form-data。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;file&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;myFile&quot;</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p><strong>后端部分</strong>：创建一个上传文件的类Upload，继承HttpServlet，@WebServlet()注解内容与前端页面form表单的action路径相同(此处有<code>/</code>)，此外还需要<code>@MultipartConfig</code>注解,缺少该注解将无法正确读取文件。 通过Part对象的getPart()方法获取文件，方法内参数为前端界面input中类型为file格式的name属性值。通过write方法可以将文件写入磁盘，方法内参数为磁盘路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MultipartConfig</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/file&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Upload</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        Part part = req.getPart(<span class="string">&quot;myFile&quot;</span>);</span><br><span class="line">        System.out.println(part.getContentType());</span><br><span class="line">        System.out.println(part.getName());</span><br><span class="line">        System.out.println(part.getSize());</span><br><span class="line">        part.write(<span class="string">&quot;d:/myFile.png&quot;</span>);</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;上传成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Servlet支持上传文件操作，在HttpServletRequest类中，通过Part对象的getPart方法便可以获取请求中指定name的文件。&lt;/p&gt;
&lt;p&gt;上传文件分为两个部分，前端部分和后端部分，关于文件操作，这两个部分都很简单，代码量很少。&lt;/p&gt;
&lt;p&gt;各文件</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="JavaWeb" scheme="https://youngsay.cn/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>时间复杂度和空间复杂度</title>
    <link href="https://youngsay.cn/2022/06/04/algorithm-complexity/"/>
    <id>https://youngsay.cn/2022/06/04/algorithm-complexity/</id>
    <published>2022-06-04T13:40:41.000Z</published>
    <updated>2022-06-04T14:22:53.531Z</updated>
    
    <content type="html"><![CDATA[<p>如何衡量一个算法的好坏？我们可以从时间和空间两个方面入手，也就是时间复杂度和空间复杂度。</p><p>无论是时间复杂度还是空间复杂度，都采用<strong>大O的渐进表示法</strong>。只保留最高阶项，且最高阶项的系数为1.例如一个算法的执行次数是2N^2+M+3,那么该算法的时间复杂度是O（N^2)。</p><h3 id="时间复杂度">时间复杂度</h3><p>时间复杂度的衡量标准也就是算法的执行次数。我们下面用几段代码来练习一下算法时间复杂度的计算。</p><ul><li>冒泡排序的时间复杂度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> end = array.length; end &gt; <span class="number">0</span>; end--) &#123;</span><br><span class="line"><span class="keyword">boolean</span> sorted = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; end; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (array[i - <span class="number">1</span>] &gt; array[i]) &#123;</span><br><span class="line">Swap(array, i - <span class="number">1</span>, i);</span><br><span class="line">sorted = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sorted == <span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>假设有N个元素，最坏的情况下需要走N-1趟，每趟排序end-1次。例如有5个元素，N-5，那么需要走4趟，每趟排列次数分别为4,3,2,1。刚好构成等差数列，可以用等差数列求和公式计算执行次数,也就是<code>[(N*（N-1))]/2</code>。</p><p>按照大O的渐进表示法，时间复杂度是O（N^2)。</p><ul><li>二分查找的时间复杂度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (begin &lt;= end) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = begin + ((end-begin) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (array[mid] &lt; value)</span><br><span class="line">    begin = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &gt; value)</span><br><span class="line">    end = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二份查找的好处是每次能去掉一半，第一次是去掉一半还剩一半，第二次去掉一半还剩1/4，第三次去掉一半还剩1/8……如下图所示：</p><p><img src="https://cos.youngsay.cn/blog/202206042220754.png" alt="image-20220604213754161"></p><p>所以二分查找的时间复杂度是O（logN）</p><ul><li>递归求阶乘的时间复杂度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> N &lt; <span class="number">2</span> ? N : factorial(N-<span class="number">1</span>) * N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归算法的时间复杂度 = 递归的次数 * 每次递归执行的次数</p><p>递归求阶乘算法递归次数为N，每次递归执行1次，所以时间复杂度是O（N）。</p><ul><li>递归求斐波那契数列</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> N &lt; <span class="number">2</span> ? N : fibonacci(N-<span class="number">1</span>)+fibonacci(N-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归次数，也就是层数为N的二叉树最多的结点个数，(2^N) - 1。</p><p>所以时间复杂度是O（2^N)。</p><h3 id="空间复杂度">空间复杂度</h3><p>空间复杂度的衡量标准是临时占用的存储空间大小。随着计算机的发展，存储空间越来越大，空间复杂度也就不必太过关注。</p><ul><li>递归求阶乘的空间复杂度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> N &lt; <span class="number">2</span> ? N : factorial(N-<span class="number">1</span>)*N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归了N次，开辟了N个栈帧，每个栈帧占用常数的存储空间，所以该算法的空间复杂度是O（N）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如何衡量一个算法的好坏？我们可以从时间和空间两个方面入手，也就是时间复杂度和空间复杂度。&lt;/p&gt;
&lt;p&gt;无论是时间复杂度还是空间复杂度，都采用&lt;strong&gt;大O的渐进表示法&lt;/strong&gt;。只保留最高阶项，且最高阶项的系数为1.例如一个算法的执行次数是2N^2+M+3,</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="数据结构和算法" scheme="https://youngsay.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【JavaSE】认识String类</title>
    <link href="https://youngsay.cn/2022/06/03/Java-String/"/>
    <id>https://youngsay.cn/2022/06/03/Java-String/</id>
    <published>2022-06-03T03:40:41.000Z</published>
    <updated>2022-06-08T13:43:16.312Z</updated>
    
    <content type="html"><![CDATA[<h3 id="创建一个Sting">创建一个Sting</h3><p>String有三种构造方法，分别为直接赋值、new String方法构造和字符串数组构造。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1</span></span><br><span class="line">String str1=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line">String str2=<span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//方法3</span></span><br><span class="line"><span class="keyword">char</span>[] arr=&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">String str3=<span class="keyword">new</span> String(arr);</span><br></pre></td></tr></table></figure><p>String是一种引用类型，内部并不存储字符串本身。</p><h3 id="Sting的存储结构">Sting的存储结构</h3><p>观察下段代码，输出结果是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str1=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String str11=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String str2=<span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">String str22=<span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">String str3=<span class="string">&quot;world&quot;</span>;</span><br><span class="line">System.out.println(str1==str11); <span class="comment">//true</span></span><br><span class="line">System.out.println(str2==str22); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>输出结果分别为true、false。</p><p>之所以出现这样的结果，是字符串的存储方式不同。字符串str1和str11这样的创建方式是将数据存放在字符串常量池，在常量池中，同一个数只有一份。字符串常量池在JVM中是StringTable类，实际是一个固定大小的HashTable。str2和str22是将数据存放在堆上，每new一次就会在堆上开辟一块空间。</p><p>下面这幅图是String内部存储结构的简单示意图。</p><p><img src="https://cos.youngsay.cn/blog/202206031208205.png" alt="Sting内部存储结构"></p><p>总结：String类中两种对象实例化的区别：</p><ul><li>直接赋值：只会开辟一块堆内存空间，并且该字符串对象可以自动保存在对象池中以供下次使用。</li><li>构造方法：会开辟两块堆内存空间，不会自动保存在对象池中，<strong>可以使用intern()方法手工入池</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str2=<span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>).intern();</span><br></pre></td></tr></table></figure><h3 id="Sting的不可变性">Sting的不可变性</h3><p>字符串Sting是不可变的，所以每次字符串“+”加号拼接时都会产生一个新的对象，并不是在原对象的基础上拼接。</p><p>JDK中，String类由final修饰，value字符数组也由final修饰。</p><ul><li>String类被final修饰，表明该类不能被继承。</li><li>value被修饰被final修饰，只是表明不能再引用其他数组，但是引用空间中的值仍能被修改。</li></ul><p>所以，final并不是String对象不可变的原因。</p><p>如何理解 String 类型值的不可变？</p><p><a href="https://www.zhihu.com/question/20618891/answer/114125846">https://www.zhihu.com/question/20618891/answer/114125846</a></p><p>String对象不可变，使用加号进行字符串拼接效率是很低的，每次都会创建一个新对象，中间还会有很多临时变量。可以使用StringBuffer和StingBuilder来进行字符串的修改。</p><h3 id="StringBuffer和StringBuilder"><code>StringBuffer</code>和<code>StringBuilder</code></h3><p>String、StringBuffer、StringBuilder的区别:</p><ul><li>String的内容不可修改，StringBuffer与StringBuilder的内容可以修改.</li><li>StringBuffer与StringBuilder大部分功能是相似的。StringBuffer采用同步处理，属于线程安全操作；而StringBuilder未采用同步处理，属于线程不安全操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line">String str=<span class="string">&quot;panghu&quot;</span>;</span><br><span class="line">String str1 = str + <span class="string">&quot;tx&quot;</span>;</span><br><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;panghu&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;tx&quot;</span>);</span><br><span class="line"><span class="comment">//转化</span></span><br><span class="line"><span class="comment">//String----&gt;StringBuffer</span></span><br><span class="line">StringBuffer sb1=<span class="keyword">new</span> StringBuffer();</span><br><span class="line">System.out.println(sb1.append(str));</span><br><span class="line"><span class="comment">//StringBuffer---&gt;String</span></span><br><span class="line">String ss= sb.toString();</span><br><span class="line">System.out.println(ss);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;创建一个Sting&quot;&gt;创建一个Sting&lt;/h3&gt;
&lt;p&gt;String有三种构造方法，分别为直接赋值、new String方法构造和字符串数组构造。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="JavaSE" scheme="https://youngsay.cn/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>【JavaSE】抽象类和接口</title>
    <link href="https://youngsay.cn/2022/05/24/Java-abstractClass-interface/"/>
    <id>https://youngsay.cn/2022/05/24/Java-abstractClass-interface/</id>
    <published>2022-05-24T09:40:41.000Z</published>
    <updated>2022-06-08T13:43:25.643Z</updated>
    
    <content type="html"><![CDATA[<h3 id="抽象类">抽象类</h3><h4 id="什么是抽象类">什么是抽象类</h4><p>被abstract修饰的类就是抽象类。抽象类是类的进一步抽象，抽象类中的方法可以不做具体的实现（抽象方法，由abstract修饰）。抽象类中也可以有普通方法。</p><p>抽象方法不能由static和final修饰，因为抽象方法要被子类重写。</p><p>抽象类中不一定要有抽象方法，但是有抽象方法的类一定是抽象类。</p><p>抽象类不能实例化，但可以引用其子类对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="comment">//抽象类中也可以有构造方法，也可以有普通方法、属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象方法，不做具体实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;正在吃狗粮&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//抽象类不能实例化，但可以引用其子类对象。</span></span><br><span class="line">        Animal animal = <span class="keyword">new</span> Dog(<span class="string">&quot;旺旺&quot;</span>);</span><br><span class="line">        <span class="comment">//子类重写eat方法</span></span><br><span class="line">        animal.eat();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：旺旺正在吃狗粮</p><h4 id="为什么需要抽象类">为什么需要抽象类</h4><p>抽象类中的方法可以不做具体实现，为了子类能够继承该抽象类。使用抽象类能够多一层编译器校验，增加了安全性。就像常量用final修饰，不小心修改时编译器会报错提醒。</p><p>像上面的代码main方法中new Dog改成new Animal，编译器就会报错：‘Animal’ is abstract; cannot be instantiated。</p><h3 id="接口">接口</h3><h4 id="什么是接口">什么是接口</h4><p>接口是多个类的公共规范，是一种引用数据类型。接口可以理解为一种功能、特性，类实现某个接口，便可以具备某种功能。</p><p>接口中的方法默认是由public abstract修饰，接口中的属性默认是public final static。建议接口中的方法和属性不加任何修饰符号, 保持代码的简洁性.</p><p>接口不能实例化。</p><p>接口中不能有静态代码块和构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Running</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>; <span class="comment">//方法不加修饰符，默认为public abstract void run()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flying</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="comment">//抽象类中也可以有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象方法，不做具体实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Running</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;正在吃狗粮&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实现接口中的run方法，必须为public，因为接口中的run方法是public，重写时要分配更高的访问权限</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;正在扑向他的主人&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Flying</span></span>&#123;</span><br><span class="line">    <span class="comment">//继承父类，需要重写父类的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写父类的抽象方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;正在觅食&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现接口，必须实现接口的抽象方法，否则类需设置为抽象类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;正在天空中自由地翱翔&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog(<span class="string">&quot;旺旺&quot;</span>);</span><br><span class="line">        dog.eat();</span><br><span class="line">        dog.run();</span><br><span class="line">        Bird bird  = <span class="keyword">new</span> Bird(<span class="string">&quot;飞儿&quot;</span>);</span><br><span class="line">        bird.eat();</span><br><span class="line">        bird.fly();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p>旺旺正在吃狗粮<br>旺旺正在扑向他的主人<br>飞儿正在觅食<br>飞儿正在天空中自由地翱翔</p><h4 id="为什么需要接口">为什么需要接口</h4><p>Java不允许多重继承，通过接口可以提供多重继承的大部分好处，同时还能避免多重继承的复杂性和低效性。</p><h4 id="接口的使用实例">接口的使用实例</h4><h5 id="Comparable接口">Comparable接口</h5><p>对数组元素按年龄排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写compareTo方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        if(this.age&gt;o.age)&#123;</span></span><br><span class="line"><span class="comment">//            return 1;</span></span><br><span class="line"><span class="comment">//        &#125;else if(this.age&lt;o.age)&#123;</span></span><br><span class="line"><span class="comment">//            return -1;</span></span><br><span class="line"><span class="comment">//        &#125;else &#123;</span></span><br><span class="line"><span class="comment">//            return 0;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age-o.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Compare</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student[] students = <span class="keyword">new</span> Student[]&#123;</span><br><span class="line">                <span class="keyword">new</span> Student(<span class="string">&quot;panghu&quot;</span>,<span class="number">20</span>),</span><br><span class="line">                <span class="keyword">new</span> Student(<span class="string">&quot;xiaofu&quot;</span>,<span class="number">18</span>),</span><br><span class="line">                <span class="keyword">new</span> Student(<span class="string">&quot;daxiong&quot;</span>,<span class="number">19</span>),</span><br><span class="line">                <span class="keyword">new</span> Student(<span class="string">&quot;jingxiang&quot;</span>,<span class="number">16</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(students);</span><br><span class="line">        System.out.println(Arrays.toString(students));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p>[Student{name=‘jingxiang’, age=16}, Student{name=‘xiaofu’, age=18}, Student{name=‘daxiong’, age=19}, Student{name=‘panghu’, age=20}]</p><p>上面代码有一个问题，只能按年龄排序，如果想按姓名排序就要修改compareTo方法，修改后又只能按姓名排序。有没有一种办法，可以实现按不同的属性进行排序。利用比较器可以实现该要求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student1</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Student1</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student1 o1, Student1 o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.age-o2.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Student1</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student1 o1, Student1 o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.name.compareTo(o2.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Compare1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student1[] students = <span class="keyword">new</span> Student1[]&#123;</span><br><span class="line">                <span class="keyword">new</span> Student1(<span class="string">&quot;panghu&quot;</span>,<span class="number">20</span>),</span><br><span class="line">                <span class="keyword">new</span> Student1(<span class="string">&quot;xiaofu&quot;</span>,<span class="number">18</span>),</span><br><span class="line">                <span class="keyword">new</span> Student1(<span class="string">&quot;daxiong&quot;</span>,<span class="number">19</span>),</span><br><span class="line">                <span class="keyword">new</span> Student1(<span class="string">&quot;jingxiang&quot;</span>,<span class="number">16</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        AgeComparator ageComparator = <span class="keyword">new</span> AgeComparator();</span><br><span class="line">        NameComparator nameComparator = <span class="keyword">new</span> NameComparator();</span><br><span class="line">        <span class="comment">//按年龄排序</span></span><br><span class="line">        Arrays.sort(students,ageComparator);</span><br><span class="line">        System.out.println(<span class="string">&quot;按年龄&quot;</span>+Arrays.toString(students));</span><br><span class="line">        <span class="comment">//按姓名排序</span></span><br><span class="line">        Arrays.sort(students,nameComparator);</span><br><span class="line">        System.out.println(<span class="string">&quot;按姓名&quot;</span>+Arrays.toString(students));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p>按年龄[Student{name=‘jingxiang’, age=16}, Student{name=‘xiaofu’, age=18}, Student{name=‘daxiong’, age=19}, Student{name=‘panghu’, age=20}]<br>按姓名[Student{name=‘daxiong’, age=19}, Student{name=‘jingxiang’, age=16}, Student{name=‘panghu’, age=20}, Student{name=‘xiaofu’, age=18}]</p><h5 id="Clonable接口">Clonable接口</h5><p>实现Clonable接口需要重写Object类的clone()方法，在方法中使用super关键字调用Object类的clone()方法，然后调用该方法即可实现克隆。</p><ul><li>浅拷贝：仅仅拷贝当前对象本身，不拷贝引用类型。<br><img src="https://cos.youngsay.cn/blog/202206030851091.png" alt="浅拷贝"></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String phone;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    Phone p = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, p.phone=&quot;</span> + p.phone +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.age=<span class="number">20</span>;</span><br><span class="line">        person.p.phone=<span class="string">&quot;xiaomi&quot;</span>;</span><br><span class="line">        Person person2 = (Person)person.clone();</span><br><span class="line">        person2.age=<span class="number">10</span>;</span><br><span class="line">        person2.p.phone=<span class="string">&quot;iphone&quot;</span>;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        System.out.println(person2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line"><span class="comment">//Person&#123;age=20, p.phone=iphone&#125;</span></span><br><span class="line"><span class="comment">//Person&#123;age=10, p.phone=iphone&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>深拷贝：不仅拷贝当前对象，还拷贝其引用类型。</p><p><img src="https://cos.youngsay.cn/blog/202206030852161.png" alt="深拷贝"></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    Phone p = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Person tmp = (Person) <span class="keyword">super</span>.clone();</span><br><span class="line">        tmp.p= (Phone) <span class="keyword">this</span>.p.clone();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, p.phone=&quot;</span> + p.phone +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.age=<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        person.p.phone=<span class="string">&quot;xiaomi&quot;</span>;</span><br><span class="line">        Person person2 = (Person)person.clone();</span><br><span class="line">        person2.age=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        person2.p.phone=<span class="string">&quot;iphone&quot;</span>;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        System.out.println(person2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line"><span class="comment">//Person&#123;age=20, p.phone=xiaomi&#125;</span></span><br><span class="line"><span class="comment">//Person&#123;age=10, p.phone=iphone&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;抽象类&quot;&gt;抽象类&lt;/h3&gt;
&lt;h4 id=&quot;什么是抽象类&quot;&gt;什么是抽象类&lt;/h4&gt;
&lt;p&gt;被abstract修饰的类就是抽象类。抽象类是类的进一步抽象，抽象类中的方法可以不做具体的实现（抽象方法，由abstract修饰）。抽象类中也可以有普通方法。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="JavaSE" scheme="https://youngsay.cn/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>动态内存分配基本使用及常见问题</title>
    <link href="https://youngsay.cn/2022/04/09/C-malloc/"/>
    <id>https://youngsay.cn/2022/04/09/C-malloc/</id>
    <published>2022-04-09T13:23:41.000Z</published>
    <updated>2022-04-09T13:28:25.964Z</updated>
    
    <content type="html"><![CDATA[<p>为什么需要动态内存管理？创建一个数组，我们要为数组指定大小，<code>int arr[10];</code>，这属于静态创建一个数组，数组arr存放在栈上。这样的创建方式有一些局限性，小了呢不够用，大了呢又浪费空间，因此要引入动态内存管理。</p><p>动态创建一个数组，不再受元素个数的限制，当元素个数与容量相等时，可以很方便地扩容。</p><p>如何动态内存管理，我们来介绍几个函数。</p><p><strong><code>malloc</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void* malloc (size_t size);</span><br></pre></td></tr></table></figure><p>参数size为要为空间开辟的字节数，开辟成功后返回值为该空间的首地址，失败则返回<code>NULL</code>.<strong>当size为0时，要看编译器如何处理，具体返回什么不确定</strong>。</p><p>动态开辟内存后，不需要再使用这块空间时，要使用<code>free</code>函数释放内存。，否则会内存泄漏。free释放后这块内存可以再次被分配，但被释放的空间的值没有被改变，它仍然指向相同（无效）的位置。</p><p><code>free</code>专门用来释放动态分配的空间，如果空间为空，不执行任何操作。切记不可以用free来释放静态分配的内存空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>* p =(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">40</span>); <span class="comment">//动态开辟10字节的空间</span></span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123; <span class="comment">//判断是否开辟成功</span></span><br><span class="line">perror(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">*(p + i) = i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p + i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p); <span class="comment">//释放p空间</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>calloc</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void* calloc (size_t num, size_t size);</span><br></pre></td></tr></table></figure><p>与<code>malloc</code>相似，但是会在开辟后为空间初始化为0.参数num为要分配的元素数，size为每个元素的大小，总的内存空间为num*size个字节。</p><p>与malloc用法一致，不在举例。</p><p><strong><code>realloc</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void* realloc (void* ptr, size_t size);</span><br></pre></td></tr></table></figure><p>该函数可以为动态空间扩容，参数ptr为要扩容的空间，size为扩容后的内存大小。</p><p>扩容成功返回该空间的首地址，失败返回空，所以为空间扩容时先创建一块临时变量指向该空间，为临时变量扩容，扩容成功再让要扩容的空间等于临时变量，以防扩容失败内容丢失。</p><p>扩容会遇到两种情况，1种是该块空间后没有额外的空间来扩容，这时会分配一块新空间，将旧空间的内容移到新空间，返回值自然也是新空间的首地址，2是该块空间空间充足，这就可以在该空间后连续扩容，无需再寻找新的空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">40</span>); <span class="comment">//动态开辟10字节的空间</span></span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123; <span class="comment">//判断是否开辟成功</span></span><br><span class="line">perror(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">*(p + i) = i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p + i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩容</span></span><br><span class="line"><span class="keyword">int</span>* tmp=(<span class="keyword">int</span>*)<span class="built_in">realloc</span>(p, <span class="number">80</span>);</span><br><span class="line"><span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123; <span class="comment">//判断是否扩容成功</span></span><br><span class="line">p = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">*(p + i) = i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p + i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为0~19，扩容成功。</p><p><strong>问题</strong></p><p>了解了动态内存分配函数的一些基础使用后，我们来看一些常见的问题。</p><p>代码1:这段代码有什么问题？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory</span><span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">GetMemory(str);</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>p是一个局部变量，是实参的一份临时拷贝，出了GetMemory函数会自动销毁。我们为p开辟了100个字节的空间，出了函数后p销毁，找不到这块空间的首地址，却没对该空间进行内存释放，会造成内存泄漏。</p><p>此外str仍是空指针，将“hello world”拷贝到一块空指针，会造成非法访问，程序崩溃。</p><p>我们可以试着修改，将传值调用改成传址调用，这样p和str指向了同一块空间，最后别忘了free释放内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory</span><span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">GetMemory(&amp;str); <span class="comment">//传地址</span></span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(str);</span><br><span class="line"><span class="built_in">free</span>(str); <span class="comment">//别忘了释放哦~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">GetMemory</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> p[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">str = GetMemory();</span><br><span class="line"><span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>p是一个局部变量，是实参的一份临时拷贝，<code>return p</code>返回的是局部变量p的首地址，str收到了这个地址。不巧的是出了GetMemory函数p这块地址就还给了操作系统，所以str找不到这块地址，造成了野指针。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;为什么需要动态内存管理？创建一个数组，我们要为数组指定大小，&lt;code&gt;int arr[10];&lt;/code&gt;，这属于静态创建一个数组，数组arr存放在栈上。这样的创建方式有一些局限性，小了呢不够用，大了呢又浪费空间，因此要引入动态内存管理。&lt;/p&gt;
&lt;p&gt;动态创建一个数组</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="c" scheme="https://youngsay.cn/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>C语言的结构体及内存对齐</title>
    <link href="https://youngsay.cn/2022/03/31/C-struct/"/>
    <id>https://youngsay.cn/2022/03/31/C-struct/</id>
    <published>2022-03-31T11:00:41.000Z</published>
    <updated>2022-04-02T01:47:15.144Z</updated>
    
    <content type="html"><![CDATA[<h4 id="结构体基础">结构体基础</h4><p>结构体就是一些成员的集合，结构体的每一个成员可以是整型、数组、指针、结构体等不同的类型。</p><p>下面是一个简单的结构体结构，包含了类型声明<code>struct Stu</code>、成员、结构体变量<code>s1</code>的声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> &#123;</span>  <span class="comment">//类型</span></span><br><span class="line"><span class="comment">//成员</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">char</span> sex[<span class="number">10</span>];</span><br><span class="line">&#125;s1; <span class="comment">//结构体变量</span></span><br></pre></td></tr></table></figure><p>我们可以像上面那样声明一个结构体变量，也可以像下面这样单独声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">s2</span>;</span></span><br></pre></td></tr></table></figure><p><code>struct</code>是结构体关键字，<code>Stu</code>是结构体标志，两者构成了结构体类型。上面的语句表示为<code>struct Stu</code>类型的结构体声明了一个变量<code>s1</code>。下面是对s1的赋值操作，可以在声明结构体变量的时候直接赋值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">s1</span> =</span> &#123; <span class="string">&quot;panghutx&quot;</span>,<span class="number">20</span>,<span class="string">&quot;male&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p>在声明结构体时，我们可以对结构体不完全声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">double</span> c; </span><br><span class="line">&#125; a;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">double</span> c; </span><br><span class="line">&#125; *P;</span><br></pre></td></tr></table></figure><p>以上就不完全声明了两个结构体，我们称之为匿名结构体类型。结构体变量a和*p具有相同的成员，但它们是两个完全不同的类型。当我们尝试如下代码时，会出现警告。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*p = &amp;a;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/b7bee360471b4eafa7f55e39e249a0f2.png#pic_center" alt="警告信息"></p><p>说到结构体，我们难免提到一个关键字<code>typedef</code>,用于定义新的类型（或类型重命名）。我们在学习链表时可能会看到这样的结构，下面这段代码是对<code>struct Node</code>重命名为<code>Node</code>.而且还在结构体中引用了自己。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">Node* next;</span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure><p>切记在结构体自引用时不要使用匿名结构体，否则就是在定义新类型的时候引用了新类型，这是错误的。</p><p>再看下面的写法，定义了两个新类型，<code>Node</code>和<code>*pNode</code>，Node我们已经知道是对<code>struct Node</code>进行重命名，而<code>*pNode</code>是对<code>struct Node*</code>的重命名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">Node* next;</span><br><span class="line">&#125;Node,*pNode;</span><br></pre></td></tr></table></figure><h4 id="结构体内存对齐">结构体内存对齐</h4><p>结构体的大小不是单纯的各元素相加，因为主流计算机使用的是32bit字长的CPU，那么取4个字节数要比1个高效，所以结构体存在内存对齐。每个编译器都有自己的对齐系数，程序员也可以通过预编译命令来改变默认对齐数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(n) <span class="comment">//n为修改的对齐系数</span></span></span><br></pre></td></tr></table></figure><p>对齐规则：</p><p>①首个成员放在0ffset（偏移量）为0的位置，其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。</p><p><code>对齐数</code> = 编译器默认的一个对齐数 与 该成员大小的较小值。</p><p>②结构体总大小为各元素最大对齐数的整数倍。</p><p>举个例子，计算下面结构体的大小是多少。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> c1;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> c2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>假设编译环境默认4字节对齐。</p><p>c1是结构体首个元素，直接放到偏移量为0的位置，占1个字节；i自身大小为4字节，默认对齐4字节，因此对齐数就是四字节，将其放到对齐数整数倍的位置，也就是4偏移量的位置。c2自身大小1字节，默认对齐数4，因此对齐数是1，将其放到对齐数整数倍的位置，也就是int的后面。</p><p>0~8偏移量，那么该结构体为9个字节，对吗？别忘了规则②，结构体总大小是各元素最大对齐数的整数倍。结构体内最大对齐数的元素是int，对齐数是4，9不是4的整数倍，再开辟3个字节。</p><p>综上该结构体大小为12字节。</p><p><img src="https://img-blog.csdnimg.cn/21c2a08f1fb84c2f9084b2342fd99e9f.png#pic_center" alt="结构体内存对齐"></p><h4 id="结构体位段">结构体位段</h4><p>c语言允许在一个结构体中以位为单位来指定成员长度，利用位段能够节约空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> _a:<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> _b:<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> _c:<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> _d:<span class="number">30</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>A就是1个位段，它的大小为8个字节，想知道为什么是8个字节，要知道它的内存分配。</p><ul><li>位段的成员可以是 <code>int</code> <code>unsigned int</code> <code>signed int </code>或者是<code> char</code> （属于整形家族）类型</li><li>位段的空间上是按照需要以4个字节（ int ）或者1个字节（ char ）的方式来开辟的。</li><li>位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段</li></ul><p>调试下面代码，我们可以看一下空间是如何开辟的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> a:<span class="number">3</span>;</span><br><span class="line"><span class="keyword">char</span> b:<span class="number">4</span>;</span><br><span class="line"><span class="keyword">char</span> c:<span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> d:<span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">s.a = <span class="number">10</span>;</span><br><span class="line">s.b = <span class="number">12</span>;</span><br><span class="line">s.c = <span class="number">3</span>;</span><br><span class="line">s.d = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/63a14cb112be407c8b35ecec11f5fc5d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6I-c6bif5bCP6IOWcA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="位段内存分配"></p><p>我在vs2019环境下调试，和vs2013结果一样。先开辟一字节，从低位开始存数据，存不下时舍弃剩余位，再开辟一字节空间。</p><p>以上存储方式只能代表vs环境下，其他环境不确定。要知道，位段的内存分配与内存对齐的实现方式依赖于具体的机器和系统，在不同的平台可能有不同的结果，这导致了位段在本质上是不可移植的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;结构体基础&quot;&gt;结构体基础&lt;/h4&gt;
&lt;p&gt;结构体就是一些成员的集合，结构体的每一个成员可以是整型、数组、指针、结构体等不同的类型。&lt;/p&gt;
&lt;p&gt;下面是一个简单的结构体结构，包含了类型声明&lt;code&gt;struct Stu&lt;/code&gt;、成员、结构体变量&lt;code&gt;</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="c" scheme="https://youngsay.cn/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>博客一周年啦</title>
    <link href="https://youngsay.cn/2022/03/29/anniversary1/"/>
    <id>https://youngsay.cn/2022/03/29/anniversary1/</id>
    <published>2022-03-29T15:31:01.000Z</published>
    <updated>2022-07-27T00:45:40.835Z</updated>
    
    <content type="html"><![CDATA[<p>今天是3月29日，博客第一篇博文是在去年3月29日，不知不觉博客已经一年了。</p><p>一年前的今天，是大一下返校的前一天，今天，是大二下开学的第五周，一年后的今天，是大三下，不知道是在准备考研还是忙着就业。</p><p>一年后的事，一年后再说，活在当下，珍惜现在。突如其来的疫情已经持续三年了，都忘了没有疫情的生活是啥样了，三年多少人因为疫情失去了生命。上周让人悲痛的客机坠毁事件，航班人员全部遇难，向遇难者默哀。真是不知道明天和意外哪个会先来，生命无常，活着就好。</p><p>今天早上腾讯云连发了多条消息，原来是学生机和域名都快过期了。学生机是1核2G，每年108，我也不打算续费了。昨天看了橙梓的服务器迁移计划，我又心动了，今天买了五年2核2G4M的服务器，330元，我用处不大，只是觉得挺便宜的，下次续费就是2027年了，这下不用担心到期了。</p><p>下午忙活半天把hexo部署到了服务器，这下速度应该快了些，博客至少还能再活五年。五年后，我要发篇博客:博客五周年啦!</p><p>五年后的事，五年后再说吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天是3月29日，博客第一篇博文是在去年3月29日，不知不觉博客已经一年了。&lt;/p&gt;
&lt;p&gt;一年前的今天，是大一下返校的前一天，今天，是大二下开学的第五周，一年后的今天，是大三下，不知道是在准备考研还是忙着就业。&lt;/p&gt;
&lt;p&gt;一年后的事，一年后再说，活在当下，珍惜现在。突</summary>
      
    
    
    
    <category term="日常" scheme="https://youngsay.cn/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>常用的字符串处理函数</title>
    <link href="https://youngsay.cn/2022/03/28/C-string/"/>
    <id>https://youngsay.cn/2022/03/28/C-string/</id>
    <published>2022-03-28T08:31:01.000Z</published>
    <updated>2022-03-28T08:42:48.050Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串处理类">字符串处理类</h2><h3 id="strlen"><code>strlen</code></h3><h4 id="简单介绍">简单介绍</h4><p><code>size_t strlen ( const char * str );</code></p><p>Geting string length.</p><p>参数：str，返回值：字符串长度</p><p>字符串以<code>\0</code>作为结束标志，返回<code>\0</code>之前的字符个数。返回值是<code>size_t</code>（无符号）。</p><h4 id="模拟实现">模拟实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1：计时器</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">My_strlen1</span><span class="params">(<span class="keyword">char</span>* ps)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (*ps) &#123;</span><br><span class="line">count++;</span><br><span class="line">ps++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法2：指针相减</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">My_strlen2</span><span class="params">(<span class="keyword">char</span>* ps)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>* start = ps;</span><br><span class="line"><span class="keyword">while</span> (*ps) &#123;</span><br><span class="line">ps++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ps - start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法3：递归</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">My_strlen3</span><span class="params">(<span class="keyword">char</span>* ps)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (*ps == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>+My_strlen3(ps+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="strcpy"><code>strcpy</code></h3><h4 id="简单介绍-2">简单介绍</h4><p><code>char * strcpy ( char * destination, const char * source );</code></p><p>Copies the C string pointed by <em>source</em> into the array pointed by <em>destination</em>, including the terminating null character (and stopping at that point).</p><p>以<code>\0</code>结束，且将<code>\0</code>拷贝到目标空间</p><h4 id="模拟实现-2">模拟实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">My_strcpy</span><span class="params">(<span class="keyword">char</span>* des, <span class="keyword">char</span>* src)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>* rst = des;</span><br><span class="line"><span class="keyword">while</span> (*src) &#123;</span><br><span class="line">*des = *src;</span><br><span class="line">des++;</span><br><span class="line">src++;</span><br><span class="line">&#125;</span><br><span class="line">*des = *src;</span><br><span class="line"><span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//改进</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">My_strcpy1</span><span class="params">(<span class="keyword">char</span>* des, <span class="keyword">char</span>* src)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>* rst = des;</span><br><span class="line"><span class="keyword">while</span> (*des++ = *src++) &#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="strcat"><code>strcat</code></h3><h4 id="简单介绍-3">简单介绍</h4><p><code>char * strcat ( char * destination, const char * source );</code></p><p>Concatenate strings.</p><h4 id="模拟实现-3">模拟实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">My_strcat</span><span class="params">(<span class="keyword">char</span>* des, <span class="keyword">char</span>* src)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>* ret = des;</span><br><span class="line"><span class="comment">//找到des的&#x27;\0&#x27;</span></span><br><span class="line"><span class="keyword">while</span> (*des) &#123;</span><br><span class="line">des++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//字符串拷贝</span></span><br><span class="line"><span class="keyword">while</span> (*des++ = *src++) &#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="strcmp-2"><code>strcmp</code></h3><h4 id="简单介绍-4">简单介绍</h4><p><code>int strcmp ( const char * str1, const char * str2 );</code></p><p>Compare two strings.</p><h4 id="模拟实现-4">模拟实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">My_strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str1, <span class="keyword">const</span> <span class="keyword">char</span>* str2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (*str1 == *str2) &#123;</span><br><span class="line"><span class="keyword">if</span> (*str1 == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">str1++;</span><br><span class="line">str2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*str1 &gt; *str2) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="strstr"><code>strstr</code></h3><h4 id="简单介绍-5">简单介绍</h4><p><code>const char * strstr ( const char * str1, const char * str2 );</code></p><h4 id="模拟实现-5">模拟实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">My_strstr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str1, <span class="keyword">const</span> <span class="keyword">char</span>* str2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* ps1 = str1;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* ps2 = str2;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cur = str1;</span><br><span class="line"><span class="keyword">while</span> (*ps1) &#123;</span><br><span class="line">ps1 = cur;</span><br><span class="line"><span class="keyword">while</span> (*ps1 == *ps2 &amp;&amp; *ps1 &amp;&amp; *ps2) &#123;</span><br><span class="line">ps1++;</span><br><span class="line">ps2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*ps2 == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line">cur++;</span><br><span class="line">ps2 = str2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//*ps1和*ps2不相等时，要重新找ps2在ps1中的位置，ps2复原，ps1继续找下一位（也就是cur的下一位）。</span></span><br></pre></td></tr></table></figure><h2 id="内存操作类">内存操作类</h2><h3 id="memcpy"><code>memcpy</code></h3><h4 id="简单介绍-6">简单介绍</h4><p><code>void * memcpy ( void * destination, const void * source, size_t num );</code></p><p>Copy block of memory.</p><h4 id="模拟实现-6">模拟实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">My_memcpy</span><span class="params">(<span class="keyword">void</span>* des, <span class="keyword">void</span>* src, <span class="keyword">size_t</span> count)</span> </span>&#123;</span><br><span class="line"><span class="keyword">void</span>* ret = des;</span><br><span class="line"><span class="keyword">while</span> (count--) &#123;</span><br><span class="line">*(<span class="keyword">char</span>*)des = *(<span class="keyword">char</span>*)src;</span><br><span class="line">des = (<span class="keyword">char</span>*)des + <span class="number">1</span>;</span><br><span class="line">src = (<span class="keyword">char</span>*)src + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="memmove"><code>memmove</code></h3><h4 id="简单介绍-7">简单介绍</h4><p><code>void * memmove ( void * destination, const void * source, size_t num );  </code></p><p>Move block of memory,allowing the <em>destination</em> and <em>source</em> to overlap.</p><h4 id="模拟实现-7">模拟实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">My_memmove</span><span class="params">(<span class="keyword">void</span>* des, <span class="keyword">void</span>* src, <span class="keyword">size_t</span> count)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (des &lt; src) &#123;</span><br><span class="line"><span class="comment">//从前向后拷贝</span></span><br><span class="line"><span class="keyword">while</span> (count--) &#123;</span><br><span class="line">*(<span class="keyword">char</span>*)des = *(<span class="keyword">char</span>*)src;</span><br><span class="line">des = (<span class="keyword">char</span>*)des + <span class="number">1</span>;</span><br><span class="line">src = (<span class="keyword">char</span>*)src + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//从后向前拷贝</span></span><br><span class="line">des = (<span class="keyword">char</span>*)des + count - <span class="number">1</span>;</span><br><span class="line">src = (<span class="keyword">char</span>*)src + count - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (count--) &#123;</span><br><span class="line">*(<span class="keyword">char</span>*)des = *(<span class="keyword">char</span>*)src;</span><br><span class="line">des = (<span class="keyword">char</span>*)des - <span class="number">1</span>;</span><br><span class="line">src = (<span class="keyword">char</span>*)src - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;字符串处理类&quot;&gt;字符串处理类&lt;/h2&gt;
&lt;h3 id=&quot;strlen&quot;&gt;&lt;code&gt;strlen&lt;/code&gt;&lt;/h3&gt;
&lt;h4 id=&quot;简单介绍&quot;&gt;简单介绍&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;size_t strlen ( const char * str );&lt;/c</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="c" scheme="https://youngsay.cn/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c语言操作符练习总结</title>
    <link href="https://youngsay.cn/2022/03/07/C-operator2/"/>
    <id>https://youngsay.cn/2022/03/07/C-operator2/</id>
    <published>2022-03-07T02:49:01.000Z</published>
    <updated>2022-03-14T11:57:46.135Z</updated>
    
    <content type="html"><![CDATA[<h3 id="sizeof-的坑🕳">sizeof()的坑🕳</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i--;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="keyword">sizeof</span>(i))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察上端代码，思考一下输出结果是什么？</p><p>首先定义了一个全局变量，全局变量没有赋值，默认值为0；然后i–；i变成了-1.你也许会说sizeof(-1),-1是int类型的，占4个字节，-1&lt;4,结果不就是<code>&lt;</code>吗！其实不然，结果是<code>&gt;</code>,-1大于4？数学是体育老师教的！</p><p>原因在于sizeof()的返回值是无符号整型，也就是unsigned int，两数比较时，编译器会将左侧的值也转换成无符号整数，-1在内存中存储的是全1，即11111111111111111111111111111111，无符号嘛，会认为这是一个很大的数，所以最后输出了<code>&gt;</code>.</p><p>所以当一个数与sizeof()直接比较时，就要小心咯，可能会有意想不到的结果。</p><h3 id="运算符优先级">运算符优先级</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a, b, c;</span><br><span class="line">a = <span class="number">5</span>;</span><br><span class="line">c = ++a;</span><br><span class="line">b = ++c, c++, ++a, a++;</span><br><span class="line">b += a++ + c;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d b = %d c = %d\n:&quot;</span>, a, b, c);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察上段代码，输出结果是什么?很烦这种代码，虽然没什么意义，但既然错了，还是记录下吧。主要考察操作符的优先级和结合性。主要说两点，一是逗号表达式的优先级最低，所以<code>b= ++c , c++ , ++a , a++;</code>先算b=++a，然后再算逗号后面的操作。二是<code>+=</code>操作符的优先级也很低，所以在<code>b += a++ + c</code>中先计算<code>a++ +c</code>,再将结果加上b后赋值给b。</p><p><img src="https://gitee.com/panghutx/tuchuang/raw/master/20220314195744.png" alt="image-20220306211323371"></p><h3 id="二进制中1的个数">二进制中1的个数</h3><p>求二进制中1的个数，有很多方法。</p><p><strong>方法一</strong>：利用按位与<code>&amp;</code>和移位<code>&gt;&gt;</code>运算符。一个数按位与&amp;1，可以求得这个数二进制的最低位。只求最低位哪行啊，我要的是所有位上1的个数，结合移位运算符，(n&gt;&gt;1)&amp;1,得到的就是第二位，(n&gt;&gt;2)&amp;1,得到的就是第三位，一直到31，得到一次加一次，就得到了二进制中所有的1.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((n &gt;&gt; i) &amp; <span class="number">1</span>) count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二</strong>：利用%和/运算符，比如1987，1987%10，得到了后一位7，1987/10%10，得到了8，1987/100%10，得到了9，1987%1000/10，得到了1。十进制/10%10，二进制自然就/2%2。值得注意的是数的类型要定义为<code>unsigned int</code>，否则该方法只适用于正整数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> tmp = n;</span><br><span class="line"><span class="keyword">while</span> (tmp) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tmp % <span class="number">2</span>) &#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">tmp = tmp / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法三</strong>：利用表达式<code>n=n&amp;(n-1)</code>,计算表达式执行的次数，n为0时结束循环。如下图所示：</p><p><img src="C:%5CUsers%5Cpanghu%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220307103014897.png" alt="image-20220307103014897"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n) &#123;</span><br><span class="line">n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两个数二进制不同位的个数">两个数二进制不同位的个数</h3><p>有了上道题的基础，这道题就迎刃而解了。</p><p>思路一：默认最低位是第0位，n&gt;&gt;i&amp;1可以求得第i位的二进制数，如果两数不等，计数器加一即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((a &gt;&gt; i &amp; <span class="number">1</span>) != (b &gt;&gt; i &amp; <span class="number">1</span>)) count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：利用异或<code>^</code>运算符，两数异或，相同位为0，不同位为1。对异或后的数求二进制中1的个数，便得到了二进制中不同位的个数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">scanf_s(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="comment">//1.两数异或</span></span><br><span class="line"><span class="keyword">int</span> c = a ^ b;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//2.求二进制中1d</span></span><br><span class="line"><span class="keyword">while</span> (c) &#123;</span><br><span class="line">c = c &amp; (c - <span class="number">1</span>);</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;sizeof-的坑🕳&quot;&gt;sizeof()的坑🕳&lt;/h3&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="c" scheme="https://youngsay.cn/tags/c/"/>
    
  </entry>
  
</feed>
