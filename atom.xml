<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>胖虎同学</title>
  
  <subtitle>积极有时，消极有时</subtitle>
  <link href="https://youngsay.cn/atom.xml" rel="self"/>
  
  <link href="https://youngsay.cn/"/>
  <updated>2024-01-01T03:07:25.816Z</updated>
  <id>https://youngsay.cn/</id>
  
  <author>
    <name>胖虎同学</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2023年终总结</title>
    <link href="https://youngsay.cn/2024/01/01/2023/"/>
    <id>https://youngsay.cn/2024/01/01/2023/</id>
    <published>2024-01-01T03:03:15.000Z</published>
    <updated>2024-01-01T03:07:25.816Z</updated>
    
    <content type="html"><![CDATA[<p>一年又过去了，这是博客的第三个年终总结。</p><p>回看了前两年的年终总结，都是那样普通平常，而且前两年赶上了疫情，要么延期开学，要么封校，要么提前放假。与博友们的丰富多彩的生活相比，我就像白活了一样。</p><p>今年与往年有些不同，有了新的身份——实习生，活跃地点也由家和学校转移到了公司、出租屋。</p><p>1-4月，开启人生第一份实习，新鲜又陌生，期待又恐惧。</p><p>5月，担心挂科重回学校，4门必修课，大半学期没听课，最后考的还不错。所以说要活在当下，不要透支烦恼，你所想的种种麻烦大都不会发生，即便发生也都会顺利解决。</p><p>8-10月，秋招。秋招并不顺利，我想这是心态的问题，心态差，做什么都无济于事了。每天只是麻木的做着测评、笔试、面试，事后没有复盘、反思。看似很努力，其实只将一件事重复了一次又一次。</p><p>9月，大四开学，学校组织去外地实训，度过快乐、难忘的两周。一起去海边、聚餐、熬夜看鬼片，这才是大学生活。</p><p>11月，秋招不顺利，二次实习。</p><p>2024年了，虚岁24岁了，我不敢想。</p><p>还记得小学英语课上一个小插曲，老师问大家里的梦想是什么，我说想做policeman，老师听成了postman（其实postman还挺符合我的，现在听到postman，脑子里只有那个调试接口的软件），到现在还印象深刻。当时为什么说policeman，我好像没有过当警察的梦想，可能有过却被我忘了，可能是刚好想起这个单词。</p><p>上高中之后，我的目标渐渐清晰，我想做一个程序员，当时对码农概念还比较单一，只是想做出属于自己的网站，也不懂什么前端、后端，网上找到一些便宜甚至免费的虚拟主机，再找到一些现成的源码，上传上去，就能访问了。当时搭过各种博客（wordpress、emlog、typecho…）、影视网站、论坛（Flarunm、Discuz），甚至还有刷钻的网站。捣鼓这些玩意，就浪费了一天又一天的时间，一无所获却倾尽所有。</p><p>再后来才接触到前端，看到自己写的东西能展示在页面上，乐在其中。上了大学，又接触到了后端。从只会写一些简单的页面，到前后端交互，能写一些逻辑，不知道当时自己有多快乐。</p><p>到了大三、大四，有了就业的压力，好像已经忘了最初的目标。不再沉浸在编程的快乐，而是苦于八股文、算法、找工作…想想初学编程的时候，只是单纯喜欢，没有想过什么钱多钱少，什么大厂小厂，一个小功能实现了，我都能乐一天了。现在呢，想要更好的工作，想要更高的工资，永远不知足。</p><p>与过去的自己相比，我已经成长了。从搬源码，到写一些简单的静态页面，到能够前后端交互，虽然这些并不难，但对比以前的自己，已经进步了。从想做一个码农，到成为了一个码农，我的目标已经实现了。<strong>如果我是当初的我，我一定会非常高兴。即使我是现在的我，也没理由不高兴，对吗？</strong></p><p>2024，保持热爱，找寻自我。不再羡慕他人的精彩，为自己的成长喝彩。人生，才刚刚开始。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一年又过去了，这是博客的第三个年终总结。&lt;/p&gt;
&lt;p&gt;回看了前两年的年终总结，都是那样普通平常，而且前两年赶上了疫情，要么延期开学，要么封校，要么提前放假。与博友们的丰富多彩的生活相比，我就像白活了一样。&lt;/p&gt;
&lt;p&gt;今年与往年有些不同，有了新的身份——实习生，活跃地点</summary>
      
    
    
    
    <category term="日常" scheme="https://youngsay.cn/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="年终总结" scheme="https://youngsay.cn/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>练习时长1个月</title>
    <link href="https://youngsay.cn/2023/12/17/shixi-again/"/>
    <id>https://youngsay.cn/2023/12/17/shixi-again/</id>
    <published>2023-12-17T03:11:11.000Z</published>
    <updated>2023-12-19T13:58:52.952Z</updated>
    
    <content type="html"><![CDATA[<p>时间过得真快，上次发文说去实习了，转眼间实习一个多月了。</p><p>第一段实习是大三上学期学期末，疫情刚放开，进京不需要各种***了。趁着寒假，快乐地实习了一段时间。大三下学期开学后，实习就不那么快乐了。学校各种破事，还有四五门必修课和一堆水课，最后在学期末离职回学校了。现在想想其实应该再坚持一下，最坏不就是挂科嘛，工作都找不到，挂几科能怎样。</p><p>第一次找实习的过程还是挺顺利的，拿了两个offer，最后来了滴滴实习。当时在想，都说找工作难，这不也还行吗？现在看是运气好罢了。如果不是秋招，我还以为我前途一片光明呢。我的岗位是测开，但更多的是开发，接触到的测试很少。大多数公司测开还是以测试为主，所以秋招在面试时实习可能并没有带来多少加分。</p><p>秋招大寄，所以又来实习了。这次找实习也很顺利，为什么我的秋招不能这样顺利😭这次实习主要是测试，和第一段实习刚好互补了。希望能留下了或者春招能找到个满意的工作🙏。相比第一段实习，这次似乎从容了很多，一是心态上好了很多，因为除了实习，好像没有更好的选择了，不再care学校的一些破事了（最好别让我毕业，这样还能参加明年秋招🤬），二是对实习的环境也更熟悉，包括租房、出行之类的。第一次实习，对一切都很新鲜，周末经常和小伙伴们到处玩。现在小伙伴们都上岸了，只有我还在水里扑腾。周末没人一起玩，很多景点也都去过了，也就很少出去了，花更多时间好好学习吧，争取早日上岸。</p><p>现在想想，第一段实习还是有些遗憾的，有些事情本能做的更好一些。但没办法了，遗憾也是一种美，只能这样安慰自己了。希望这次实习不留遗憾。</p><img src="https://offer.youngsay.cn/blog/tigerBaby.jpg" style="height:350px" />]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;时间过得真快，上次发文说去实习了，转眼间实习一个多月了。&lt;/p&gt;
&lt;p&gt;第一段实习是大三上学期学期末，疫情刚放开，进京不需要各种***了。趁着寒假，快乐地实习了一段时间。大三下学期开学后，实习就不那么快乐了。学校各种破事，还有四五门必修课和一堆水课，最后在学期末离职回学校了</summary>
      
    
    
    
    <category term="日常" scheme="https://youngsay.cn/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>在路上</title>
    <link href="https://youngsay.cn/2023/11/05/ontheway/"/>
    <id>https://youngsay.cn/2023/11/05/ontheway/</id>
    <published>2023-11-05T02:11:01.000Z</published>
    <updated>2023-12-17T02:14:53.960Z</updated>
    
    <content type="html"><![CDATA[<p>时隔一个月，又回家了。在家睡觉就是舒服、踏实，在学校每天入睡困难，一两点睡觉是常事，回到家躺上床没十分钟就睡着了，真是家到病除。</p><p>这次回家呆几天，收拾收拾东西，下周又要去实习了。之前博客说过，我今年年初去实习了。实习期间认识了不少小伙伴，这些小伙伴都拿到了大厂offer，有些还不止一个。只有我，整个秋招只拿到一个小厂offer。我也知道，不要只问收获，不问耕耘。我也知道，不要和他人比较，做好自己。我也知道，我不知道。</p><p>秋招可以说是结束了，金九银十过去了，目前只拿到一个小厂offer。我有不错的实习经历，有时也自认为有不错的能力（在面试顺利时），对这样的结果还是不甘心。所以我决定再去实习一段时间，期望能有更好的结果。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=5264287&auto=1&height=66"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;时隔一个月，又回家了。在家睡觉就是舒服、踏实，在学校每天入睡困难，一两点睡觉是常事，回到家躺上床没十分钟就睡着了，真是家到病除。&lt;/p&gt;
&lt;p&gt;这次回家呆几天，收拾收拾东西，下周又要去实习了。之前博客说过，我今年年初去实习了。实习期间认识了不少小伙伴，这些小伙伴都拿到了大厂</summary>
      
    
    
    
    <category term="日常" scheme="https://youngsay.cn/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>国庆节</title>
    <link href="https://youngsay.cn/2023/10/03/national-day/"/>
    <id>https://youngsay.cn/2023/10/03/national-day/</id>
    <published>2023-10-03T05:25:01.000Z</published>
    <updated>2023-12-17T02:15:35.934Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=2018577736&auto=1&height=66"></iframe><p>回家过节啦，学校离家近，不到3个小时就到家了。又是一年一度的中秋国庆节，不知道从什么时候开始，中秋和国庆凑到一起过了。在什么情况下3+7等于8？答：在完美的调休制度下3+7=8。3+7=调休？8：10。回家了，好好放松下，虽说在学校也没少放松。</p><p>姐姐也回家了，带着不到两岁的小神兽。神兽已经能走路、说话了，整天“妈妈”，“抱抱”，&amp;*%…，十分可爱。想起了我小时候，在我不到两岁的时候，我……我还没有记事😅。但我想应该也特别可爱，想哭就哭，想笑就笑，哭了有人哄，饿了有人喂。谁都有童年，谁都有过童年。就像歌词写道：“一代人终将老去 但总有人正年轻”。我今年22岁了，童年离我越来越远了。</p><p>上小学时，每个学期末都盼着拿到奖状，这样在拜年时特别有面，是亲戚口中的别人家的孩子。所以好好学习就是天大的事，期末考的好就开心，考的不好就难过。</p><p>上初中时，学习不如之前勤奋了，沉迷上了游戏，几乎所有腾讯的游戏都玩了个遍，成绩也不如之前好了。虽说成绩变差了，但也是中等偏上，因为小学成绩太好了，父母的期待变高了。所以得出一个完美的结论：小时候成绩不要太好😅！成绩忽高忽低，父母的批评、管束变多了，而且有了逆反心理，烦恼越来越多。有一次期末考的不好，印象特别深刻，大年三十，我还被教育去学习，不要玩手机，我委屈地哭了。</p><p>上高中时，烦恼也特别多，尤其是高三。高三年级主任模仿衡水高中作息，早上5点多就要起床跑圈、上早自习，晚上学到10点45才下晚自习。中间不允许回宿舍，只有晚上可以回去睡觉。就像一些企业要学习狼性文化，只模仿狼性文化的管理，薪资福利等却只字不提。真是取其糟粕，去其精华。还有好多烦恼，不想回忆了😒。</p><p>……</p><p>每个年龄段有每个年龄段的烦恼，且没有孰轻孰重，每个烦恼都很烦恼。现在我最大的烦恼就是找工作，希望毕业前能找到满意的工作。在我初中时，曾有过轻生的想法，现在想想可能不算什么，但当时对于一个十多岁的孩子就是天大的事。所以我特别讨厌某些盐吃多了的人，总是用自己的经历去否定他人。</p><p>活着就是要面临各种烦恼，烦恼多还是快乐多？我不知道。如果能自己选择是否来到这个世界，做何选择？我不知道。但我知道，我是最后一代。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=2018</summary>
      
    
    
    
    <category term="日常" scheme="https://youngsay.cn/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>暑假第一天</title>
    <link href="https://youngsay.cn/2023/06/30/relax-summer/"/>
    <id>https://youngsay.cn/2023/06/30/relax-summer/</id>
    <published>2023-06-30T14:00:15.000Z</published>
    <updated>2023-06-30T14:00:48.139Z</updated>
    
    <content type="html"><![CDATA[<p>今天是放假第一天，刷刷短视频、看看综艺，一天就过去了。</p><p>这可能是比较放松的一个暑假，也是为数不多的一个暑假。考研er暑假得准备考研，甚至很多同学都没有回家，自然是没有暑假了。也有一些认识的、不打算就业的人正在大厂实习，自然也是没有暑假了。而我，这个时候再找份实习有点晚了，也快该秋招了，就呆家里刷刷算法、学学技术，过个舒服点的暑假吧。</p><p>昨天和两个高中同学一起回来的。一个是药学专业，打算考研，暑假在家备考；一个护理专业，过几天就去医院实习了，一实习就是8个月。和他们相比，似乎我是最轻松的。可眼看就要秋招了，什么都没准备好；就业压力这么大，失业人数那么多；互联网不景气，没有发展了……一大堆的问题接踵而至，我有啥可轻松的，我应该焦虑才对。</p><p>焦虑有用吗？因为焦虑，我能在秋招找到一份好工作吗？因为焦虑，互联网寒冬就能过去，就业岗位就能增加吗？显然不能，焦虑过度只能过度的焦虑。身边的人越来越焦虑，身边的人弦时刻紧绷着，我不要和他们一样。这个暑假，我要放轻松。轻松不是无所事事，虚度光阴，而是不焦虑，不强求。每天进步一点，哪怕只有一点，就很好。</p><p>九月份应该就要秋招了，可能会神仙打架，结果不尽人意，但秋招不行还有春招，春招不行还有春招补录。可能大厂已经人满为患，但大厂进不去还有中厂，中厂进不去还有小厂。最差也不过是没找到工作，这没什么大不了的。拿我的两个高中同学举例。一个药学专业，准备考研。考上了读研三年也不轻松，没考上就业或再战也不轻松。一个护理专业，每天早班晚班两班倒，放假少、睡不好，也不轻松。</p><p>资源有限，又有哪一行轻松呢？资质平平，又有哪个人轻松呢？这个暑假，我要放轻松。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天是放假第一天，刷刷短视频、看看综艺，一天就过去了。&lt;/p&gt;
&lt;p&gt;这可能是比较放松的一个暑假，也是为数不多的一个暑假。考研er暑假得准备考研，甚至很多同学都没有回家，自然是没有暑假了。也有一些认识的、不打算就业的人正在大厂实习，自然也是没有暑假了。而我，这个时候再找份实</summary>
      
    
    
    
    <category term="日常" scheme="https://youngsay.cn/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>我的大三下学期</title>
    <link href="https://youngsay.cn/2023/06/19/junior-year/"/>
    <id>https://youngsay.cn/2023/06/19/junior-year/</id>
    <published>2023-06-19T08:51:15.000Z</published>
    <updated>2023-06-30T14:00:26.803Z</updated>
    
    <content type="html"><![CDATA[<p>又到毕业季，看着校园里学生们穿着毕业服到处拍着照片，各个学院举办着毕业典礼，随处都是离别的声音。时间很快，来年6月，就到我了。</p><p>2月27号，开学。这月底，大三下学期就结束了。这一学期，过得不太一样。</p><p>不一样的是，疫情走了，花开了，人多了。不再封校，不再做核酸，不再戴口罩……校园内外充满了朝气，图书馆不再隔位就坐，网课大学成为过去，商业街热闹了起来。劳动节和同学在学校附近玩了一天，很开心，三年了第一次去学校外面逛。好的大学，没有围墙。我们就这样被困了两年多。</p><p>不一样的是，这学期一半多时间都去实习了，体验了一把打工人的苦与乐。</p><p>通过实习，认识了一些同龄的实习生，每到周末可以一起出去玩。几个月内，去了天安门、故宫、八达岭长城等景点，度过了一个个难忘的周末。赶上了组里的团建，玩得也很开心。还恰逢公司周年庆，领了个周年文化衫，留作纪念……这些都很快乐，都是很难得的经历。</p><p>实习学业难平衡。一边要忙着实习的事，完成导师给的需求，一边要忙着学校的事，生怕考试挂科。每次学校有考试，都要早上五点起床，坐最早的高铁赶到学校，哪怕这样，还有一次晚点了。下班时间晚，没有个人生活。哪怕只是实习生，大部分时间也晚上9点走，感觉很少有天亮下班的时候。到家后也懒得学习，空虚地刷着手机，凌晨一两点渐渐入睡，一天就这样过去了……这些都是感到痛苦的事，也是离职的部分原因。</p><p>第一次离家这么久，1月多出来实习，过年回去了7天，然后直到6月才回去了一趟。在此之前，除了上学外，我几乎都是宅在家里。实习后才发现，以后能呆在家里的日子少之又少了。第一次租房，找房、搬家、交租退租，都是之前没经历过的。第一次上班，敲bug、摸鱼、与导师同事交往，由好奇到厌倦。最后，离职回学校了，体验为数不多的校园生活。</p><p>现在专业课都考完试了，本周再完成两个报告就没什么事了，真正的大学生活开始了。月底就放假回家了，一个学期又结束了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;又到毕业季，看着校园里学生们穿着毕业服到处拍着照片，各个学院举办着毕业典礼，随处都是离别的声音。时间很快，来年6月，就到我了。&lt;/p&gt;
&lt;p&gt;2月27号，开学。这月底，大三下学期就结束了。这一学期，过得不太一样。&lt;/p&gt;
&lt;p&gt;不一样的是，疫情走了，花开了，人多了。不再封校</summary>
      
    
    
    
    <category term="日常" scheme="https://youngsay.cn/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>浑浑噩噩，一个月又过去了……</title>
    <link href="https://youngsay.cn/2023/02/25/wake-up/"/>
    <id>https://youngsay.cn/2023/02/25/wake-up/</id>
    <published>2023-02-25T07:15:15.000Z</published>
    <updated>2023-07-29T08:37:40.260Z</updated>
    
    <content type="html"><![CDATA[<p>浑浑噩噩，一个月又过去了……算上放假，已经实习50多天了。</p><p>工作日时间过的很快，8点多起床，刷牙洗脸挤公交，接近10点到公司，晚上早的话7点多下班，晚的话9点多下班，到家后刷刷手机，十二点、一点多入睡。一天就这样过去了。</p><p>周六日时间过得很慢，一天无所事事，刷刷手机，听听音乐，一遍又一遍地打开聊天软件，总在盼望，总在失望。一天就这样过去了。</p><p>实习就像一个分水岭。在实习前我虽然会放纵，但总的来说是处于学习的状态，并且有动力来学习充实自己。在实习后，我就彻底放飞自我，停止了学习。我会一遍一遍又一遍地自我安慰说上班时间少，工作很累了没时间学习，但我知道这是借口罢了。我知道这样下去很危险，但又懒惰地不想做出改变，我知道这样下去很危险……</p><p>下周一就要开学了，因为没有考研的准备，我选择继续实习。就在我整天浑浑噩噩的同时，醒着的人正在为实现自己的目标而努力。还有几个月就要秋招了，现在还不是做梦的时候。醒醒吧，别再沉浸在实习的美梦中了，也许，这本就是场噩梦。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;浑浑噩噩，一个月又过去了……算上放假，已经实习50多天了。&lt;/p&gt;
&lt;p&gt;工作日时间过的很快，8点多起床，刷牙洗脸挤公交，接近10点到公司，晚上早的话7点多下班，晚的话9点多下班，到家后刷刷手机，十二点、一点多入睡。一天就这样过去了。&lt;/p&gt;
&lt;p&gt;周六日时间过得很慢，一天</summary>
      
    
    
    
    <category term="日常" scheme="https://youngsay.cn/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>2022年终总结</title>
    <link href="https://youngsay.cn/2023/01/21/2022/"/>
    <id>https://youngsay.cn/2023/01/21/2022/</id>
    <published>2023-01-21T07:15:15.000Z</published>
    <updated>2023-07-29T08:35:56.323Z</updated>
    
    <content type="html"><![CDATA[<p>时间过得真快啊，今天就是大年三十了，一年又这样过去了。</p><p>没什么可写的，但又想写点什么，毕竟好久没写记录自己的日常了，连”个站商店“也把我网站删除了。与其说是年终总结，不如说是流水账。</p><blockquote><p>《个站商店》给你发了单独的邮件，</p><p>hi 胖虎同学 ：</p><p>很抱歉，你的网站《胖虎同学》未能通过『个站商店』的审核，主要原因是内容非原创，多是技术类或者转载类，这类网站一般比较少人看。等你整改后，欢迎再来哦！</p><p>———— 祝生活愉快！ 邮件来自《个站商店》 2023-01-18 12:51:59</p></blockquote><p>今年也和往年一样，疫情，开学，放假……</p><p>2月28日，开学，开学没几天，疫情严重，在校上网课。5月25日，请假离校，提前过上暑假生活……</p><p>9月5号开始返校，已经是大三的老家伙了，因家里疫情被延期返校，13日回校。开学没几天，疫情严重，在校上网课。11月26日，请假离校，提前过上寒假生活……</p><p>除了开学放假外，今年有两件事可以说说。一件好事，一件坏事。</p><p>一件好事就是找到了实习。12月，我开始准备找实习的事，很幸运在12月30日拿到了实习offer。</p><p>1月5号，去公司报到，开始实习生活。1月21也就是今天，回家过年。这月只工作了11天，而这一周人都走的差不多了，基本上就是摸鱼，所以只工作了5天。</p><p>在这段时间里，感觉挺快乐，是我之前没有体会到的新生活。但也遇到些问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;时间过得真快啊，今天就是大年三十了，一年又这样过去了。&lt;/p&gt;
&lt;p&gt;没什么可写的，但又想写点什么，毕竟好久没写记录自己的日常了，连”个站商店“也把我网站删除了。与其说是年终总结，不如说是流水账。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;《个站商店》给你发了单独的邮件，&lt;/</summary>
      
    
    
    
    <category term="日常" scheme="https://youngsay.cn/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="年终总结" scheme="https://youngsay.cn/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库：事务</title>
    <link href="https://youngsay.cn/2022/11/29/MySQL-transaction/"/>
    <id>https://youngsay.cn/2022/11/29/MySQL-transaction/</id>
    <published>2022-11-29T05:04:41.000Z</published>
    <updated>2022-11-29T05:41:07.010Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事务的概念">事务的概念</h3><p><strong>事务</strong>是逻辑上的一组操作，能够将各SQL语句打包执行，<strong>要么全都执行，要么全都不执行</strong>。</p><p>想象我们在操作数据库时，数据库突然挂了，或者多个线程写入数据库时覆盖了彼此的更改……一系列操作都会导致数据库数据的不一致性，基于这些问题，数据库有了事务这一机制。</p><p>拿转账举例，A想要向B转账500元，该操作分为两步：</p><ul><li>A的账户减少500元</li><li>B的账户增加500元</li></ul><p>事务会将这两步打包在一起执行，要么全都执行，要么全都不执行。不会出现A的账户少了500，而B账户没有增加500的情况。</p><h3 id="如何使用事务">如何使用事务</h3><p>①开启事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br></pre></td></tr></table></figure><p>②执行多条SQL语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- A账户减少500</span></span><br><span class="line">update accout <span class="keyword">set</span> money<span class="operator">=</span>money<span class="number">-500</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="comment">-- B账户增加500</span></span><br><span class="line">update accout <span class="keyword">set</span> money<span class="operator">=</span>money<span class="operator">+</span><span class="number">500</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>;</span><br></pre></td></tr></table></figure><p>③回滚或提交：rollback/commit;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>说明：rollback即是全部失败，commit即是全部成功。</p><h3 id="事务的特性">事务的特性</h3><p>关系型数据库（例如：<code>MySQL</code>、<code>SQL Server</code>、<code>Oracle</code> 等）事务都有四大特性：</p><p>原子性</p><p><strong>原子性</strong>：事务为执行的最小单元，不可再划分，要么全都执行，要么全都不执行。</p><p><strong>一致性</strong>：事务执行前后的数据要保持一致，结果不能出现异常。拿转账举例，转账前后两个账户的总额是不变的。</p><p><strong>持久性</strong>：事务带来的影响是持久的，不会因为数据库故障而产生任何影响。</p><p><strong>隔离性</strong>：并发访问数据库时，各事务之间的数据库是独立的，一个用户的事务不会被其他事务所干扰。</p><p>只有保证事务的原子性、持久性和隔离性，才能保证事务的一致性，所以说原子性、持久性和隔离性是事务的手段，一致性是目的。</p><h3 id="并发事务带来的问题">并发事务带来的问题</h3><p><strong>脏读</strong>：一个事务正在访问数据库并对数据进行修改，而该修改并未提交到数据库，另一个进行此时访问数据库读取数据。而这里访问的数据只是一个中间的数据，不一定是最终的结果，这里读到的数据就是一个“脏数据”，基于“脏数据”做出的操作可能是错误的。</p><p><strong>不可重复读</strong>：在一个事务内多次读取同一数据。在多次读取数据之间，另一个事务访问并修改了该数据，那么再次读取该数据时，发现与之前读取到的数据不一样。在一个事务内两次读取到的数据不一样，称为不可重复读。</p><p><strong>幻读</strong>:一个事务(T1)读取了几行数据，此时另一个事务(T2)插入了一些数据。事务T1再次读取该数据发现多了一些原本不存在的数据，这就是幻读。幻读是不可重复读的特殊情况，不可重复读强调的是数据的更改，幻读强调的是数据的增加。</p><h3 id="事务隔离级别">事务隔离级别</h3><p>SQL标准定义了四个隔离级别，隔离级别越高，并行化就越低。</p><ul><li>read-uncommitted：读取未提交。最低的隔离级别。允许读取未提交的数据，可能导致脏读、不可重复读、幻读。</li><li>read-committed：读取已提交。不能读取未提交的数据，即事务在修改数据时另一个事务不能执行读操作。可以防止脏读，不能避免不可重复读、幻读。</li><li>repeatable-read：可重复读。事务在读取数据时，其他事务不能修改正在读取的数据。因此对同一数据的多次修改结果都是一致的，可以防止脏读、不可重复读，不能避免幻读。</li><li>serializable：串行化。最高的隔离级别。各事务串行执行，相互之间不存在干扰，可以防止脏读、不可重复读和幻读。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;事务的概念&quot;&gt;事务的概念&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;事务&lt;/strong&gt;是逻辑上的一组操作，能够将各SQL语句打包执行，&lt;strong&gt;要么全都执行，要么全都不执行&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;想象我们在操作数据库时，数据库突然挂了，或者多个线程写入</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="MySQL" scheme="https://youngsay.cn/tags/MySQL/"/>
    
    <category term="事务" scheme="https://youngsay.cn/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库：索引</title>
    <link href="https://youngsay.cn/2022/11/28/MySQL-index/"/>
    <id>https://youngsay.cn/2022/11/28/MySQL-index/</id>
    <published>2022-11-28T13:04:41.000Z</published>
    <updated>2022-11-28T13:18:47.781Z</updated>
    
    <content type="html"><![CDATA[<p>索引是一种用于快速查找和检索数据的数据结构，类似于图书的目录，通过索引可以更快地找到对应的数据。</p><h3 id="索引的优缺点">索引的优缺点</h3><p>优点：</p><ul><li>提高了查找的效率</li><li>通过创建唯一性索引，确保了每一行数据的唯一性。</li></ul><p>缺点：</p><ul><li>索引使用物理文件存储，带来了空间的消耗。</li><li>创建和维护索引需要耗费时间。当数据发生更改时，索引也会动态修改，降低SQL执行效率。</li></ul><h3 id="索引SQL">索引SQL</h3><h4 id="查看索引">查看索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> 索引名 <span class="keyword">from</span> 表名(列名);</span><br></pre></td></tr></table></figure><p><img src="https://cos.youngsay.cn/blog/202211282118307.png" alt="image-20221128161811672"></p><h4 id="创建索引">创建索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index 索引名 <span class="keyword">on</span> 表名(列名);</span><br></pre></td></tr></table></figure><p><img src="https://cos.youngsay.cn/blog/202211282118347.png" alt="image-20221128162120786"></p><h4 id="删除索引">删除索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> index 索引名 <span class="keyword">on</span> 表名</span><br></pre></td></tr></table></figure><p><img src="https://cos.youngsay.cn/blog/202211282118794.png" alt="image-20221128162440340"></p><h3 id="索引底层的数据结构">索引底层的数据结构</h3><p>索引是一种查找更快的数据结果。</p><p>数组和链表的查找都需要遍历，最先淘汰。</p><p>二叉搜索树最坏情况下会变成单支树，查找的时间复杂度变为O(N)，淘汰。</p><p>AVL树和红黑树使得左右子树高度相对平衡，但数据量太大时，树的高度过高，比较次数过多，即磁盘IO过多，淘汰。</p><p>哈希表查找的时间复杂度是O(1)，是不是可以作为索引的数据结构了呢？NO！哈希表不支持顺序和范围查找，而SQL要经常进行排序和</p><p>范围查询，淘汰。</p><p><strong>目前大多数数据库采用B树或B+树作为索引结构</strong>，在MySQL中，MyISAM 引擎和 InnoDB 引擎都是使用 B+树 作为索引结构。</p><p>B树称为多路平衡查找树，B+树是在B树基础上的变现，二者都是多叉平衡树。</p><h4 id="B树">B树</h4><p><img src="https://cos.youngsay.cn/blog/202211282118366.png" alt="image-20221128203706890"></p><h4 id="B-树">B+树</h4><p><img src="https://cos.youngsay.cn/blog/202211282118609.png" alt="image-20221128203611266"></p><h4 id="区别和联系">区别和联系</h4><ul><li><p>B树N个值，划分为N+1个结点；B+树N个值，划分为N个结点。</p></li><li><p>B树叶子结点相互独立;B+树叶子结点是链式结构，指向相邻结点。</p></li><li><p>B树每个结点既存放key，又存放data；B+树只有叶子结点既存放key，又存放data，其他结点只存key。</p></li><li><p>B树的查找过程是对每个关键字二分查找，可能没有到叶子结点就检索到了；B+树更加稳定，每次查找都是从根节点开始，到叶子结点结束。</p></li></ul><h4 id="索引为什么要用B-树">索引为什么要用B+树</h4><ul><li>每次都是从根节点到叶子结点，IO次数都差不多，查询效率稳定。</li><li>磁盘IO请求数少，查询速度快。</li><li>叶子结点采用链式存储结构，方便数据范围查询。</li><li>非叶子结点只存储key，占用空间小，甚至可以缓存到内存中。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;索引是一种用于快速查找和检索数据的数据结构，类似于图书的目录，通过索引可以更快地找到对应的数据。&lt;/p&gt;
&lt;h3 id=&quot;索引的优缺点&quot;&gt;索引的优缺点&lt;/h3&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提高了查找的效率&lt;/li&gt;
&lt;li&gt;通过创建唯一性索引，确保了每一行数据</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="索引" scheme="https://youngsay.cn/tags/%E7%B4%A2%E5%BC%95/"/>
    
    <category term="MySQL" scheme="https://youngsay.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>socket套接字网络编程</title>
    <link href="https://youngsay.cn/2022/11/22/Java-Socket/"/>
    <id>https://youngsay.cn/2022/11/22/Java-Socket/</id>
    <published>2022-11-22T06:14:41.000Z</published>
    <updated>2022-11-22T06:49:57.565Z</updated>
    
    <content type="html"><![CDATA[<p>网络编程使计算机不再是一个孤立的个体，而是一个互联的整体，通过网络编程，可实现主机各进程间的数据传输。网络编程的核心就是套接字socket。socket是由系统提供用于网络通信的技术，是基于TCP/IP协议的网络通信的基本操作单元。</p><p>socket主要分为三类：流套接字、数据报套接字、原始套接字。我们这里主要介绍前两种：</p><p><strong>流套接字</strong>：使用传输层TCP协议，提供面向连接、可靠的数据传输，面向字节流，有接收缓冲区和发送缓冲区，传输数据大小无限制。</p><p><strong>数据报套接字</strong>：使用传输层UDP协议，提供无连接、不可靠传输，面向数据报，只有接收缓冲区，传输大小受限，一次最多传输64K。</p><p>下面我们来看下Java中是如何使用socket来进行网络编程的。</p><h3 id="数据报套接字">数据报套接字</h3><p>Java数据报套接字编程有两个核心的类，<code>DatagramSocket</code>和<code>DatagramPacket</code>。</p><h4 id="两个核心类">两个核心类</h4><p><code>DatagramSocket</code>用于创建一个数据报套接字，用于发送和接收数据报。主要的构造方法如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>DatagramSocket()</td><td>创建一个UDP数据报套接字的Socket，绑定到本机任意一个随机端口 （一般用于客户端）</td></tr><tr><td>DatagramSocket(int port)</td><td>创建一个UDP数据报套接字的Socket，绑定到本机指定的端口（一般用 于服务端）</td></tr></tbody></table><p>常用方法如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void receive(DatagramPacket p)</td><td>从此套接字接收数据报（如果没有接收到数据报，会阻塞等待）</td></tr><tr><td>void send(DatagramPacket p)</td><td>从此套接字发送数据报包（不会阻塞等待，直接发送）</td></tr><tr><td>void close()</td><td>关闭此数据报套接字</td></tr></tbody></table><p>方法内的参数类型，就是我们要介绍的另一个核心类：<code>DatagramPacket</code>，该类表示数据报包，用于进程间的发送和接收。主要构造方法如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>DatagramPacket(byte[] buf, int length)</td><td>构造一个数据报包，<strong>用来接收</strong>，接收的数据保存在字节数组buf中，接收指定长度length</td></tr><tr><td>DatagramPacket(byte[] buf, int offset, int length, SocketAddress address)</td><td>构造一个数据报包，<strong>用来发送</strong>，发送的数据为字节数组buf，从offset到长度length，指明目标主机地址address，即IP和端口号</td></tr></tbody></table><p>常用方法如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>InetAddress getAddress()</td><td>获取该数据报发送或接收数据报的计算机的IP地址。</td></tr><tr><td>getSocketAddress()</td><td>获取该数据包发送到或正在从其发送的远程主机的SocketAddress（通常为IP地址+端口号）。</td></tr><tr><td>int getPort()</td><td>获取该数据报发送或接收数据报的端口号</td></tr><tr><td>byte[] getData()</td><td>获取数据报中的数据</td></tr><tr><td>int getLength()</td><td>返回要发送的数据的长度或接收到的数据的长度。</td></tr></tbody></table><h4 id="服务器端">服务器端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdpServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DatagramSocket socket = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UdpServer</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个服务器端的数据报套接字，通常指明端口</span></span><br><span class="line">        socket = <span class="keyword">new</span> DatagramSocket(port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;服务器已连接&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">//1.接收请求</span></span><br><span class="line">                <span class="comment">//创建数据报包，用来接收客户端发来的请求</span></span><br><span class="line">                DatagramPacket reqPacket = <span class="keyword">new</span> DatagramPacket(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>],<span class="number">1024</span>);</span><br><span class="line">                <span class="comment">//接收数据报，没有数据传来时会阻塞等待</span></span><br><span class="line">                socket.receive(reqPacket);</span><br><span class="line">                <span class="comment">//★从接收的数据报中解析数据，构造成请求字符串</span></span><br><span class="line">                String req = <span class="keyword">new</span> String(reqPacket.getData(),<span class="number">0</span>,reqPacket.getLength(),<span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">                <span class="comment">//2.构造响应</span></span><br><span class="line">                <span class="comment">//这里没有做处理，发来什么就返回什么。</span></span><br><span class="line">                String resp = process(req);</span><br><span class="line">                <span class="comment">//创建数据报包，用来发送响应</span></span><br><span class="line">                <span class="comment">//将响应字符串转换成字节数组，指明目的主机地址</span></span><br><span class="line">                DatagramPacket respPacket = <span class="keyword">new</span> DatagramPacket(resp.getBytes(),resp.getBytes().length,reqPacket.getSocketAddress());</span><br><span class="line">                <span class="comment">//3.发送响应</span></span><br><span class="line">                socket.send(respPacket);</span><br><span class="line">                <span class="comment">//4.打印日志</span></span><br><span class="line">                System.out.printf(<span class="string">&quot;[%s:%d] req: %s, resp: %s\n&quot;</span>,</span><br><span class="line">                        reqPacket.getAddress().toString(), reqPacket.getPort(), req, resp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造响应</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">process</span><span class="params">(String req)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> req;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">        UdpServer server = <span class="keyword">new</span> UdpServer(<span class="number">9090</span>);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中★处要尤为注意：</p><p>构造请求字符串的第三个参数：请求字符串长度，是接收到的数据报的长度，reqPacket.getLength()。一定不要写成reqPacket.getData().length()，这个是字节数组的长度，该代码为1024。</p><h4 id="客户端">客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdpClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port; <span class="comment">//服务器端口号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String ip; <span class="comment">//服务器ip地址</span></span><br><span class="line">    <span class="keyword">private</span> DatagramSocket socket = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UdpClient</span><span class="params">(String ip,<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个客户端的数据报套接字，通常不指明端口</span></span><br><span class="line">        <span class="keyword">this</span>.socket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">        <span class="keyword">this</span>.ip = ip;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">//0.输入请求</span></span><br><span class="line">                System.out.println(<span class="string">&quot;请输入请求：&quot;</span>);</span><br><span class="line">                Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">                String req = scanner.nextLine();</span><br><span class="line">                <span class="comment">//1.构造请求</span></span><br><span class="line">                <span class="comment">//创建一个数据报包，用来发送请求★</span></span><br><span class="line">                DatagramPacket reqPacket = <span class="keyword">new</span> DatagramPacket(req.getBytes(),req.getBytes().length,InetAddress.getByName(ip),port);</span><br><span class="line">                <span class="comment">//2.发送请求</span></span><br><span class="line">                socket.send(reqPacket);</span><br><span class="line">                <span class="comment">//创建接收数据包，用来接收服务器发来的响应</span></span><br><span class="line">                DatagramPacket respPacket = <span class="keyword">new</span> DatagramPacket(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>],<span class="number">1024</span>);</span><br><span class="line">                <span class="comment">//3.接收响应</span></span><br><span class="line">                socket.receive(respPacket);</span><br><span class="line">                String resp = <span class="keyword">new</span> String(respPacket.getData(),<span class="number">0</span>,respPacket.getLength());</span><br><span class="line">                System.out.println(<span class="string">&quot;resp：&quot;</span>+resp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">        <span class="comment">//参数内为服务器的ip和端口号</span></span><br><span class="line">        UdpClient client = <span class="keyword">new</span> UdpClient(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">9090</span>);</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码中★处：</p><p>构造发送数据包时要传入目的主机的地址，InetAddress.getByName(ip),port分别为主机的ip地址和端口号，除了这样，还可以通过创建socketAddress类来指定主机地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SocketAddress socketAddress = <span class="keyword">new</span> InetSocketAddress(ip,port);</span><br><span class="line">DatagramPacket reqPacket = <span class="keyword">new</span> DatagramPacket(req.getBytes(),req.getBytes().length,socketAddress);</span><br></pre></td></tr></table></figure><h3 id="流套接字">流套接字</h3><p>Java流套接字编程也有两个核心的类，<code>ServerSocket</code>和<code>Socket</code>。</p><h4 id="两个核心类-2">两个核心类</h4><p>ServerSockert通常用于创建一个服务器端的流套接字，常用构造方法如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>ServerSocket(int port)</td><td>创建一个服务端流套接字Socket，并绑定到指定端口</td></tr></tbody></table><p>常用方法如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Socket accept()</td><td>监听要连接此客户端的套接字，有客户端连接后，返回一个服务端Socket对象，并基于该Socket建立与客户端的连接，否则阻塞等待</td></tr><tr><td>void close()</td><td>关闭此套接字</td></tr></tbody></table><p>Socket通常用于常见一个客户端的流套接字，常用构造方法如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Socket(String host, int port)</td><td>创建一个客户端流套接字Socket，并与对应IP的主机上，对应端口的进程建立连接</td></tr></tbody></table><p>常用方法如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>InetAddress getInetAddress()</td><td>返回套接字所连接的地址</td></tr><tr><td>InputStream getInputStream()</td><td>返回此套接字的输入流</td></tr><tr><td>OutputStream getOutputStream()</td><td>返回此套接字的输出流</td></tr></tbody></table><h4 id="服务器端-2">服务器端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpServer</span> </span>&#123;</span><br><span class="line">    ServerSocket server = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TcpServer</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个服务器套接字，指定服务器端口号</span></span><br><span class="line">        server = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//监听客户端并建立连接</span></span><br><span class="line">            Socket client = server.accept();</span><br><span class="line">            processConnection(client);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConnection</span><span class="params">(Socket client)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;[%s,%d]客户端建立连接\n&quot;</span>,client.getInetAddress(),client.getPort());</span><br><span class="line">        <span class="comment">//创建输入输出流，输入流用来接收客户端传来的数据，输出流用来将数据发给客户端</span></span><br><span class="line">        <span class="keyword">try</span>(InputStream inputStream = client.getInputStream())&#123;</span><br><span class="line">            <span class="keyword">try</span>(OutputStream outputStream = client.getOutputStream())&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    Scanner scanner = <span class="keyword">new</span> Scanner(inputStream);</span><br><span class="line">                    <span class="keyword">if</span>(!scanner.hasNext())&#123;</span><br><span class="line">                        System.out.printf(<span class="string">&quot;[%s,%d]客户端断开连接&quot;</span>,client.getInetAddress(),client.getPort());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//1.接收请求</span></span><br><span class="line">                    String req = scanner.nextLine();</span><br><span class="line">                    <span class="comment">//2.构造响应</span></span><br><span class="line">                    String resp = process(req);</span><br><span class="line">                    <span class="comment">//3.返回响应</span></span><br><span class="line">                    PrintWriter printWriter = <span class="keyword">new</span> PrintWriter(outputStream);</span><br><span class="line">                    <span class="comment">//★调用println方法，不能是print和write</span></span><br><span class="line">                    printWriter.println(resp);</span><br><span class="line">                    printWriter.flush();</span><br><span class="line">                    System.out.printf(<span class="string">&quot;req:%s,resp:%s\n&quot;</span>,req,resp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//★关闭连接</span></span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">process</span><span class="params">(String req)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> req;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        TcpServer server = <span class="keyword">new</span> TcpServer(<span class="number">9090</span>);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>★处要尤为注意：</p><ol><li><p>调用的是println方法，不是print也不是write。println方法会为写入的数据后面添加上换行符，而print和write不会。客户端接收数据时是以换行符为结束来获取数据。如果找不到换行符，将一直不能接收响应，造成阻塞。同理，客户端发送请求时也要使用println方法，否则服务器也会接收不到请求而一直阻塞。</p></li><li><p>大家可能会想，为什么这里的client要关闭连接，而server和之前的数据报套接字都不需要关闭连接。关闭连接的前提是不再使用了，对于UDP和ServerSocket，它们是贯穿程序始终的，而这里的client，也就是Socket，每个连接都有一个Socket，断开连接也就不再需要这个Socket了，需要进行释放。</p></li></ol><h4 id="客户端-2">客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line">    Socket client = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TcpClient</span><span class="params">(String ip,<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.ip = ip;</span><br><span class="line">        <span class="comment">//★创建客户端套接字，并将其连接到指定IP地址的指定端口号。</span></span><br><span class="line">        <span class="keyword">this</span>.client = <span class="keyword">new</span> Socket(ip,port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>(InputStream inputStream = client.getInputStream()) &#123;</span><br><span class="line">            <span class="keyword">try</span>(OutputStream outputStream = client.getOutputStream())&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="comment">//1.构造请求</span></span><br><span class="line">                    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">                    String req = scanner.next();</span><br><span class="line">                    <span class="comment">//2.发送请求</span></span><br><span class="line">                    PrintWriter printWriter = <span class="keyword">new</span> PrintWriter(outputStream);</span><br><span class="line">                    <span class="comment">//★调用println方法，不能是print和write</span></span><br><span class="line">                    printWriter.println(req);</span><br><span class="line">                    printWriter.flush();</span><br><span class="line">                    <span class="comment">//3.接收响应</span></span><br><span class="line">                    Scanner respScan = <span class="keyword">new</span> Scanner(inputStream);</span><br><span class="line">                    String resp = respScan.next();</span><br><span class="line">                    System.out.println(<span class="string">&quot;resp:&quot;</span>+resp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        TcpClient client = <span class="keyword">new</span> TcpClient(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">9090</span>);</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题">问题</h4><p>流套接字的客户端服务器通信还存在一个问题，只能满足一个客户端的通信。其他客户端尝试与服务器连接时，会发生阻塞。观察服务器代码中下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="comment">//监听客户端并建立连接</span></span><br><span class="line">        Socket client = server.accept();</span><br><span class="line">        processConnection(client);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端1与服务器建立连接后，服务器线程执行processConnection代码中的操作，代码中存在while循环，不断地接收客户端1发来的请求，构造响应，返回响应……此时客户端2想要与服务器通信，而服务器线程正在processConnection的while循环中等待客户端1的请求，导致服务器不能与客户端2建立连接。</p><p>TCP每次都需要建立连接，只能支持一对一，也就是端到端的通信。就像打电话一样，同一时间只能接听一个电话，当正在通话时，别的电话是打不进来的。而UDP是无连接的，因此支持一对一、一对多、多对多交互通信。所以我们在数据报套接字时没有出现该问题。</p><p>解决办法也很简单，因为processConnection中的循环未结束导致服务器不能执行accept操作，所以单独创建一个新的线程来完成processConnection操作即可。我们可以用多线程或线程池来解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="comment">//建立连接</span></span><br><span class="line">        Socket client = server.accept();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                processConnection(client);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其他代码不变，只需改动start方法内的代码，为processConnection操作创建新的线程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网络编程使计算机不再是一个孤立的个体，而是一个互联的整体，通过网络编程，可实现主机各进程间的数据传输。网络编程的核心就是套接字socket。socket是由系统提供用于网络通信的技术，是基于TCP/IP协议的网络通信的基本操作单元。&lt;/p&gt;
&lt;p&gt;socket主要分为三类：</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="socket" scheme="https://youngsay.cn/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>Java文件和IO流</title>
    <link href="https://youngsay.cn/2022/11/17/Java-IO/"/>
    <id>https://youngsay.cn/2022/11/17/Java-IO/</id>
    <published>2022-11-17T12:14:41.000Z</published>
    <updated>2022-11-17T12:21:05.099Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文件基础操作">文件基础操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个hello的目录</span></span><br><span class="line">    File dir = <span class="keyword">new</span> File(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!dir.exists())&#123;</span><br><span class="line">        dir.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在hello目录下创建一个hello.txt文件</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(dir+<span class="string">&quot;/hello.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">        file.createNewFile();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到文件名</span></span><br><span class="line">    System.out.println(file.getName());</span><br><span class="line">    <span class="comment">//得到文件的绝对路径</span></span><br><span class="line">    System.out.println(file.getAbsolutePath());</span><br><span class="line">    <span class="comment">//得到文件的规范路径，当路径不规范时，会进行优化(去掉.)</span></span><br><span class="line">    System.out.println(file.getCanonicalPath());</span><br><span class="line">    <span class="comment">//得到父目录名</span></span><br><span class="line">    System.out.println(file.getParent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体详见：<a href="https://docs.oracle.com/javase/8/docs/api/">File (Java Platform SE 8 ) (oracle.com)</a></p><h3 id="IO流">IO流</h3><p>IO即输入和输出（Input、Output），输入就是将数据读入到内存，输出就是将数据输出到外部存储（如文件、数据库）。数据的输入输出就像水流一样，因此成为IO流。</p><p>IO流的处理方式可分为两种：字节流和字符流。Java中针对IO流的处理有很多类，但最基本的只有4个抽象类。<code>InputStream</code>、<code>OutputStream</code>、<code>Reader</code>、<code>Writer</code>，前两个是对字节流的输入输出，后两个是对字符流的输入输出。下面我们拿普通文件的读写举例，介绍它们的基本操作。</p><h4 id="字节流">字节流</h4><h5 id="InputStream">InputStream</h5><p>用于对文件进行读操作，构造方法内可以是一个文件类型的参数，也可以是一个文件路径(字符串)的参数。</p><p>常用方法：</p><p><code>read()</code> ：一次读取一字节，返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。返回 <code>-1</code> ，表示读到文件的末尾，读取结束。</p><p><code>read(byte b[ ])</code> : 一次读取多个字节，将输入流字节存储到数组b，返回结果为读取字节长度。返回-1，表示读到文件的末尾，读取结束。</p><p><code>read(byte b[], int off, int len)</code> ：在<code>read(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</p><p><code>close()</code> ：关闭输入流释放相关的系统资源。</p><ul><li>一次读取一字节</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readOne</span><span class="params">(File file,FileInputStream fileInputStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fileInputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> read = fileInputStream.read();</span><br><span class="line">            <span class="keyword">if</span>(read==-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一次读取多个字节</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readByte</span><span class="params">(File file,FileInputStream inputStream)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> read = inputStream.read(bytes);</span><br><span class="line">            <span class="keyword">if</span>(read==-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; read; i++) &#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>)bytes[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="OutputStream">OutputStream</h5><p>用于对文件进行写操作，构造方法内可以是一个文件类型的参数，也可以是一个文件路径(字符串)的参数，同时可以指定第二个参数表示是否追加写入(是否清空之前的内容)，true表示追加写入，默认为false。</p><p>在写操作时数据暂时放在缓存区，只有缓存区满后才会真正写入到设备，所以别忘了调用<code>fulsh()</code>，防止数据没有写入设备。</p><p>常用方法：</p><p><code>write(int b)</code> ：将特定字节写入输出流。</p><p><code>write(byte b[ ])</code> : 将数组<code>b</code> 写入到输出流，等价于 <code>write(b, 0, b.length)</code> 。</p><p><code>write(byte[] b, int off, int len)</code> : 在<code>write(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</p><p><code>flush()</code> ：刷新此输出流并强制写出所有缓冲的输出字节。</p><p><code>close()</code> ：关闭输出流释放相关的系统资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeOne</span><span class="params">(File file, FileOutputStream outputStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        outputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        outputStream.write(<span class="number">103</span>);</span><br><span class="line">        outputStream.write(<span class="number">104</span>);</span><br><span class="line">        outputStream.flush();</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符流">字符流</h4><p>字节是电脑中存储信息的基本单位，那为什么还需要字符流呢？</p><p>当存储信息中有中文时，以字节流来读取会出现乱码。字节流更适用于音频、图片等类型文件，当文件中涉及字符类型时，使用字符流更好。字符流默认编码是<code>unicode</code>。</p><p>常见的字符编码：<code>utf8</code> :英文占 1 字节，中文占 3 字节，<code>unicode</code>：任何字符都占 2 个字节，<code>gbk</code>：英文占 1 字节，中文占 2 字节。</p><h5 id="Reader">Reader</h5><p>常用方法：</p><p><code>read()</code> : 从输入流读取一个字符。</p><p><code>read(char[] cbuf)</code> : 从输入流中读取一些字符，并将它们存储到字符数组 <code>cbuf</code>中，等价于 <code>read(cbuf, 0, cbuf.length)</code> 。</p><p><code>read(char[] cbuf, int off, int len)</code> ：在<code>read(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</p><p><code>close()</code> : 关闭输入流并释放相关的系统资源。</p><ul><li>一次读取一个字符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readOne</span><span class="params">(File file,Reader reader)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        reader = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> read = reader.read();</span><br><span class="line">            <span class="keyword">if</span>(read==-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一次读取多个字符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readCharacter</span><span class="params">(File file,Reader reader)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        reader = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">        <span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> read = reader.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (read==-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String s = <span class="keyword">new</span> String(buffer,<span class="number">0</span>,read);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Writer">Writer</h5><p>常用方法：</p><p><code>write(int c)</code> : 写入单个字符。</p><p><code>write(char[] cbuf)</code> ：写入字符数组 <code>cbuf</code>，等价于<code>write(cbuf, 0, cbuf.length)</code>。</p><p><code>write(char[] cbuf, int off, int len)</code> ：在<code>write(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</p><p><code>write(String str)</code> ：写入字符串，等价于 <code>write(str, 0, str.length())</code> 。</p><p><code>write(String str, int off, int len)</code> ：在<code>write(String str)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</p><p><code>append(CharSequence csq)</code> ：将指定的字符序列附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</p><p><code>append(char c)</code> ：将指定的字符附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</p><p><code>flush()</code> ：刷新此输出流并强制写出所有缓冲的输出字符。</p><p><code>close()</code>:关闭输出流释放相关的系统资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeOne</span><span class="params">(File file,Writer writer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        writer = <span class="keyword">new</span> FileWriter(file);</span><br><span class="line">        writer.write(<span class="string">&quot;我是panghutx&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;文件基础操作&quot;&gt;文件基础操作&lt;/h3&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="IO" scheme="https://youngsay.cn/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>多线程实例：线程池</title>
    <link href="https://youngsay.cn/2022/11/14/Java-ThreadPool/"/>
    <id>https://youngsay.cn/2022/11/14/Java-ThreadPool/</id>
    <published>2022-11-14T09:04:41.000Z</published>
    <updated>2022-11-14T10:43:43.259Z</updated>
    
    <content type="html"><![CDATA[<p>顾名思义，线程池就是存放线程的池子。直接用线程不就好了吗，为什么还需要线程池呢？</p><p>相比进程，线程已经轻量很多了，创建和销毁线程消耗的资源会少很多，但终究还是有消耗的。为了进一步降低消耗，我们需要用到线程池。需要用到线程时不用申请，直接从线程池中取，用完之后也不用销毁，再放进线程池。</p><p>标准库中的线程池（简化版本)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService pool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    pool.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟实现一个简化版本的线程池：</p><ol><li>描述任务：直接用Runnable接口即可</li><li>组织任务：用到阻塞队列</li><li>描述工作线程：创建Worker类继承Thread，重写run方法，从阻塞队列中取任务，然后执行任务</li><li>组织工作线程：实例化工作线程，加入到线程池，启动线程</li><li>提交任务：往线程池中添加任务（具体是将任务添加到阻塞队列）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreatPool</span> </span>&#123;</span><br><span class="line">    <span class="comment">//描述一个任务</span></span><br><span class="line">    <span class="comment">//组织一个任务</span></span><br><span class="line">    BlockingDeque&lt;Runnable&gt; queue = <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;();</span><br><span class="line">    <span class="comment">//描述一个线程</span></span><br><span class="line">    <span class="comment">//线程是用来执行任务的，而任务都存放在队列中</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="comment">//通过构造方法能够拿到外面的queue</span></span><br><span class="line">        <span class="keyword">private</span> BlockingDeque&lt;Runnable&gt; queue = <span class="keyword">null</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(BlockingDeque&lt;Runnable&gt; queue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.queue = queue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//从queue中取任务，然后执行任务</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Runnable runnable = queue.take();</span><br><span class="line">                    runnable.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//组织线程,创建线程</span></span><br><span class="line">    List&lt;Worker&gt; workers = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreatPool</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//创建线程，存放到线程池,执行线程</span></span><br><span class="line">            Worker worker = <span class="keyword">new</span> Worker(queue);</span><br><span class="line">            workers.add(worker);</span><br><span class="line">            worker.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提交任务到线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sumbit</span><span class="params">(Runnable runnable)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        queue.put(runnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreatPool pool = <span class="keyword">new</span> ThreatPool(<span class="number">10</span>);<span class="comment">//线程数10</span></span><br><span class="line">        <span class="comment">//执行1000个任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> workId = i;</span><br><span class="line">            pool.sumbit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;任务:&quot;</span>+workId+Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;顾名思义，线程池就是存放线程的池子。直接用线程不就好了吗，为什么还需要线程池呢？&lt;/p&gt;
&lt;p&gt;相比进程，线程已经轻量很多了，创建和销毁线程消耗的资源会少很多，但终究还是有消耗的。为了进一步降低消耗，我们需要用到线程池。需要用到线程时不用申请，直接从线程池中取，用完之后也不</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="多线程" scheme="https://youngsay.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程实例：定时器</title>
    <link href="https://youngsay.cn/2022/11/14/Java-Timer/"/>
    <id>https://youngsay.cn/2022/11/14/Java-Timer/</id>
    <published>2022-11-14T07:04:41.000Z</published>
    <updated>2022-11-14T07:18:08.606Z</updated>
    
    <content type="html"><![CDATA[<p>定时器是实际开发中常用的组件，例如文章的定时发布，双11的准点抢购活动等。</p><p>下面我们来看一下Java标准库中的定时器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">    timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该定时器会在3秒之后输出“hello”。创建一个定时器需要用到Timer类中的核心方法schedule，该方法内有两个参数，一个表示要执行的任务，一个表示任务在多长时间后执行。</p><p>认识了标准库中的定时器后，我们可以自己来模拟实现一个定时器。</p><p>首先，描述一个任务。创建一个MyTask类，类中有两个属性：一个是执行的任务，一个是任务执行时间。这两个属性类似于标准库schedule方法内的两个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">MyTask</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//具体要干啥</span></span><br><span class="line">    <span class="keyword">private</span> Runnable runnable;</span><br><span class="line">    <span class="comment">//啥时候开始干</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(Runnable runnable,<span class="keyword">long</span> dalay)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.runnable = runnable;</span><br><span class="line">        <span class="keyword">this</span>.time=System.currentTimeMillis()+dalay;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        runnable.run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(MyTask o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//时间小的排在前面</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (<span class="keyword">this</span>.time-o.time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，组织一个任务类。如何组织任务类呢，我们这里用到<strong>优先级阻塞队列</strong>。每个任务的执行时间（指的是在多长时间后执行）不同，根据时间大小来排序，进而优先执行队头任务，因此需要优先级队列。</p><p>最后，我们还需要一个线程不断的去扫描到了时间的任务，然后执行这个任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTimer</span></span>&#123;</span><br><span class="line">    <span class="comment">//组织一个任务</span></span><br><span class="line">    <span class="keyword">private</span> PriorityBlockingQueue&lt;MyTask&gt; queue = <span class="keyword">new</span> PriorityBlockingQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Object locker = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(Runnable runnable,<span class="keyword">long</span> delay)</span></span>&#123;</span><br><span class="line">        MyTask myTask = <span class="keyword">new</span> MyTask(runnable,delay);</span><br><span class="line">        queue.put(myTask);</span><br><span class="line">        <span class="keyword">synchronized</span> (locker)&#123;</span><br><span class="line">            locker.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行到时间的任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTimer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//取队首元素</span></span><br><span class="line">                    MyTask task = queue.take();</span><br><span class="line">                    <span class="keyword">long</span> time=System.currentTimeMillis();</span><br><span class="line">                    <span class="keyword">if</span>(time&lt;task.getTime())&#123;</span><br><span class="line">                        <span class="comment">//时间还没到</span></span><br><span class="line">                        queue.put(task);</span><br><span class="line">                        <span class="keyword">synchronized</span> (locker)&#123;</span><br><span class="line">                            locker.wait(task.getTime()-time);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//到时间了，执行这个任务</span></span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟一个定时器，总共分三步。第一步，<s>把冰箱打开</s>描述一个任务，即要执行的任务和任务多长时间后开始执行。第二步，组织一个任务，这里用到了优先级阻塞队列。第三步，利用一个线程扫描任务，执行到时间的任务。</p><p>下面有两个问题需要注意。</p><ol><li>任务类要放进优先级阻塞队列中，优先级阻塞队列根据时间先后进行排序。因此我们的任务类要实现<code>Comparable&lt;MyTask&gt;</code>接口，然后重写比较规则。</li><li>线程扫描任务，会从队头取元素，判断是否到时间了，如果没到，再放回队列。接着继续取元素……如果不加限制，它一直不停的扫描队首元素, 看看是否能执行这个任务，这样会大量消耗CPU。因此我们利用wait来使这个线程等待，时间到后再唤醒。此外当新加入一个任务后我们也需要用notify来唤醒扫描线程，因为可能该任务的时间更小，优先级更高，所以需要重新扫描任务队列。（这也就决定了必须用wait，而不能用sleep，因为sleep不能中途唤醒）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;定时器是实际开发中常用的组件，例如文章的定时发布，双11的准点抢购活动等。&lt;/p&gt;
&lt;p&gt;下面我们来看一下Java标准库中的定时器。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="多线程" scheme="https://youngsay.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程实例：阻塞队列</title>
    <link href="https://youngsay.cn/2022/11/14/Java-BlockingQueue/"/>
    <id>https://youngsay.cn/2022/11/14/Java-BlockingQueue/</id>
    <published>2022-11-14T04:04:41.000Z</published>
    <updated>2022-11-14T04:21:36.271Z</updated>
    
    <content type="html"><![CDATA[<p>阻塞队列是一种具有阻塞功能的队列，满足队列“先进先出”的特点，是一种线性安全的数据结构。当队列为空时，执行出队操作会进行阻塞，直到队列中有元素为止；当队列已经满了，执行入堆操作会进行阻塞，知道队列有空间为止。</p><p>阻塞队列的一个典型应用常见就是“生产者消费者”模型。毫无疑问，该模型有两个主体：生产者和消费者。生产者线程负责生产产品，将生产好的产品放进阻塞队列。消费者线程负责消费产品，直接从阻塞队列取产品。</p><p>生产者消费者模型具有解耦、平衡速度差异的特点。</p><p>解耦：生产者无需关注是谁在消费产品，消费了多少产品，只需关注生产操作即可；消费者无需关注是谁在生产产品，生产了多少产品，只需关注消费操作即可。</p><p>平衡速度差异：设想11.11，大量用户向服务器发送了大量的支付请求，一次性将这些请求交给服务器处理，服务器可能会hole不住，因此将这些请求都放进阻塞队列，消费者线程从阻塞队列一个一个地来处理请求就好了。这样就起到了“削峰填谷”的作用，平衡了生产者和消费者之间的速度差异。</p><h3 id="标准库中的阻塞队列：">标准库中的阻塞队列：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    BlockingDeque&lt;String&gt; queue = <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;();</span><br><span class="line">    queue.put(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    String s = queue.take();</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>BlockingQueue 是一个接口. 真正实现的类是 LinkedBlockingQueue.</li><li>put 方法用于阻塞式的入队列, take 用于阻塞式的出队列.</li><li>BlockingQueue 也有 offer, poll, peek 等方法, 但是这些方法不带有阻塞特性</li></ul><h3 id="模拟实现阻塞队列：">模拟实现阻塞队列：</h3><ul><li>循环队列+阻塞等待</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] elem = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object locker = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> val)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (locker)&#123;</span><br><span class="line">            <span class="comment">//队列满了，阻塞等待</span></span><br><span class="line">            <span class="keyword">if</span>(size==elem.length)&#123;</span><br><span class="line">                locker.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//一轮循环，让尾指针指向数组下标为0的位置</span></span><br><span class="line">            <span class="keyword">if</span>(tail==elem.length)&#123;</span><br><span class="line">                tail=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            elem[tail++]=val;</span><br><span class="line">            size++;</span><br><span class="line">            <span class="comment">//唤醒消费者线程的堵塞等待</span></span><br><span class="line">            locker.notify();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (locker)&#123;</span><br><span class="line">            <span class="comment">//队列空了，阻塞等待</span></span><br><span class="line">            <span class="keyword">if</span>(size==<span class="number">0</span>)&#123;</span><br><span class="line">                locker.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(head==elem.length)&#123;</span><br><span class="line">                head=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> ret = elem[head];</span><br><span class="line">            head++;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="comment">//唤醒生产者线程的堵塞等待</span></span><br><span class="line">            locker.notify();</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyQueue queue = <span class="keyword">new</span> MyQueue();</span><br><span class="line">        <span class="comment">//生产者线程</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.put(i);</span><br><span class="line">                    System.out.println(<span class="string">&quot;生产了：&quot;</span>+i);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//消费者线程</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> take = queue.take();</span><br><span class="line">                    System.out.println(<span class="string">&quot;消费了：&quot;</span>+take);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;阻塞队列是一种具有阻塞功能的队列，满足队列“先进先出”的特点，是一种线性安全的数据结构。当队列为空时，执行出队操作会进行阻塞，直到队列中有元素为止；当队列已经满了，执行入堆操作会进行阻塞，知道队列有空间为止。&lt;/p&gt;
&lt;p&gt;阻塞队列的一个典型应用常见就是“生产者消费者”模型</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="多线程" scheme="https://youngsay.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java线程的创建及状态</title>
    <link href="https://youngsay.cn/2022/10/12/Java-Thread/"/>
    <id>https://youngsay.cn/2022/10/12/Java-Thread/</id>
    <published>2022-10-12T13:04:41.000Z</published>
    <updated>2022-11-14T10:47:20.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是线程">什么是线程</h2><p>在计算机中，一个任务就是一个进程。打开任务管理器，我们可以看见多个进程。如浏览器，QQ。线程是进程的再划分，是进程的一部分。一个进程可以只有一个线程（主线程），也可以有多个线程。拿浏览器举例，打开浏览器的多个网页，一个网页在播放音乐，一个网页在播放视频，一个网页在浏览博客。每个网页有不同的分工，这些浏览器的每个子任务就是一个线程。</p><p>线程是更轻量的进程，创建一个线程的消耗要低于创建一个进程，且同一进程的不同线程之间可以共享资源，效率更高。通过多线程可以更好地实现并发编程。</p><p><strong>进程vs线程</strong></p><ul><li>进程包含线程，进程是线程的一部分，一个进程中至少包含一个线程。</li><li>进程与进程之间不能共享资源，同一个进程的线程之间可以共享资源。</li><li>进程是系统分配资源的最小单位，线程是系统调度执行的最小单位。</li><li>多进程稳定性高于多线程，一个进程的崩溃不会影响其他线程；多线程下一个线程的崩溃可能影响该进程。</li></ul><h2 id="创建线程">创建线程</h2><p>一个线程至少包含一个进程，<code>main()</code>就是一个线程，我们还可以在里面创建多个线程。</p><p><strong>1.继承<code>Thread</code>类,重写<code>run()</code>方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.创建<code>Thread</code>实例，实现<code>Runnable</code>接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.其他变形</strong></p><ul><li>匿名内部类创建Thread子类对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;使用匿名类创建 Thread 子类对象&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>匿名内部类创建Runnable子类对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;使用匿名类创建 Runnable 子类对象&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>lambda表达式创建Thread子类对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread t4 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;使用匿名类创建 Thread 子类对象&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Thread方法"><code>Thread</code>方法</h2><p><strong>常见构造方法</strong></p><table><thead><tr><th>构造方法</th></tr></thead><tbody><tr><td><code>Thread()</code>  分配一个新的 <code>Thread</code>对象。</td></tr><tr><td><code>Thread(Runnable target)</code>  分配一个新的 <code>Thread</code>对象。</td></tr><tr><td><code>Thread(Runnable target, String name)</code>  分配一个新的 <code>Thread</code>对象，name为新线程的名字。</td></tr><tr><td><code>Thread(String name)</code>  分配一个新的 <code>Thread</code>对象，name为新线程的名字。</td></tr></tbody></table><p><strong>启动一个线程.start()</strong></p><p>Thread对象对创建后，并没有启动线程，执行该指令后才会真正创建一个线程。即内核中创建了一个内存控制块PCB。</p><p><strong>中断一个线程</strong></p><p>方法1：自定义变量作为标志位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义变量flag作为标志位</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程正在运行&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>); <span class="comment">//使线程进入休眠状态</span></span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：<code>interrupted()</code>方法中断线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程运行中&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Thread.currentThread().isInterrupted()</code>获取当前线程是否被中断；<code>interrupted()</code>向线程发出中断请求。</p><p>Thread收到通知方式有两种：①当线程因wait/sleep/join等方法处于堵塞状态时，以 <code>InterruptedException </code>异常的形式通知。②<code>isInterrupted()</code>标志位置为true.</p><p><strong>等待一个线程.join()</strong></p><p>执行该指令，会使该线程执行结束后再执行下一线程，即将并发编程变成了串行。比如用某软件下载一部电影，可以边下载边观看，当执行该指令后，就要等下载完后再看了~</p><p><strong>休眠一个线程sleep()</strong></p><p>让线程进入休眠状态，进入休眠状态的指令，他的属性<code>isAlive()</code>为Timed Waiting。线程状态会稍后介绍到。</p><h2 id="线程状态">线程状态</h2><p>注意，这里我们说的是java线程的六种状态。利用<code>isAlive</code>属性可以观察线程的状态，线程有以下6种状态：</p><ul><li>New：新创建的线程，但未执行<code>start()</code>，线程没有存活；</li><li>Runnable：运行中的线程，正在执行<code>run()</code>方法的Java代码；</li><li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li><li>Waiting：运行中的线程，因为某些操作在等待中，如执行<code>wait()</code>方法；</li><li>Timed Waiting：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待；</li><li>Terminated：线程结束，线程没有存活。</li></ul><h2 id="线程状态转换">线程状态转换</h2><p>线程被创建出来，处于New状态。调用start方法后，处于Runnable状态。当线程获取不到锁时，处于Blocked状态，直到获取到锁后进入Runnable状态。运行的线程调用wait或join方法后会进入Waiting状态，直到唤醒通知后进入Runnable状态。调用带有超时参数的方法后会进入Timed Waiting状态，直到时间到后进入Runnable状态。运行的线程执行完run方法或出现异常后进入Terminated状态。</p><p>与操作系统中的进程状态不同，java没有就绪态。操作系统中，一个进程调用start后并没有直接运行，而是进入就绪态，当获取到cpu时间片后进入运行态。我们可以认为在java中，就绪态和运行态同属于Runnable。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是线程&quot;&gt;什么是线程&lt;/h2&gt;
&lt;p&gt;在计算机中，一个任务就是一个进程。打开任务管理器，我们可以看见多个进程。如浏览器，QQ。线程是进程的再划分，是进程的一部分。一个进程可以只有一个线程（主线程），也可以有多个线程。拿浏览器举例，打开浏览器的多个网页，一个网页</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="多线程" scheme="https://youngsay.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程安全及解决方案</title>
    <link href="https://youngsay.cn/2022/09/26/Thread-safe/"/>
    <id>https://youngsay.cn/2022/09/26/Thread-safe/</id>
    <published>2022-09-26T09:40:41.000Z</published>
    <updated>2022-11-14T04:22:10.251Z</updated>
    
    <content type="html"><![CDATA[<p>安全，已经成为非常重要的社会话题。所谓“安全第一”，“安全无小事”（手动滑稽），同样，多线程中，线程安全也是非常重要的话题。那么是什么原因造成了线程不安全，又如何解决线程不安全呢？</p><h3 id="造成线程不安全的原因">造成线程不安全的原因</h3><ol><li><p>线程的调度</p><p>各线程之间是抢占式执行的，线程的执行顺序是随机的，因此可能会产生各种问题。现在最流行什么？做核酸！如果做核酸是抢占式的，做核酸没有一个顺序，做核酸顺序完全靠运气，这能安全吗！</p></li><li><p>多线程同时修改同一变量</p><p>如果是多线程同时读取同一变量，不涉及修改的操作，是线程安全的。但如果多线程同时修改同一变量，这能不乱吗？想当年家里买了一台电脑，我姐姐要用电脑玩QQ炫舞，我要用电脑玩穿越火线，你争我抢，打的是不可开交。</p></li><li><p>操作指令不是原子的</p><p>例如一条加法指令，其实要执行三条指令，load、add、save，先将内存中的变量加载到寄存器，在寄存器中完成加法操作，再将结果写会内存中。假设线程1完成了load、add操作，线程2完成了load、add、save操作，当线程1再去执行save操作，便将线程2的操作覆盖了，线程2说：线程1真是一个猪队友。</p></li><li><p>内存可见性</p><p>线程1循环进行读操作，线程2看心情进行修改操作。我们知道，读操作是将内存变量加载到寄存器，然后读取寄存器。而线程1循环加载内存中的值到寄存器，线程2又迟迟不修改，线程1说：你当我傻吗？于是线程1干脆去读取寄存器了，这就是编译器的优化。拿做核酸举例，最初是刮嗓子，但日复一日，现在有些已经是刮舌头了，这难道是疫情的优化？大部分情况下是安全的，但也可能会翻车。线程1循环读操作，线程2突然心情不好，很快啊，修改了内存中的值。而线程1却绕过了内存，从寄存器读值，这能安全吗！</p></li></ol><h3 id="解决方案">解决方案</h3><p>针对原因1，线程的调度就是抢占式执行的，我们无能为力。针对原因2，我们可以通过调整代码结构，使不同线程操作不同变量，但我这菜鸡技术，既然能写出一个bug，就能写出无数个bug，一顿调整猛如虎，结果bug乘以5.</p><p>所以我们解决方案寄托在原因3、4上。</p><p>Java中提供了<code>synchronized</code>关键字来对操作上锁。拿上面的加法操作举例，为加法这一方法加上synchronized后，就为该操作上锁了。想象要在卫生间完成加法操作，（不敢想象），小县城来的孩子线程1来执行加法操作，发现卫生间没人，他进来后把门锁上，进行加法操作。又一个小县城的孩子线程2来到卫生间前，也想要做加法操作，发现门锁了，只好等到线程1出来后才能进去，他是等也得等，不等也得等，这样就保证了操作的原子性。</p><p>Java还提供了<code>volatile</code>关键字来解决内存可见性问题，synchronized也可以解决该问题，只不过开销更大。为代码加上volatile后，就能禁止编译器进行优化，线程1无论做多少次循环读操作，都要耐心地从内存中读值，不能直接去读取寄存器中的值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;安全，已经成为非常重要的社会话题。所谓“安全第一”，“安全无小事”（手动滑稽），同样，多线程中，线程安全也是非常重要的话题。那么是什么原因造成了线程不安全，又如何解决线程不安全呢？&lt;/p&gt;
&lt;h3 id=&quot;造成线程不安全的原因&quot;&gt;造成线程不安全的原因&lt;/h3&gt;
&lt;ol&gt;
&lt;</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="多线程" scheme="https://youngsay.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java单例模式：懒汉模式和饿汉模式</title>
    <link href="https://youngsay.cn/2022/09/21/Java-Singleton/"/>
    <id>https://youngsay.cn/2022/09/21/Java-Singleton/</id>
    <published>2022-09-21T13:04:41.000Z</published>
    <updated>2022-11-14T04:21:23.114Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式，就是一个类中只有一个实例。主要有懒汉模式和饿汉模式。</p><p>饿汉模式是在类加载的同时就创建实例，而懒汉模式是使用时才创建实例。</p><h3 id="饿汉模式">饿汉模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.使用static创建一个实例，并且立即实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">//2.为了防止在其他地方不小心new这个Singleton，把方法构造为private</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//3.提供一个方法，让外面能够拿到唯一实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在多线程中，多个线程对同一数据进行读操作，线程安全。</p><h3 id="懒汉模式">懒汉模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.不立即初始化实例，使用时再初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//2.将构造方法设为private</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//3.提供方法获取实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多线程中，多个线程对同一对象进行读、写操作，线程不安全。线程不安全出现在首次创建实例时，多个线程同时调用getInstance方法，可能创造出多个实例。</p><p>改进1：</p><p>对getInstance方法加锁，保证操作的原子性，实现线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.不立即初始化实例，使用时再初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//2.将构造方法设为private</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//3.提供方法获取实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这种方法性能较差，毕竟线程不安全只出现在首次创建实例时，为getInstance方法加锁后每次都要加锁解锁，所以做如下改进。</p><p>改进2：</p><p>进入getInstance方法后首先判断instance是否为空，即是否为第一次创建实例，是才需要加锁，否则不需要加锁。同时为了避免 “内存可见性” 导致读取的 instance 出现偏差, 因此为instance加上volatile。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.不立即初始化实例，使用时再初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton1 instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//2.将构造方法设为private</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//3.提供方法获取实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;单例模式，就是一个类中只有一个实例。主要有懒汉模式和饿汉模式。&lt;/p&gt;
&lt;p&gt;饿汉模式是在类加载的同时就创建实例，而懒汉模式是使用时才创建实例。&lt;/p&gt;
&lt;h3 id=&quot;饿汉模式&quot;&gt;饿汉模式&lt;/h3&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;tabl</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="多线程" scheme="https://youngsay.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【JavaWeb】Thymeleaf模板引擎</title>
    <link href="https://youngsay.cn/2022/06/09/Java-Thymeleaf/"/>
    <id>https://youngsay.cn/2022/06/09/Java-Thymeleaf/</id>
    <published>2022-06-09T11:40:41.000Z</published>
    <updated>2022-10-20T11:58:10.263Z</updated>
    
    <content type="html"><![CDATA[<p>上篇博客中，我们了解了服务器渲染，并用Thymeleaf模板引擎写了一个简单的猜数字小游戏。</p><p>下面我们简单了解一下Thymeleaf的语法。</p><h4 id="Thymeleaf常见命令">Thymeleaf常见命令</h4><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>th:text</td><td>在标签体中展示表达式求值结果的文本内容</td></tr><tr><td>th:[HTML标签属性]</td><td>设置任意的 HTML 标签属性的值</td></tr><tr><td>th:if</td><td>当表达式的结果为真时则显示内容，否则不显示</td></tr><tr><td>th:each</td><td>循环访问元素</td></tr></tbody></table><p>Thymeleaf语法有很多，我们这里先简单介绍这四个。th:text和th:if在猜数字小游戏案例已经使用过，这里不再介绍。</p><h5 id="th-属性">th:[属性]</h5><ul><li>HTML模板代码：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;$&#123;url1&#125;&quot;</span>&gt;</span>胖虎同学<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;$&#123;url2&#125;&quot;</span>&gt;</span>胖虎同学1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Servlet代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/thymeleafUrl.html&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThymeleafUrlServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.创建核心类,用于完成页面渲染</span></span><br><span class="line">    <span class="keyword">public</span> TemplateEngine engine = <span class="keyword">new</span> TemplateEngine();</span><br><span class="line">    <span class="comment">//2.初始化模板引擎,创建解析器，加载文件，关联</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ServletContext context = getServletContext();</span><br><span class="line">        ServletContextTemplateResolver resolver = <span class="keyword">new</span> ServletContextTemplateResolver(context);</span><br><span class="line">        resolver.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        resolver.setPrefix(<span class="string">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class="line">        resolver.setSuffix(<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">        engine.setTemplateResolver(resolver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        ServletContext context = getServletContext();</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//3.实例化WebContext，关联变量</span></span><br><span class="line">        WebContext webContext = <span class="keyword">new</span> WebContext(req,resp,context);</span><br><span class="line">        webContext.setVariable(<span class="string">&quot;url1&quot;</span>,<span class="string">&quot;https://youngsay.cn&quot;</span>);</span><br><span class="line">        webContext.setVariable(<span class="string">&quot;url2&quot;</span>,<span class="string">&quot;http://blog.youngsay.cn&quot;</span>);</span><br><span class="line">        <span class="comment">//4.渲染</span></span><br><span class="line">        engine.process(<span class="string">&quot;thymeleafUrl&quot;</span>,webContext,resp.getWriter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="th-each">th:each</h5><p>列举游戏战绩：昵称、击杀、死亡、得分</p><ul><li>HTML模板代码：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">th:each</span>=<span class="string">&quot;person : $&#123;persons&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;person.name&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;person.kill&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;person.dead&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;person.score&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Servlet代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> kill;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> dead;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> kill, <span class="keyword">int</span> dead, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.kill = kill;</span><br><span class="line">        <span class="keyword">this</span>.dead = dead;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/thymeleafEach&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThymeleafEach</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建TemplateEngine对象</span></span><br><span class="line">    <span class="keyword">public</span> TemplateEngine engine = <span class="keyword">new</span> TemplateEngine();</span><br><span class="line">    <span class="comment">//初始化模板引擎</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServletContext context = getServletContext();</span><br><span class="line">        ServletContextTemplateResolver resolver = <span class="keyword">new</span> ServletContextTemplateResolver(context);</span><br><span class="line">        resolver.setPrefix(<span class="string">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class="line">        resolver.setSuffix(<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">        resolver.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        engine.setTemplateResolver(resolver);</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        List&lt;Person&gt; persons = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">        persons.add(<span class="keyword">new</span> Person(<span class="string">&quot;損友比过狗友i&quot;</span>,<span class="number">12</span>,<span class="number">2</span>,<span class="number">80</span>));</span><br><span class="line">        persons.add(<span class="keyword">new</span> Person(<span class="string">&quot;马棚管理员&quot;</span>,<span class="number">21</span>,<span class="number">8</span>,<span class="number">130</span>));</span><br><span class="line">        persons.add(<span class="keyword">new</span> Person(<span class="string">&quot;吃枣药丸&quot;</span>,<span class="number">16</span>,<span class="number">5</span>,<span class="number">110</span>));</span><br><span class="line">        ServletContext context = getServletContext();</span><br><span class="line">        WebContext webContext = <span class="keyword">new</span> WebContext(req,resp,context);</span><br><span class="line">        webContext.setVariable(<span class="string">&quot;persons&quot;</span>,persons);</span><br><span class="line"></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        engine.process(<span class="string">&quot;thymeleafEach&quot;</span>,webContext, resp.getWriter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ServletContext">ServletContext</h4><p>观察上篇博客猜数字游戏代码和上面的两段代码，我们发现，每个Servlet都创建了一个TemplateEngine对象并进行初始化，其实这完全没必要，一个webapp中，只创建一个TemplateEngine对象即可。</p><p>这就需要用到ServletContext，它是Servlet程序全局存储信息的空间，每个webapp中只有一个ServlectContext，多个Servlet之间共享一个ServlectContext。通过 HttpServlet.getServletContext() 方法获取到当前webapp 的ServletContext对象。</p><p>下面是ServletContext常见方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>void setAttribute(String name, Object obj)</td><td>设置属性(键值对)</td></tr><tr><td>Object getAttribute(String name)</td><td>根据属性名获取属性值, 如果 name 不存在, 返 回 null</td></tr><tr><td>void removeAttribute(String name)</td><td>删除对应的属性</td></tr></tbody></table><p>我们用代码来证明多个一个webapp中多个Servlet类共用一个ServletContext。</p><ul><li>创建一个WriterServlet类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/writer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取message参数</span></span><br><span class="line">        String message = req.getParameter(<span class="string">&quot;message&quot;</span>);</span><br><span class="line">        ServletContext context = getServletContext();</span><br><span class="line">        <span class="comment">//2.将message设置到ServletContext</span></span><br><span class="line">        context.setAttribute(<span class="string">&quot;message&quot;</span>,message);</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//3.返回结果</span></span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;设置成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建一个ReaderServlet类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/reader&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.读取ServletContext中的message值</span></span><br><span class="line">        ServletContext context = getServletContext();</span><br><span class="line">        String message = (String) context.getAttribute(<span class="string">&quot;message&quot;</span>);</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//2.返回读到的值</span></span><br><span class="line">        resp.getWriter().write(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cos.youngsay.cn/blog/202206101502724.gif" alt="展示结果"></p><h4 id="监听器">监听器</h4><p>要想做到一个webapp中只创建一个TemplateEngine对象，除了认识ServletContext，还需要了解监听器。</p><p>使用监听器监听ServletContext的创建，创建好后在ServletContext完成初始化操作，后续的 Servlet 直接从 ServletContext 中获取到engine实例即可，不必每创建一个Servlet都初始化一次。</p><p>首先创建一个监听器类Mylistener，实现ServletContextListener接口，重写contextInitialized方法。在contextInitialized方法内完成初始化等一系列操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.通过方法的参数可以获取到ServletContext</span></span><br><span class="line">        ServletContext context = sce.getServletContext();</span><br><span class="line">        <span class="comment">//2.创建TemplateEngine类对象engine</span></span><br><span class="line">        TemplateEngine engine = <span class="keyword">new</span> TemplateEngine();</span><br><span class="line">        <span class="comment">//3.创建解析器</span></span><br><span class="line">        ServletContextTemplateResolver resolver = <span class="keyword">new</span> ServletContextTemplateResolver(context);</span><br><span class="line">        <span class="comment">//4.加载文件</span></span><br><span class="line">        resolver.setPrefix(<span class="string">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class="line">        resolver.setSuffix(<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">        resolver.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//5.关联engine和解析器</span></span><br><span class="line">        engine.setTemplateResolver(resolver);</span><br><span class="line">        <span class="comment">//6.将engine放到ServletContext中,后续直接调用getAttribute获取engine</span></span><br><span class="line">        context.setAttribute(<span class="string">&quot;engine&quot;</span>,engine);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了MyListener类，之前代码中engine对象的创建和init方法内的初始化操作都可以删掉了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上篇博客中，我们了解了服务器渲染，并用Thymeleaf模板引擎写了一个简单的猜数字小游戏。&lt;/p&gt;
&lt;p&gt;下面我们简单了解一下Thymeleaf的语法。&lt;/p&gt;
&lt;h4 id=&quot;Thymeleaf常见命令&quot;&gt;Thymeleaf常见命令&lt;/h4&gt;
&lt;table&gt;
&lt;thea</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="JavaWeb" scheme="https://youngsay.cn/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>【JavaWeb】服务器渲染</title>
    <link href="https://youngsay.cn/2022/06/09/Java-templateEngine/"/>
    <id>https://youngsay.cn/2022/06/09/Java-templateEngine/</id>
    <published>2022-06-09T08:40:41.000Z</published>
    <updated>2022-06-09T08:44:44.970Z</updated>
    
    <content type="html"><![CDATA[<p>页面渲染，所谓渲染就是将数据和页面相结合，根据用户传送的数据不同，页面渲染后的内容也不同。页面渲染可以在服务器端完成，也可以在客户端完成。<strong>服务器渲染</strong>是将用户传来的数据在服务器端拼接成HTML后传给客户端，而<strong>客户端渲染</strong>是在客户端将服务器传来的数据拼接成HTML。</p><p><img src="https://cos.youngsay.cn/blog/202206091642034.png" alt="页面渲染"></p><h4 id="服务器渲染">服务器渲染</h4><p>这篇博客主要介绍一下服务器渲染。</p><p>我们可以用字符串拼接的方式，将数据拼接成HTML页面。下面我们用字符串拼接的方式完成一个猜数字web版的小游戏。</p><p>首先约定好交互方式。</p><ul><li>GET /guess</li></ul><p>通过get请求，从服务器得到一个页面响应，同时在服务器生成一个1-100的随机数。</p><ul><li>POST /guess</li></ul><p>通过post请求，将用户输入的数提交到服务器，在服务器比较用户输入的数和随机数的大小，将比较结果和次数返回。</p><p>约定好交互方式后，我们创建一个GuessNumServlet类，关联到/guess路径，用doGet方法实现第一个交互接口，doPost方法实现第二个交互接口。代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/guess&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuessNumServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//生成一个随机数</span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//随机数范围在[1,100]</span></span><br><span class="line">        num = random.nextInt(<span class="number">100</span>)+<span class="number">1</span>; <span class="comment">//得到一个1-100之间的随机数</span></span><br><span class="line">        <span class="comment">//设置响应的类型格式</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//字符串拼接响应页面</span></span><br><span class="line">        StringBuilder html = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        html.append(<span class="string">&quot;&lt;form action=\&quot;guess\&quot; method=\&quot;post\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        &lt;input type=\&quot;text\&quot; name=\&quot;guessNum\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        &lt;input type=\&quot;submit\&quot; value=\&quot;确认输入\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    &lt;/form&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">//返回响应</span></span><br><span class="line">        resp.getWriter().write(html.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//设置响应格式</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//得到用户猜的数字</span></span><br><span class="line">        <span class="keyword">int</span> guessNum = Integer.parseInt(req.getParameter(<span class="string">&quot;guessNum&quot;</span>));</span><br><span class="line">        String result =<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//比较用户输入的数字和生成的随机数</span></span><br><span class="line">        <span class="keyword">if</span>(guessNum&lt;num)&#123;</span><br><span class="line">            result=<span class="string">&quot;猜小了&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(guessNum&gt;num)&#123;</span><br><span class="line">            result=<span class="string">&quot;猜大了&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result=<span class="string">&quot;猜对了&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">//字符串拼接响应界面</span></span><br><span class="line">        StringBuilder html = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        html.append(<span class="string">&quot;&lt;form action=\&quot;guess\&quot; method=\&quot;post\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        &lt;input type=\&quot;text\&quot; name=\&quot;guessNum\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        &lt;input type=\&quot;submit\&quot; value=\&quot;确认输入\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    &lt;/form&gt;&quot;</span>);</span><br><span class="line">        html.append(<span class="string">&quot;&lt;div&gt;&quot;</span>+result+<span class="string">&quot;&lt;/div&gt;&quot;</span>);</span><br><span class="line">        html.append(<span class="string">&quot;&lt;div&gt;&quot;</span>+<span class="string">&quot;猜的次数：&quot;</span>+count+<span class="string">&quot;&lt;/div&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">//返回响应界面</span></span><br><span class="line">        resp.getWriter().write(html.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上段代码，我们发现十分简单的页面拼接起来却如此复杂，代码可读性不高。其实我们有一种更好的方式来完成服务器渲染，那就是<strong>模板引擎</strong>。</p><h4 id="模板引擎">模板引擎</h4><p>上面的代码Java和HTML代码都混在了一起，模板引擎可以将JAVA和HTML代码分离，将HTML放到单独的文件。HTML中需要变动的部分用占位符占位，当服务器计算响应完毕后，将HTML模板中的占位符替换成计算后的内容，返回给客户端。</p><p>Java中有很多模板引擎，这里用的是Thymeleaf 。</p><p>如何使用Thymeleaf，我们上面的猜数字小游戏为例，将上段代码改成模板引擎版本。</p><p><strong>首先需要引入依赖。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.thymeleaf/thymeleaf --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;thymeleaf&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">3.0</span><span class="number">.12</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>接着创建一个HTML模板</strong>，创建路径是<code>webapps/WEB-INF/templates  </code>,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;GuessNum&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;guessNum&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;确认输入&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;div th:<span class="keyword">if</span>=<span class="string">&quot;$&#123;!first&#125;&quot;</span>&gt;</span><br><span class="line">    &lt;div th:text=<span class="string">&quot;$&#123;result&#125;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div th:text=<span class="string">&quot;$&#123;count&#125;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>有$符号的地方就是一个占位符，最终会被替换成计算好的结果。</p><p><strong>最后创建Servlet类</strong>：<code>GuessNumTemplateEngine</code>。</p><ul><li>创建一个TemplateEngine的类，这个类是服务器渲染的核心类。</li><li>初始化模板引擎：创建一个ServletContextTemplateResolver类的解析器，结合ServletContext使用，用来加载要渲染的文件，然后与TemplateEngine相关联。</li><li>通过WebContext类将模板文件的变量与Java中的变量相关联。</li><li>通过TemplateEngine的process方法完成渲染。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/GuessNum&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuessNumTemplateEngine</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">//核心，用于完成页面的渲染</span></span><br><span class="line">    <span class="keyword">public</span> TemplateEngine engine = <span class="keyword">new</span> TemplateEngine();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> randomNum;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对模板引擎初始化</span></span><br><span class="line">        ServletContextTemplateResolver resolver = <span class="keyword">new</span> ServletContextTemplateResolver(<span class="keyword">this</span>.getServletContext());</span><br><span class="line">        resolver.setPrefix(<span class="string">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class="line">        resolver.setSuffix(<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">        resolver.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        engine.setTemplateResolver(resolver);</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        randomNum = random.nextInt(<span class="number">100</span>)+<span class="number">1</span>;</span><br><span class="line">        WebContext webContext = <span class="keyword">new</span> WebContext(req,resp,getServletContext());</span><br><span class="line">        webContext.setVariable(<span class="string">&quot;first&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        engine.process(<span class="string">&quot;guessNum&quot;</span>,webContext,resp.getWriter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html; charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//1.获取用户输入的数字</span></span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(req.getParameter(<span class="string">&quot;guessNum&quot;</span>));</span><br><span class="line">        String result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">// 2. 和 随机数 进行比较</span></span><br><span class="line">        <span class="keyword">if</span> (num &lt; randomNum) &#123;</span><br><span class="line">            result = <span class="string">&quot;猜低了&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; randomNum) &#123;</span><br><span class="line">            result = <span class="string">&quot;猜高了&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="string">&quot;猜对了&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 自增猜的次数</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">//4.返回响应界面</span></span><br><span class="line">        WebContext context = <span class="keyword">new</span> WebContext(req,resp,getServletContext());</span><br><span class="line">        context.setVariable(<span class="string">&quot;first&quot;</span>,<span class="keyword">false</span>);</span><br><span class="line">        context.setVariable(<span class="string">&quot;result&quot;</span>,result);</span><br><span class="line">        context.setVariable(<span class="string">&quot;count&quot;</span>,count);</span><br><span class="line">        engine.process(<span class="string">&quot;guessNum&quot;</span>,context,resp.getWriter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;页面渲染，所谓渲染就是将数据和页面相结合，根据用户传送的数据不同，页面渲染后的内容也不同。页面渲染可以在服务器端完成，也可以在客户端完成。&lt;strong&gt;服务器渲染&lt;/strong&gt;是将用户传来的数据在服务器端拼接成HTML后传给客户端，而&lt;strong&gt;客户端渲染&lt;/st</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="JavaWeb" scheme="https://youngsay.cn/tags/JavaWeb/"/>
    
  </entry>
  
</feed>
